### 1、css
#### 1、说一下css盒模型

 <pre>
 在html页面中的所有元素都可以看成是一个盒模型,盒模型分为两种：IE盒模型和标准W3C盒模型。
 标准W3C盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)。
 IE盒模型： 边界(margin)、内容(content 包含 边框(border)、填充(padding))。
</pre>  

#### 2、css选择器有哪些

 <pre>
 1.id选择器（ # myid）
 2.类选择器（.myclassname）
 3.标签选择器（div, h1, p）
 4.相邻选择器（h1 + p）
 5.子选择器（ul > li）
 6.后代选择器（li a）
 7.通配符选择器（ * ）
 8.属性选择器（a[rel = "external"]）
 9.伪类选择器（a: hover, li: nth-child）
</pre>  

#### 3、CSS优先级算法如何计算

<pre>
优先级就近原则，同权重情况下样式定义最近的生效
载入样式以最后载入的定位为准
优先级为:
!important > 行内样式 >  id > 类or属性选择器or伪类选择器 > tag
重要要加引号，并且要写在最前面，同时css属性不能简写。
</pre>

#### 4、CSS3新增伪类有那些

<pre>
1.p:first-of-type 选择属于其父元素的首个 p 元素。
2.p:last-of-type  选择属于其父元素的最后 p 元素。
3.p:only-of-type  选择属于其父元素唯一的 p 元素。
4.p:only-child        选择属于其父元素的唯一子元素的 p 元素。
5.p:nth-child(2)  选择属于其父元素的第二个子元素的 p 元素。
6.:enabled  :disabled 控制表单控件的禁用状态。
7.:checked        单选框或复选框被选中。
</pre>

#### 5、如何居中div

<pre>
- [x] 1.position + margin
- [x] 2.position + transform
- [x] 3.flexbox
- [x] 4.grid
</pre>

```scss
.parent-block {
  position: relative;
}

// position + margin
.center-block {
  position: absolute;
  left: 0;
  top: 0;
  right: 0;
  bottom: 0;
  margin: auto;
}

// position + transform

.center-block {
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
}

// flexbox
.parent-block {
  display: flex;
  justify-content: center;
  align-items: center;
}

// grid

.parent-block {
  display: grid;
}

.center-block {
  margin: auto;
}
```

#### 6、隐藏元素的方法
```css
.box{
    /* 设置 元素消失 不占据空间*/
    display: none;
    /* 设置透明度为0，元素不可见，占据空间*/
    opacity: 0;
    /* 让元素消失，占据空间位置*/
    visibility: hidden;
    /* 相对其他盒子*/
    position: absolute;
    /* 剪切掉这块*/
    clip-path: circle(30px);
}
```

#### 7、px与rem的区别
<pre>
    px 时像素单位，显示器上最小物理点，每个像素的大小是一样的，是一个绝对单位长度。
    rem是相对单位，
    相对于根元素html的font-size，
    根元素html的font-size默认是62.5%，
    1rem = 10px = (16px * 62.5%)，
    计算公式：
    rem = px / 根元素html的font-size
</pre>

#### 8、使用link和@import引入的区别
<pre>
    1. link是HTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。
    2. link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。
    3. link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。
    4. link支持使用Javascript控制DOM去改变样式；@import不支持。
</pre>

#### 9、title与h1的区别,b与strong的区别,i与em的区别?
<pre>
    title与h1的区别  
        1.定义
            title: 概括了网站信息，可以告诉搜索引擎或者用户关于这个网站的内容主题。
            h1: 文章主题内容，告诉蜘蛛我们的网站内容是什么。
        区别：
            1.从显示上说，title 显示在网页标题上，h1 显示在网页内容上。
            2.从seo上说，title 比 h1 添加重要（title > h1）。
        场景上：
            网站的logo都是用 h1 标签包裹的
</pre>
<pre>
    b与strong的区别
        1.定义
            b: 实体标签，表示粗体文本，没有实际意义，只是视觉上的加粗。
            strong: 逻辑标签，用来加强字符的语气，表示重要文本，有实际意义，搜索引擎会重点抓取。
        区别：
            1.b 没有语义，只是视觉上的加粗，没有实际意义，搜索引擎不会重点抓取。
            2.strong 是有语义的，表示重要文本，有实际意义，搜索引擎会重点抓取。
        场景上：
            1.b 标签一般用于表示一些小字，如：导航栏、侧边栏等。
            2.strong 标签一般用于表示一些重要文本，如：文章标题、文章内容等。
</pre>
<pre>
    i与em的区别
       1.定义
</pre>    

### 2、Echarts
#### 6、Echarts有用过吗？常用的组件有哪些？

####

<pre>
1、title标题组件 show text link
2、tooltip 提示框组件 show trigger show formatter
3、legend 图例组件 show orient data
4、toolbox 工具栏组件 show feature saveLoad dataZoom restore
5、grid 直角坐标系内绘图网格 show top left bottom right
6、xAxis 直角坐标系 grid 中的 x 轴 show type axisLabel splitLine
7、yAxis 直角坐标系 grid 中的 y 轴 show type axisLabel splitLine
8、polar 极坐标系 show angleAxis radiusAxis
9、radar 雷达图 show indicator
10、series 系列列表 show type data
11、color 颜色映射组件 show color
12、visualMap 视觉映射组件 show type dimension min max inRange outRange
13、dataZoom 数据区域缩放组件 show type start end
14、timeline 时间轴组件 show type currentIndex autoPlay
15、axisPointer 坐标轴指示器组件 show type axis line
</pre>


### 3、uni-app

#### 1、uni-app 分包

<pre>
1、分包的作用：优化小程序的下载和启动速度；
2、小程序启动默认下载主包并启动页面，当用户进入分包时，才会下载对应的分包，下载完进行展示；
3、首先在 mainfest.json mp-weixin添加以下代码（启动分包）(第一个代码块)
4、在pages.json中加入subPackages，里面是对象(第二个代码块)
</pre>

```json lines
{
  "mp-weixin": {
    "appid": "touristappid",
    "setting": {
      "urlCheck": true,
      "checkSiteMap": false
    },
    "usingComponents": true,
    //在此处加上以下一句话
    "optimization": {
      "subPackages": true
    }
  },
}
```

```json lines
{
  "pages": [
    "pages/index/index",
    "pages/good/index",
  ],
  "subpackages": [
    {
      "root": "pagesA",
      //分包的根路径，彼此之间不可以重复
      "name": "pagesA",
      //分包的标识名字，用于预加载分包时用
      "pages": [
        //分包的路径（不预加载的时候，用户进入分包路径才会加载分包资源）
        "register/register"
      ],
      "independent": false
      //是否独立分包（可以不加载主包就独立加载的包，独能立分包不当做全局资源）
    },
    {
      "root": "pagesB",
      "name": "pagesB",
      "pages": [
        "children/addChildren"
      ],
      "independent": false
    }
  ],
  //预加载
  "preloadRule": {
    "pages/index": {
      "network": "",
      "packages": [
        "pagesA"
      ]
      // 在 pages/index 页面中预加载名为 pagesA分包内容
    }
  }
}
```

### 4、webpack

####

#### 1、webpack 打包和不打包的区别

<pre>
    1、打包：将多个文件打包成一个文件，减少网络请求次数，提高运行效率；
    2、对基础的支持不够；
</pre>

#### 2、webpack 打包原理 babel是做什么的

<pre>
    webpack 会将js 、css、image 看作一个模块，用import/require引入，
    找到入口文件，通过入口文件找到关联的依赖文件，把它们打包到一起，
    把bundle文件拆分成多个小文件，异步按需加载所需要的文件。
    如果一个文件被多个文件引用，打包时只会生成一个文件
    如果引用的文件没有被调用，不会被打包，如果引入的变量和方法没有被调用，也不会被打包。
    对于多个入口文件，假如引用了相同的代码，可以用插件把它抽离到公共文件中。
    babel的作用
    1、将es6、es7、es8等高级语法转换成低级语法，让浏览器可以运行；
    2、将react、vue等高级语法转换成低级语法，让浏览器可以运行；
    3、将typescript转换成js，让浏览器可以运行；
    4、将less、sass、stylus等转换成css，让浏览器可以运行；
</pre>

### 5、算法

#### 1、数据结构

<pre>
计算机存储或者组织数据的方式
</pre>

#### 2、空间复杂度

<pre>
1、什么时空间复杂度
    空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度，它也是程序执行时间的一部分。

2、表示法
    O(1)表示常数阶，O(logN)表示对数阶，O(n)表示线性阶，O(n^2)表示平方阶，O(2^n)表示指数阶

3、如何计算
    1、只关注循环次数最多的循环，其他循环可以忽略不计；
    2、用大O表示法表示循环
</pre>

#### 3、时间复杂度

<pre>
1、什么是时间复杂度
    时间复杂度是对一个算法执行时间的长短度量，它也是程序执行时间的一个量度。

2、表示法
    O(1)表示常数阶，O(logN)表示对数阶，O(n)表示线性阶，O(n^2)表示平方阶，O(2^n)表示指数阶

3、如何计算
    1、只关注循环次数最多的循环，其他循环可以忽略不计；
    2、用大O表示法表示循环
</pre>

```javascript
// 1、时间复杂度 O(1)
let a = 1

function fn(n) {
    return n++;
}

fn(a)
// 2、时间复杂度 O(n)
for (let i = 0; i < n; i++) {
    console.log(i)
}
// 3、时间复杂度 O(n^2)
for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
        console.log(i, j)
    }
}

// 4、时间复杂度 O(2^n)
function fn(n) {
    if (n == 1) {
        return 1
    } else {
        return 2 * fn(n - 1)
    }
}

fn(n)

// 5、空间复杂度 O(logn)
let i = 1;
const n = 6;
while (i < n) {
    i = i * 2;
}

```

#### 4、栈的介绍

<pre>
栈是一种遵从后进先出(LIFO)原则的有序集合。新添加的或待删除的元素都保存在栈的顶端。

1、栈的声明
    let stack = [];

2、栈的常用方法
    push()   添加一个或多个元素到栈顶 [1,2,3] ==> [1,2,3,4]
    pop()    移除栈顶的元素，同时返回被移除的元素 [1,2,3] ==>4
    peek()   返回栈顶的元素，不对栈做任何修改(该方法不会移除栈顶的元素，仅仅返回它) [1,2,3,4] ==> 4
    empty()  如果栈里没有任何元素就返回true，否则返回false [] ==>true  [1] ==>false

3、栈的应用场景
    函数调用栈
    浏览器的前进后退
</pre>
```javascript
// 力扣题  有效的括号 时间复杂度O(n) 空间复杂度O(n)
// 输入 '(){}' 返回true 输入'(]{}' 返回false
function fn(str) {
    const stack =[];
    for(let i=0;i<str.length; i++){
        const start = str[i];
        if(str[i] === '(' || str[i] === '{' || str[i] === '['){
            stack.push(str[i]);
        }else{
            const end = stack[stack.length - 1];
            if(start ===')' && end ==='(' ||
            start===']' && end==='[' ||
            start==='}' && end==='{'){
                stack.pop();
            }else{
                return false;
            }
        }
    }
    return stack.length === 0;
}

console.log(fn('(){}')) // true
console.log(fn('(]{}')) // false
```
```javascript
// 力扣题  删除字符串中所有相邻重复项。

function fn(str) {
    const stack =[];
    for(s of str){
        let prev = stack.pop();
        if(prev !== s){
            stack.push(prev);
            stack.push(s);
        }
    }
    return stack.join('');
}

console.log(fn('abbaca')) // ca
```
```javascript
// 力扣题  简化路径

function fn(path) {
        const stack = [];
        let str = '';
        let arr = path.split('/');
        arr.forEach(item => {
            if(item && item=== '..'){
                stack.pop();
            }else if(item && item !=='.'){
                stack.push(item);
            }
        })
        return '/' + stack.join('/');
}

console.log(fn('/home/')) // /home
console.log(fn('/../')) // /
console.log(fn('/home//foo/')) // /home/foo
console.log(fn('/a/./b/../../c/')) // /c
```
```javascript
// 力扣题  移掉K位数字

function fn(num, k) {
    if(num.length <= k){
        return '0';
    }
    let stack = [];
    for(let i = 0; i < num.length; i++){
        while(k && stack.length && stack[stack.length-1] > num[i]){
            stack.pop();
            k--;
        }
        stack.push(num[i]);
    }
    stack.splice(0, k);
    let res = stack.join('');
    return res.length ? res : '0';
}

console.log(fn('1432219',3)) // 1219
```

#### 5、队列的介绍
队列是遵循FIFO（先进先出）原则的一组有序的项。队列在尾部添加新元素，并从顶部移除元素。

### 6、Javascript
#### 1、为什么 javascript 是单线程？
<pre>
    JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么 JavaScript 不能有多个线程呢？
    这样可以同时执行多个任务，提高性能，减少延迟。
    
    JavaScript 单线程，与它的用途有关。作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM。
    这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，
    另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？

    所以，为了避免复杂性，从一诞生，JavaScript 就是单线程，这已经成了这门语言的核心特征，将来也不会改变.
</pre>

#### 2、javascript 是单线程，怎么执行异步代码？
<pre>
    JavaScript 语言的执行环境是“单线程”的，也就是说，一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，
    再执行后面一个任务，以此类推。
    1、同步任务
        同步任务都在主线程上执行，形成一个执行栈。
    2、异步任务（宏任务、微任务）
        除了同步任务以外，其他任务都属于异步任务，又可以分成两种：
        1. 普通事件，如click、resize等。
        2. 资源加载，如load、error等。
        3. 定时器，包括setInterval、setTimeout等。
        4.promise对象。
        5.async/await。
    3、宏任务
        script(整体代码), setTimeout, setInterval, setImmediate(Node.js 环境), requestAnimationFrame(浏览器环境)，
        I/O, UI rendering(浏览器环境)，网络请求
    4、微任务
        process.nextTick(Node.js 环境), Promise.then(null), Promise.catch(null), Promise.finally(null
        promise 回调 、DOM变动观察器
    5、事件循环
        1. 执行一个宏任务（栈中没有就从事件队列中获取）
        2. 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中
        3. 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
        4. 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染
        5. 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）
        6. 如此循环
    6、任务队列
        1. 同步任务都在主线程上执行，形成一个执行栈。
        2. 主线程之外，还存在一个"任务队列"。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。
        3. 一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异
        步任务，于是结束等待状态，进入执行栈，开始执行。
        4. 主线程不断重复上面的第三步。
    7、JS执行流程
        1. 主线程读取JS代码，此时是在同步环境，形成对应的堆和执行栈；
        2. 主线程遇到异步任务，会推给异步线程进行处理；
        3. 异步线程处理完毕后，将对应的异步任务推到任务队列中；
        4. 主线程查询任务队列，执行微任务，将其按照顺序执行，全部执行完毕。
        5. 主线程查询任务队列，执行宏任务，取得第一个宏任务，执行完毕。
        5. 主线程不断重复第四步。
        
    异步任务相关的事件回调函数都在任务队列中等待。
    一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会按次序读取任务队列，将可运行的
    异步任务添加到可执行栈中，开始执行。
</pre>

#### 3、promise

<pre>
    1、Promise的含义
        Promise是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现
        ，ES6将其写进了语言标准，统一了用法，原生提供了Promise对象。 

    2、Promise解决了哪些问题
        1. 回调地狱
        2. 多个异步操作的串行执行
        3. 并行执行异步操作，且可以获得所有异步操作的结果
    3、Promise有几种状态
        1. pending: 初始状态，既不是成功，也不是失败状态。
        2. fulfilled: 意味着操作成功完成。
        3. rejected: 意味着操作失败。
    4、Promise的构造函数是做什么的？
        1. 创建一个Promise实例，需要传入一个函数作为参数，该函数的两个参数分别是resolve和reject。
        2. 该函数会立即执行。
</pre>

#### 4、generator

<pre>
    1、Generator的含义
        Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。
        Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。
        执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成器。
        形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；
        二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。
    2、Generator的用法
        1. 基本用法
            function* helloWorldGenerator() {
                yield 'hello';
                yield 'world';
                return 'ending';
            }

            var hw = helloWorldGenerator();
            console.log(hw.next()); // { value: 'hello', done: false }
            console.log(hw.next()); // { value: 'world', done: false }
            console.log(hw.next()); // { value: 'ending', done: true }
            console.log(hw.next()); // { value: undefined, done: true }
        2. yield表达式
            function* fibonacci() {
                let [prev, curr] = [0, 1];
                for (;;) {
                    yield curr;
                    [prev, curr] = [curr, prev + curr];
                }
            }

            for (let n of fibonacci()) {
                if (n > 1000) break;
                console.log(n);
            }
        3. 与Iterator接口的关系
            Generator 函数就是遍历器生成函数。
            Generator 函数除了状态机，还是一个遍历器对象生成函数。
            Generator 函数可以不用任何修饰符调用，这是因为它就是遍历器对象生成函数。
            Generator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也继承了Generator函数的prototype对象上的方法。
        4. 作为对象属性的Generator函数
            var myIterable = {};
            myIterable[Symbol.iterator] = function* () {
                yield 1;
                yield 2;
                yield 3;
            };

            [...myIterable] // [1, 2, 3]
            let obj = {};
            obj[Symbol.iterator] = function* () {
                yield 1;
                yield 2;
                yield 3;
            };

            obj[Symbol.iterator] // 1
            obj // {1: 2, 2: 3, 3: 4}
        5. Generator函数的this
            Generator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也继承了Generator函数的prototype对象上的方法。
            Generator 函数也不能跟new命令，否则会抛出一个错误。
</pre>



### 7、websocket
###
#### 1、websocket是什么

<pre>
    WebSocket是一种在单个TCP连接上进行全双工通讯的协议。
    WebSocket使得客户端和服务器可以进行双向通信。
    在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。
</pre>

#### 2、websocket与http的区别

<pre>
    WebSocket是一个持久化的协议，相对于HTTP这种非持久的协议来说。
    WebSocket是双向通信协议，在建立连接之后，WebSocket的server与client都能主动向对方发送或接收数据。
    HTTP是单向的通信协议，也就是请求-响应模式，请求完成之后，连接就关闭了，要进行下一次通信，必须重新建立连接。
</pre>

#### 3、websocket与http2.0的区别

<pre>
    WebSocket和HTTP2.0有着本质的不同，HTTP2.0是一个应用层协议，WebSocket是一个独立的协议。
    WebSocket是一种双向通信协议，在建立连接之后，WebSocket的server与client都能主动向对方发送或接收数据。
    HTTP2.0是一个应用层协议，HTTP2.0的request和response都遵循HTTP协议的格式。
    HTTP2.0是双向通信协议，通信过程中可以同时发送多个请求或响应，而且这些请求或响应都是独立成行的，不必等待其中一个请求或响应完成后再发送下一个请求或响应。
    HTTP2.0采用二进制格式传输数据，比HTTP1.x的文本格式数据更高效；
    HTTP2.0支持服务器推送，即服务端可以主动向客户端推送数据。
    HTTP2.0实现了一些机制让客户端与服务器之间可以进行有效的交互。
</pre>

#### 4、websocket心跳机制

<pre>
        
</pre>

```javascript
    // 客户端的连接 ws服务器
    var ws = new WebSocket('wss://echo.websocket.org');
    // open 事件
    ws.onopen = function(evt) {
        console.log("Connection open ...");
        ws.send("Hello WebSocket!");
    };
    // message 事件
    ws.onmessage = function(evt) {
        console.log( "Received Message: " + evt.data);
        ws.close();
    };
    // close 事件
    ws.onclose = function(evt) {
        console.log("Connection closed.");
    };
    // 心跳机制
    setInterval(function(){
        ws.send("ping");
    }, 5000);
    // 断线重连 重连时间要大于心跳时间
    ws.onclose = function(){
        console.log("连接断开，重连中...");
        // 重连
        ws = new WebSocket('wss://echo.websocket.org');
    };
    ws.onopen = function(){
        console.log("重连成功");
    };
```
```javascript
// 封装成类使用
class Socket {
    wsUrl;
   constructor(wsUrl:any) {
        this.wsUrl = wsUrl;
    }
    modeCode={
       // webSocket 消息类型
        MSG:"message",
        // 心跳类型
        HEART_BEAT:"heart_beat",
    }
    ws:any=null;
    webSocketState:boolean=false;
    heartBeat ={
        // 心跳连接的时间设置
        time:5 * 1000, // 心跳时间间隔
        timeOut:3 * 1000, // 心跳超时间隔
        reconnect:10 * 1000, // 重连时间间隔
    }
    reconnectTimer:any=null; // 断开重连时间器
    /**
     * 连接 ws
     * */
    connectWebSocket(){
        this.ws = new WebSocket(this.wsUrl);
       this.init();
    }

    /**
     * 心跳初始函数
     */
    
    startHeartBeat(time:number | string){
        setTimeout(()=>{
            this.ws.send(JSON.stringify({
                ModeCode:this.modeCode.HEART_BEAT,
                msg:new Date(),
            }))
            this.waitingServer()
        },time)
    }
    
    /**
     * 延迟等待服务端响应，通过webSocketState判断是否连接成功
     * */
    waitingServer(){
        this.webSocketState = false;
        setTimeout(()=>{
            if (this.webSocketState){
                this.startHeartBeat(this.heartBeat.time)
                return;
            }
            console.log("心跳无响应，已断开...");
            try{
                this.ws.close();
            }catch(e){
                console.log("关闭连接失败...");
            }
            this.reconnectWebSocket();
        },
        this.heartBeat.timeOut)
    }

    /**
     * 重连操作
     */
    reconnectWebSocket(){
        this.reconnectTimer = setTimeout(()=>{
            console.log("尝试重新连接...");
            this.reconnectWs();
        },this.heartBeat.reconnect)
    }
    
    /**
     * 初始化
     * */
   init(){
       this.ws.addEventListener('open',()=>{
           // socket状态设置为连接， 作为后面的断线重连的拦截器
           this.webSocketState = true;
           // 是否启动心跳级制
           this.heartBeat && this.heartBeat.time ?
           this.startHeartBeat(this.heartBeat.time) : null;
           console.log("连接成功...");
       })
       this.ws.addEventListener('message',(e)=>{
           console.log("收到消息：",e.data);
           const data = JSON.parse(e.data);
           switch (data.ModeCode){
               case this.ModeCode.heartBeat:
                   console.log("收到心跳..."+data.msg);
                   break;
               case this.ModeCode.MSG:
                   console.log("收到消息..."+data.msg);
                   break;
           }
       })
       this.ws.addEventListener('close',(e)=>{
           this.webSocketState = false;
           console.log("连接已关闭...",e);
       })
       this.ws.addEventListener('error',()=>{
           this.webSocketState = false;
           console.log("连接出错...",e);
           this.reconnectWebSocket(); //重连
       })
    }
    reconnectWs(){
       if(!this.ws){
           // 第一次执行，初始化
           this.connectWebSocket();
       }
       if(this.ws && this.reconnectTimer){
           // 防止多个webSocket同时执行
           clearTimeout(this.reconnectTimer);
           this.ws.reconnectTimer = null;
           this.connectWebSocket()
       }
    }

    /**
     *  发送消息
     */
    sendMessage(data:any){
        this.ws.send(JSON.stringify(data));
    }

    /**
     * 在其他需要socket的地方主动关闭socket
     */
    closeWebSocket(e:any){
        console.log("主动关闭socket...",e);
        this.ws.close();
        clearTimeout(this.reconnectTimer);
        this.webSocketState = false;
    }
}

export default Socket;
```
```javascript
/**
 * 使用
 * @type {Socket}
 */
import Socket from './socket';

const socket = new Socket("url");
socket.init();
socket.sendMessage("Hello WebSocket!");
```

### 8、浏览器
###
#### 1、localStrage、sessionStrage、cookie的区别

<pre>
    localStrage、sessionStrage、cookie都是浏览器端存储数据的方式，区别如下：
    1、存储位置不同：
        localStrage、sessionStrage存储在浏览器端，而cookie存储在服务端。
    2、存储大小不同：
        localStrage、sessionStrage、cookie存储大小不同，cookie一般不能超过4k，而localStrage、sessionStrage可以存储超过4k的数据。
    3、有效时间不同：
        localStrage、sessionStrage在设置的有效时间内一直有效，而cookie在设置的有效期内一直有效，即使窗口或浏览器关闭。
    4、与服务器端通信不同：
        localStrage、sessionStrage在设置的有效期内一直有效，而cookie在设置的有效期内一直有效，即使窗口或浏览器关闭。
</pre>

#### 2、浏览器缓存

<pre>

    浏览器缓存分为强缓存和协商缓存。

    1、强缓存：
        浏览器直接从缓存中读取资源，不会向服务器发送请求。
        强缓存可以通过设置两种HTTP Header实现：Expires和Cache-Control。
        Expires是HTTP/1.0的产物，表示缓存到期时间，但是它受限于本地时间，如果修改了本地时间，可能会造成缓存失效。
        Cache-Control是HTTP/1.1的产物，在Expires出现后，Cache-Control成为主要控制缓存失效的header。
        Cache-Control的几个常用字段：
            public：所有内容都将被缓存（客户端和代理服务器都可缓存）
            private：所有内容只有客户端可以缓存，Cache-Control的默认取值
            no-cache：客户端缓存内容，但是是否使用缓存需要经过协商缓存来验证决定
            no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存
            max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效

    2、协商缓存：
        如果缓存过期了，那么浏览器会发送请求到服务器，服务器根据请求中的相关标识来判断是否命中缓存。
        如果命中缓存，则返回304和Not Modified状态码，浏览器根据此状态码来从缓存中读取资源。
        如果未命中缓存，则返回200和请求的结果资源，并且会更新缓存中的资源。
        协商缓存可以通过设置两种HTTP Header实现：Last-Modified和ETag。
        Last-Modified：标识请求资源在服务器上的最新修改时间。
        ETag：标识请求资源的唯一标识符。

</pre>

#### 3、浏览器输入URL到页面展示的详细过程

<pre>

    1、DNS解析：
        浏览器缓存-&gt;系统缓存-&gt;路由器缓存-&gt;ISP DNS缓存-&gt;递归搜索

    2、TCP连接：
        三次握手：
            客户端发送SYN包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；
            服务器收到SYN包，必须确认客户的SYN(ack=j+1)，同时自己也发送一个SYN包(syn=k)，即SYN+ACK包，此时服务器进入SYN_RECV状态；
            客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

    3、发送HTTP请求：
        客户端向服务器发送一个HTTP请求，请求被发送到服务器的默认端口(80)

    4、服务器处理请求：
        服务器端请求处理完毕后，向客户端发送HTTP响应，客户端接收HTTP响应并渲染页面

    5、关闭TCP连接：
        客户端获取到HTML文档后，会关闭TCP连接，或者等待一段时间后发起TCP连接

</pre>

#### 4、HTTP1.0和HTTP1.1的区别

<pre>

    1、长连接：
        HTTP1.0默认是短连接，也就是说每次请求都要重新建立一次连接，用完就断开。
        HTTP1.1默认是长连接，也就是说，默认会保持连接。

    2、缓存处理：
        HTTP1.0没有指定缓存的处理方式，依赖浏览器或者用户自己进行处理。
        HTTP1.1新增了缓存处理，如缓存请求头字段Cache-Control、Last-Modified、Etag等。

    3、带宽优化及网络连接的使用：
        HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，
        并且不支持断点续传功能，HTTP1.1则在请求头引入了Range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），
        这样就方便了开发者自由的选择以便充分利用带宽和连接。

    4、错误通知的管理：
        在HTTP1.1中，新增了24个错误状态响应码，
        如409（Conflict）表示请求的资源与资源的当前状态发生冲突；
        410（Gone）表示服务器上的某个资源被永久性的删除。

    5、Host头处理：
        在HTTP1.0中，每个请求的header中都有Host信息，例如：Host:www.google.com。
        而在HTTP1.1中，Host信息是必须的，如果客户端没有给出这个信息，服务器将不会处理该请求。

</pre>

#### 5、HTTP2.0的新特性

<pre>

    1、二进制分帧：
        HTTP2.0将报文分成帧（frame）进行传输，和HTTP1.x一样，HTTP2.0也需要客户端和服务器同时支持，才能实现二进制分帧，
        实现二进制分帧的关键是帧头，它由帧类型（type）、帧长度（length）、帧标志（flags）三个字段组成，其中帧长度指的是整个帧的长度，
        而不包括帧头本身的长度。

    2、多路复用：
        多路复用是指在单个连接上可以同时传送多个请求或响应，即可以同时发送多个请求或响应，它的最大优点就是减少了建立和关闭连接的消耗和延迟，
        节省了带宽资源。

    3、头部压缩：
        HTTP2.0实现了头部的压缩功能，即HTTP2.0在客户端和服务器端使用“HPACK”算法来压缩头部，使数据体积变小，提高传输速度。

    4、服务器推送：
        HTTP2.0服务器能够更快的将资源发送给客户端，这被称为服务器推送。

</pre>

#### 6、HTTP请求报文和响应报文的具体格式

<pre>

    请求报文格式：
        请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。

    响应报文格式：
        状态行、响应头部、空行和响应数据四个部分组成。

</pre>

#### 7、HTTP常见状态码

<pre>

    200 OK：客户端请求成功。
    201 Created：已创建，成功请求并创建了新的资源。
    202 Accepted：已接受，已经接受请求，但未处理完成。
    203 Non-Authoritative Information（非授权信息）：请求成功。但返回的meta信息不在原始的服务器，而是一个副本。
    204 No Content：请求成功，但返回的meta信息为空（用null表示）。
    205 Reset Content（重置内容）：服务器处理成功，用户终端（例如：浏览器）应重置文档视图。
    206 Partial Content（部分内容）：服务器成功处理了部分GET请求。

    300 Multiple Choices（多种选择）：请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择。
    301 Moved Permanently（永久移动）：请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。
        今后任何新的请求都应使用新的URI代替。
    302 Found（找到）：临时性重定向。
    303 See Other（查看其他）：临时性重定向，且总是使用GET方法请求新的URI。
    304 Not Modified（未修改）：自从上次请求后，请求的资源未修改过，服务器返回此状态码时，不会包含任何响应的主体部分。
    305 Use Proxy（使用代理）：请求的资源必须通过代理访问。
    306 (Unused)：已经被废弃的代码，将来有可能使用，现在尚未使用。
    307 Temporary Redirect（临时重定向）：临时重定向，与302 Found类似。使用GET方法请求新的URI，但是POST方法提交的请求报文中的地址不会改变。

    400 Bad Request（错误请求）：请求报文存在语法错误。
    401 Unauthorized（未授权）：请求需要有通过HTTP认证的认证信息。
    402 Payment Required（支付要求）：该状态码是为了将来可能的需求而预留的。
    403 Forbidden（禁止）：服务器收到请求，但是拒绝提供服务。
    404 Not Found（未找到）：请求的资源不存在，或不可用。
    405 Method Not Allowed（方法禁用）：客户端请求中的方法被禁止。
    406 Not Acceptable（不可接受）：服务器无法根据客户端请求的内容特性完成请求。
    407 Proxy Authentication Required（代理服务器认证要求）：请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权。
    408 Request Timeout（请求超时）：服务器完成请求处理，但请求超时。
    409 Conflict（冲突）：通常和PUT请求有关。由于请求和资源的当前状态相冲突，因此请求不能成功。
    410 Gone（已删除）：被请求的资源已从这个地址转移，不再可用。
    411 Length Required（需要有效长度）：服务器无法处理客户端发送的不带Content-Length的请求信息。
    412 Precondition Failed（先决条件失败）：请求信息的先决条件错误。
    413 Request Entity Too Large（请求实体过大）：由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，
        服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息。
    414 Request-URI Too Long（请求URI过长）：请求的URI过长（URI通常为网址），服务器无法处理。
    415 Unsupported Media Type（不支持的媒体类型）：服务器无法处理请求附带的媒体格式。
    416 Requested Range Not Satisfiable（请求范围无法满足）：客户端请求的范围无效。
    417 Expectation Failed（期望失败）：服务器无法满足Expect的请求头信息。

    500 Internal Server Error（服务器内部错误）：服务器遇到错误，无法完成请求。
    501 Not Implemented（尚未实施）：服务器不支持请求的功能，无法完成请求。
    502 Bad Gateway（错误网关）：作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应。
    503 Service Unavailable（服务不可用）：由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度由服务器自己决定。
    504 Gateway Timeout（网关超时）：充当网关或代理的服务器，未及时从远端服务器获取请求。
    505 HTTP Version Not Supported（不支持的HTTP版本）：服务器不支持请求的HTTP协议的版本，无法完成处理。
</pre>