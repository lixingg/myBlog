### 1、HTML

#### 1、语义化标签

- 1.语义化标签有哪些？

 <pre>
     1.header 头部标签
     2.nav 导航标签
     3.section 定义文档某个区域
     4.article 定义独立的内容
     5.aside 定义页面的侧边栏
     6.footer 尾部标签
</pre>

- 2.语义化标签的作用

 <pre>
     1.让页面的内容结构化，便于对浏览器、搜索引擎解析
     2.即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的
     3.搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO
     4.使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解
</pre>

- 3.语义化标签的缺点：

 <pre>
     语义化标签在IE6-8浏览器下无效;(解决的办法: 可以通过html5shiv让IE6-8支持H5标签)
</pre>

#### 2、Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?

 <pre>
 1.<!DOCTYPE>声明位于位于HTML文档中的第一行，处于 html 标签之前。告知浏览器的解析器，用什么文档标准解析这个文档。
 2.严格模式的排版和JS运作模式是以该浏览器支持的最高标准运行。在混杂模式中，页面以宽松的向后兼容模式显示。模拟老式浏览器的行为以防止站点无法工作。
 3.DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。
</pre>

#### 3. ::before 和 :after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用。

 <pre>
 1.单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。
 2.before元素之前。
 3.after元素之后。
 4.作用：清除浮动、样式布局上也有用。
</pre>

```scss
div:before { // 伪类 添加样式
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 20px;
  height: 20px;
  background-color: red;
  border: 1px solid #000;
  border-radius: 50%;
}

div::after { // 伪元素 清除浮动
  content: '';
  display: block;
  clear: both;
}
```

### 2、css

#### 1、说一下css盒模型

 <pre>
 在html页面中的所有元素都可以看成是一个盒模型,盒模型分为两种：IE盒模型和标准W3C盒模型。
 标准W3C盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)。
 IE盒模型： 边界(margin)、内容(content 包含 边框(border)、填充(padding))。
</pre>  

#### 2、css选择器有哪些

 <pre>
 1.id选择器（ # myid）
 2.类选择器（.myclassname）
 3.标签选择器（div, h1, p）
 4.相邻选择器（h1 + p）
 5.子选择器（ul > li）
 6.后代选择器（li a）
 7.通配符选择器（ * ）
 8.属性选择器（a[rel = "external"]）
 9.伪类选择器（a: hover, li: nth-child）
</pre>  

#### 3、CSS优先级算法如何计算

<pre>
优先级就近原则，同权重情况下样式定义最近的生效
载入样式以最后载入的定位为准
优先级为:
!important > 行内样式 >  id > 类or属性选择器or伪类选择器 > 标签 > 通配
重要要加引号，并且要写在最前面，同时css属性不能简写。
</pre>

#### 4、CSS3新增伪类有那些

<pre>
1.p:first-of-type 选择属于其父元素的首个 p 元素。
2.p:last-of-type  选择属于其父元素的最后 p 元素。
3.p:only-of-type  选择属于其父元素唯一的 p 元素。
4.p:only-child        选择属于其父元素的唯一子元素的 p 元素。
5.p:nth-child(2)  选择属于其父元素的第二个子元素的 p 元素。
6.:enabled  :disabled 控制表单控件的禁用状态。
7.:checked        单选框或复选框被选中。
</pre>

#### 5、如何居中div

<pre>
- [x] 1.position + margin
- [x] 2.position + transform
- [x] 3.flexbox
- [x] 4.grid
</pre>

```scss
.parent-block {
  position: relative;
}

// position + margin
.center-block {
  position: absolute;
  left: 0;
  top: 0;
  right: 0;
  bottom: 0;
  margin: auto;
}

// position + transform

.center-block {
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
}

// flexbox
.parent-block {
  display: flex;
  justify-content: center;
  align-items: center;
}

// grid

.parent-block {
  display: grid;
}

.center-block {
  margin: auto;
}
```

#### 6、隐藏元素的方法

```css
.box {
    /* 设置 元素消失 不占据空间*/
    display: none;
    /* 设置透明度为0，元素不可见，占据空间*/
    opacity: 0;
    /* 让元素消失，占据空间位置*/
    visibility: hidden;
    /* 相对其他盒子*/
    position: absolute;
    /* 剪切掉这块*/
    clip-path: circle(30px);
}
```

#### 7、px与rem的区别

<pre>
    px 时像素单位，显示器上最小物理点，每个像素的大小是一样的，是一个绝对单位长度。
    rem是相对单位，
    相对于根元素html的font-size，
    根元素html的font-size默认是62.5%，
    1rem = 10px = (16px * 62.5%)，
    计算公式：
    rem = px / 根元素html的font-size
</pre>

#### 8、使用link和@import引入的区别

<pre>
    1. link是HTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。
    2. link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。
    3. link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。
    4. link支持使用Javascript控制DOM去改变样式；@import不支持。
</pre>

#### 9、title与h1的区别,b与strong的区别,i与em的区别?

<pre>
    title与h1的区别  
        1.定义
            title: 概括了网站信息，可以告诉搜索引擎或者用户关于这个网站的内容主题。
            h1: 文章主题内容，告诉蜘蛛我们的网站内容是什么。
        区别：
            1.从显示上说，title 显示在网页标题上，h1 显示在网页内容上。
            2.从seo上说，title 比 h1 添加重要（title > h1）。
        场景上：
            网站的logo都是用 h1 标签包裹的
</pre>
<pre>
    b与strong的区别
        1.定义
            b: 实体标签，表示粗体文本，没有实际意义，只是视觉上的加粗。
            strong: 逻辑标签，用来加强字符的语气，表示重要文本，有实际意义，搜索引擎会重点抓取。
        区别：
            1.b 没有语义，只是视觉上的加粗，没有实际意义，搜索引擎不会重点抓取。
            2.strong 是有语义的，表示重要文本，有实际意义，搜索引擎会重点抓取。
        场景上：
            1.b 标签一般用于表示一些小字，如：导航栏、侧边栏等。
            2.strong 标签一般用于表示一些重要文本，如：文章标题、文章内容等。
</pre>
<pre>
    i与em的区别
       1.定义
           i: 实体标签，表示斜体文本，没有实际意义，只是视觉上的倾斜。
           em: 逻辑标签，用来强调字符，表示重要文本，有实际意义，搜索引擎会重点抓取。
       区别：
          1.i 没有语义，只是视觉上的倾斜，没有实际意义，搜索引擎不会重点抓取。
          2.em 是有语义的，表示重要文本，有实际意义，搜索引擎会重点抓取。
       场景上：
          i 更多的用在字体图标，em 术语上 （医药、生物）。
</pre>  

#### 10、img 标签的 title 和 alt 有什么区别？

<pre>
    1、显示不同：
        1.title: 鼠标悬停在img上显示的文字。
        2.alt: 图片加载失败时显示的文字。
    2、SEO搜索引擎优化：
        1.title: 给图片起个名字，方便搜索引擎抓取图片信息。
        2.alt: 图片加载失败时显示的文字，方便搜索引擎抓取图片信息。
</pre> 

#### 11、png、jpg、gif 有什么区别，如何选择使用哪种图片格式？

<pre>
    1.png: 无损压缩，尺寸体积要比jpg/jpeg的大，适合做小图标，支持透明度，支持256色，支持动画。
    2.jpg: 采用压缩算法，有一点失真，比png要小，适合做中大图片，不支持透明度，支持256色，不支持动画。
    3.gif: 一般是做动图的。支持透明度，支持256色，支持动画。
    4.webp: 同时支持有损或者无损压缩，相同质量的图片，webp具有更小的体积，兼容性不是特别好。
</pre>

#### 12、line-height 和 height 有什么区别？

<pre>
    1.line-height: 行高，是行距，是基线到基线之间的距离。（每一行文字的高，如果换行则整个盒子高度会增大（行数 * 行高））
    2.height: 元素的高度，是元素边框到元素边框之间的距离。（死值，就是盒子的高度）
</pre>

#### 13、哪些属性可以继承？

<pre>
    1.文字系列属性：font-size font-family color font-weight font-style text-decoration text-align 
                  text-indent vertical-align line-height letter-spacing word-spacing text-shadow text-transform direction
    2.元素可见性：visibility
    3.表格布局属性：caption-side border-collapse empty-cells
    4.列表布局属性：list-style-type list-style-image list-style-position list-style
    5.光标属性：cursor
    6.页面样式属性：page page-break-before page-break-after page-break-inside
    7.声音样式属性：speak speak-punctuation speak-numeral speak-header speak-delay speak-rate speak-volume
</pre>

#### 14、用css 绘制三角形

<pre>
    1.border-width: 10px;
    2.border-style: solid;
    3.border-color: transparent transparent red transparent;
</pre>

#### 15、display 有哪些值，表示什么

<pre>
    1.block         把某个元素转换成块元素。
    2.none          此元素会被隐藏。
    3.inline        把某个元素转换成内联元素。
    4.inline-block  把某个元素转换成行内块元素。
    5.list-item     象块类型元素一样显示，并添加样式列表标记。
    6.table         此元素会作为块级表格来显示（类似 table），表格前后带有换行符。
    7.inherit       规定应该从父元素继承 display 属性的值。
</pre>

#### 16、对BFC规范（块级格式化上下文：block formatting context）的理解？

<pre>
    BFC就是页面上一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。

    1. 了解BFC: 块级格式化上下文。
    2. BFC原则: 如果一个元素具有BFC，那么内部元素再怎么弄，都不会影响到外部元素。
    3. 哪些元素会具有BFC: 根元素、float属性不为none、position为absolute或fixed、display为inline-block、overflow不为visible。
</pre>

#### 17、清除浮动有哪些方法

<pre>
    1. 触发BFC : 给父元素添加overflow:hidden;
    2. 结尾处加空div标签 clear:both;
    3. 使用伪类 父元素:after{ clear:both; display:block; content:""; }
</pre>

#### 18、在网页中字体使用奇数还是偶数？为什么？

<pre>
    偶数
    1、方便开发，布局、计算像素方便。
    2、偶数像素的图片，在放大后不会出现模糊。
    3、让文字在浏览器上表现的更好看。
</pre>

#### 19、有几种定位？ 分别是根据什么定位的

<pre>
    1. static 默认值，没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。
    2. relative 生成相对定位的元素，相对于其正常位置进行定位。
                如果有top, bottom, left, right ==》left top
    3. absolute 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。
                如果有top, bottom, left, right ==》top, bottom, left, right 
    4. fixed 生成固定定位的元素，相对于浏览器窗口进行定位。
    5. sticky 生成粘性定位的元素，元素先按照普通文档流定位，然后相对于该元素在流中的flow根元素进行定位。
</pre>

#### 20、双飞翼布局

```html

<div class="container">
    <div class="main">main</div>
    <div class="left">left</div>
    <div class="right">right</div>
</div>
```

```css
.container {
    width: 100%;
}

.main {
    float: left;
    width: 100%;
    margin: 0 200px;
    background: #f00;
}

.left {
    float: left;
    width: 200px;
    margin-left: -100%;
    background: #0f0;
}

.right {
    float: left;
    width: 200px;
    margin-left: -200px;
    background: #00f;
}

.clearfix::after {
    content: "";
    display: block;
    clear: both;
}
```

#### 21、什么是css reset?

- reset.css 是一个CSS文件，它包含了一组重置样式（reset styles），用于将浏览器默认的样式重置为一致的样式。
  在编写CSS样式时，如果需要重置浏览器默认样式，可以引用[reset.css](https://meyerweb.com/eric/tools/css/reset/)文件。
  这样可以确保所有浏览器在渲染页面时都使用一致的样式，避免由于浏览器默认样式不同而导致的样式差异。

- 为了增强跨浏览器渲染的一致性，我们推荐使用 [Normalize.css](https://necolas.github.io/normalize.css/)，这是由 Nicolas
  Gallagher 和 Jonathan Neal 维护的一个CSS 重置样式库。

- [bootcss 官网](https://v3.bootcss.com/css/)

#### 22、CSS Sprites 是什么？ 有什么优缺点？（雪碧图|精灵图）

- CSS Sprites是一种CSS图像合并技术，用于将多个小图标合并成一张大图，从而减少HTTP请求
- 优点：
    1. 减少HTTP请求数，提高页面加载速度
    2. 减少图片大小，提高页面加载效率
    3. 提高页面渲染性能，减少页面加载时间
    4. 提高页面响应速度，提高用户体验
- 缺点：
    1. 维护成本高，需要手动维护合并后的图片
    2. 图片合并后体积较大，增加页面加载时间
    3. 图片合并后，图片无法单独使用，只能作为背景图使用
- 使用：

```css
.container {
    /* 使用雪碧图添加背景图片*/
    /*background: url('./images/sprite.png') no-repeat;*/
    /* 移动雪碧图位置确定哪个雪碧图*/
    /*background-position: -100px -100px;*/
}
```

#### 23、重绘和回流

```scss
.container {
  visibility: hidden; // 产生重绘
  display: none; // 产生回流 + 重绘
  // 产生回流一定会造成重绘，但重绘不一定会造成回流。
}
```

- 重绘（Repaint）：当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color
  等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。
- 回流（Reflow）：当页面中元素的尺寸、结构、位置、显隐或触发某些属性时，浏览器会重新计算元素的几何属性，
  并重新构造渲染树，这个过程称为回流。

#### 24、opacity和rgba区别

- opacity 取值范围 0 - 1 之间，0表示完全透明，1表示完全不透明。
- rgba r表示红色，g表示绿色，b表示蓝色，取值可以为正整数或者百分数，a表示透明度，取值范围 0 - 1 之间，0表示完全透明，1表示完全不透明。
- 区别：
- opacity 作用于元素，以及元素的所有后代元素（会被子元素继承），而 rgba 只作用于元素本身（不会被子元素继承）。
- opacity 不会触发浏览器的重排和重绘，而 rgba 会导致浏览器重绘。

#### 25、rem和em区别

- rem 相对于根元素（html 元素）的 font-size 进行计算，em 相对于其父元素的 font-size 进行计算
- rem 值不会被浏览器缓存，而 em 值会被浏览器缓存
- rem 值在移动端使用更加合适，而 em 值在 PC 端使用更加合适

### 3、Javascript

#### 1、为什么 javascript 是单线程？

<pre>
    JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么 JavaScript 不能有多个线程呢？
    这样可以同时执行多个任务，提高性能，减少延迟。
    
    JavaScript 单线程，与它的用途有关。作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM。
    这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，
    另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？

    所以，为了避免复杂性，从一诞生，JavaScript 就是单线程，这已经成了这门语言的核心特征，将来也不会改变.
</pre>

#### 2、javascript 是单线程，怎么执行异步代码？

<pre>
    JavaScript 语言的执行环境是“单线程”的，也就是说，一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，
    再执行后面一个任务，以此类推。
    1、同步任务
        同步任务都在主线程上执行，形成一个执行栈。
    2、异步任务（宏任务、微任务）
        除了同步任务以外，其他任务都属于异步任务，又可以分成两种：
        1. 普通事件，如click、resize等。
        2. 资源加载，如load、error等。
        3. 定时器，包括setInterval、setTimeout等。
        4.promise对象。
        5.async/await。
    3、宏任务
        script(整体代码), setTimeout, setInterval, setImmediate(Node.js 环境), requestAnimationFrame(浏览器环境)，
        I/O, UI rendering(浏览器环境)，网络请求
    4、微任务
        process.nextTick(Node.js 环境), Promise.then(null), Promise.catch(null), Promise.finally(null
        promise 回调 、DOM变动观察器
    5、事件循环
        1. 执行一个宏任务（栈中没有就从事件队列中获取）
        2. 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中
        3. 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
        4. 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染
        5. 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）
        6. 如此循环
    6、任务队列
        1. 同步任务都在主线程上执行，形成一个执行栈。
        2. 主线程之外，还存在一个"任务队列"。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。
        3. 一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异
        步任务，于是结束等待状态，进入执行栈，开始执行。
        4. 主线程不断重复上面的第三步。
    7、JS执行流程
        1. 主线程读取JS代码，此时是在同步环境，形成对应的堆和执行栈；
        2. 主线程遇到异步任务，会推给异步线程进行处理；
        3. 异步线程处理完毕后，将对应的异步任务推到任务队列中；
        4. 主线程查询任务队列，执行微任务，将其按照顺序执行，全部执行完毕。
        5. 主线程查询任务队列，执行宏任务，取得第一个宏任务，执行完毕。
        5. 主线程不断重复第四步。
        
    异步任务相关的事件回调函数都在任务队列中等待。
    一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会按次序读取任务队列，将可运行的
    异步任务添加到可执行栈中，开始执行。
</pre>

#### 3、promise

<pre>
    1、Promise的含义
        Promise是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现
        ，ES6将其写进了语言标准，统一了用法，原生提供了Promise对象。 

    2、Promise解决了哪些问题
        1. 回调地狱
        2. 多个异步操作的串行执行
        3. 并行执行异步操作，且可以获得所有异步操作的结果

    3、Promise有几种状态
        1. pending: 初始状态，既不是成功，也不是失败状态。
        2. fulfilled: 意味着操作成功完成。
        3. rejected: 意味着操作失败。

    4、Promise的构造函数是做什么的？
        1. 创建一个Promise实例，需要传入一个函数作为参数，该函数的两个参数分别是resolve和reject。
        2. 该函数会立即执行。
</pre>

#### 4、async/await

<pre>
    1、async/await的含义
        1. async/await是Generator函数的语法糖。
        2. async/await是基于Promise实现的，它不能用于普通的回调函数。
        3. async/await使得异步代码看起来像同步代码，这正是它的魔力所在。
</pre> 

#### 5、generator

<pre>
    1、Generator的含义
        Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。
        Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。
        执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成器。
        形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；
        二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。
    2、Generator的用法
        1. 基本用法
            function* helloWorldGenerator() {
                yield 'hello';
                yield 'world';
                return 'ending';
            }

            var hw = helloWorldGenerator();
            console.log(hw.next()); // { value: 'hello', done: false }
            console.log(hw.next()); // { value: 'world', done: false }
            console.log(hw.next()); // { value: 'ending', done: true }
            console.log(hw.next()); // { value: undefined, done: true }
        2. yield表达式
            function* fibonacci() {
                let [prev, curr] = [0, 1];
                for (;;) {
                    yield curr;
                    [prev, curr] = [curr, prev + curr];
                }
            }

            for (let n of fibonacci()) {
                if (n > 1000) break;
                console.log(n);
            }
        3. 与Iterator接口的关系
            Generator 函数就是遍历器生成函数。
            Generator 函数除了状态机，还是一个遍历器对象生成函数。
            Generator 函数可以不用任何修饰符调用，这是因为它就是遍历器对象生成函数。
            Generator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也继承了Generator函数的prototype对象上的方法。
        4. 作为对象属性的Generator函数
            var myIterable = {};
            myIterable[Symbol.iterator] = function* () {
                yield 1;
                yield 2;
                yield 3;
            };

            [...myIterable] // [1, 2, 3]
            let obj = {};
            obj[Symbol.iterator] = function* () {
                yield 1;
                yield 2;
                yield 3;
            };

            obj[Symbol.iterator] // 1
            obj // {1: 2, 2: 3, 3: 4}
        5. Generator函数的this
            Generator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也继承了Generator函数的prototype对象上的方法。
            Generator 函数也不能跟new命令，否则会抛出一个错误。
</pre>

#### 6、JS延迟加载有哪些方式

<pre>
    defer和async、动态创建DOM方式（通过documen.write）、按需异步载入js
    
    defer和async的区别
    defer要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；
    async一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。
</pre>

#### 7、JS数据类型

<pre>
    基本数据类型：String,Number,Boolean,Undefined,Null,Symbol,bigint
    引用数据类型：Object
    NaN 是一个数值类型，但不是一个具体的数字；
</pre>

#### 8、数据类型的隐式转换

```javascript
console.log(true + 1); // 2 number
console.log('name' + true); // 'nametrue' string
console.log(undefined + 1); // NaN number
console.log(typeof NaN); // number
console.log(typeof undefined); // undefined
```

#### 9、null 和 undefined 的区别

<pre>
    1. 最初设计js的时候借鉴了java语言，java中含有null,就设计了null。
    2. null会被隐式转换为0，很不容易发现错误。
    3. 现有null后有undefined,设计undefined是为了填补之前的坑。
    具体区别：
    javascript的最初版本是这样区分的，null表示一个"无"的对象（空对象指针），转为数值时为0，
    undefined表示一个"无"的值（空值指针），转为数值时为NaN。
</pre>

```javascript
console.log(Number(null)) // 0
console.log(Number(undefined)) // NaN
```

#### 10、== 和 === 有什么不同

- == : 只进行值的比较，不进行数据类型的比较
- string == number || boolean || ...都会隐式转换，
- 通过valueOf转换（valueOf() 方法通常由JavaScript自动调用，并不显式地出现在代码中）
- 隐式转换：虽然两个值比较是相等 但是数据类型还是不相同，不做显示只做比较。
- === : 除了比较值，还比较数据类型（建议使用三等）

```javascript
console.log(1 == '1') // true
console.log(1 === '1') // false

console.log(null == undefined) // true
console.log(null === undefined) // false

console.log(true == 1) // true
console.log(true === 1) // false

console.log([1, 2] == '1,2'); // true
console.log([1, 2] === '1,2'); // false
```

#### 11、JS 作用域

- 1.除了函数外，js 是没有块级作用域的。

```javascript
function fn() {
    var a = 10;
}

console.log(a); // 报错

for (var i = 0; i < 10; i++) {
}
console.log(i); // 10

if (true) {
    var b = 11;
}
console.log(b); // 11
```

- 2.作用域链：内部可以访问外部变量，外部不能访问内部变量。
  注意：如果内部有，优先查找内部，如果内部没有就查找外部的。

```javascript
function fn1() {
    var a = 10;

    function fn2() {
        console.log(a);
    }

    fn2();
}

fn1(); // 10
```

- 3.注意声明变量是用var还是没有写（没有写默认全局，注册在window上），

```javascript
function fn() {
    var a = b = 10
    console.log(a); // 10
    console.log(b); // 10
}

console.log(a); // a is not defined
console.log(b); // 10
```

- 4.js有变量提升的机制（变量悬挂声明）
- 5.变量提升只提升声明，不提升赋值

```javascript
var a = '2222'

function fn() {
    console.log(a); // undefined
    var a = '1111'
    console.log(a); // 1111
}

fn(); // undefined
// 如果没有声明a 那么会报错 a is not defined
```

- 6.优先级：声明变量> 声明普通函数> 参数> 变量提升

```javascript
// 声明变量> 声明普通函数
var a = '2222'

function a() {
}

console.log(a); // 2222

// 普通声明函数是不看写函数的时候顺序

b() // 声明前面调用
function b() {
    console.log('b');
}

b() // 声明后面调用

// 声明普通函数> 参数

function a(a) {
    console.log(a); // f a(){}
    function a() {
    }
}

a(1111);

// 参数> 变量提升

function fun(a) {
    console.log(a); // 1111
    var a = '33333'
}

fun(1111); // 1111

// 声明普通函数> 变量提升
console.log(a); // f a(){}
var a = '33333'

function a() {
}

// 变量提升并赋值再次赋值
function fn() {
    a = 10;
    console.log(a); // 10
    var a = 20;
    console.log(a); // 20
}

fun()
```

#### 12、JS对象

```javascript
// 1.对象通过new操作符构建出来的，所以对象之间不相等（除了引用外）。
console.log([1, 2, 3] === [1, 2, 3]); // false

// 2.对象注意：引用类型（共同地址）
var a = {name: 'zs'}
var b = a;
b.name = 'ls';
console.log(a.name); // ls

// 3.对象key都是字符串， 对象属性为对象时会转换为字符串 [object Object]
var a = {}
var c = {key: 'c'}
var d = {key: 'd'}
a[c] = 'c';
a[d] = 'd';
for (var i in a) {
    console.log(i) // [object Object]
    console.log(typeof i); // string
}
console.log(a[c]); // d

// 4.对象如何查找属性或者方法
console.log([1, 2, 3].constructor) // f Array() == new Array()
// 每个函数都自带一个属性prototype，prototype的属性constructor指向构造函数
// 注意：对象拥有__proto__属性，指向构造函数的prototype
// new Fun 该Fun构造函数的原型指向对象（new Fun)的原型
// 实例的指针指向构造函数的原型
function Fun() {
};
var obj = new Fun();
console.log(obj.constructor) // f Fun()
obj.__proto__ == Fun.prototype;
console.log(obj.__proto__ == Fun.prototype); // true

function Fn() {
    this.a = '函数中添加的属性'
}

Fn.prototype.say = function () {
    console.log('我是原型中的方法')
}

var fn = new Fn();
fn.a = '我是对象本身属性'
fn.__proto__a = "我是对象原型中添加的属性"
Object.a = "我是Object对象中添加的属性"
console.log(fn.a)
// 对象本身属性 -> 构造函数中添加的属性 -> 对象原型中添加的属性 -> 构造函数原型中查找 -> 对象上一层的原型中查找
 ```

#### 13、this 指向

```javascript
function fn() {
    console.log(this)
}

fn() // window
```

```javascript
function Foo() {
    getName = function () {
        console.log(1)
    } // window上的的方法
    return this;
}

Foo.getName = function () {
    console.log(2)
}; // Foo的自有方法

Foo.prototype.getName = function () {
    console.log(3)
}; // Foo原型上的方法

var getName = function () {
    console.log(4)
}; // 全局变量

function getName() {
    console.log(5)
}; // 

Foo.getName();       // 2
getName();           // 4
Foo().getName();     // 1
getName();           // 1
new Foo().getName(); // 3

// 1. 函数执行，首先看函数名前面是否有"."，
// 1.1 有的话， "."前面是谁，this就指向谁
// 1.2 没有的话，this就指向window
var o = {
    a: 10,
    b: {
        fn: function () {
            console.log(this.a);
            console.log(this)
        }
    }
}
o.b.fn() // undefined b

// 2. 自执行函数中的this指向window
~function () {
    console.log(this)
}();
```

```javascript
window.name = 'ByteDance';

function A() {
    this.name = 'A';
}

A.prototype.getA = function () {
    console.log(this);
    return this.name + 1;
};

let a = new A();
let funcA = a.getA; // window.funcA =function (){console.log(this);return this.name + 1;}
funcA(); // window
```

```javascript
var length = 10;

function fn() {
    return this.length + 1;
}

var obj = {
    length: 5,
    test1: function () {
        return fn();
    }
};
obj.test2 = fn;
console.log(obj.test1()); // 11
console.log(fn() === obj.test2()) // 11 6 false
console.log(obj.test1() === obj.test2()) // 11 6 false
console.log(obj.test2()); // 6
```

#### 14、JS判断变量是不是数组，你能写出哪些方法？

- 1.isArray
- 2.instanceof
- 3.constructor
- 4.isPrototypeOf
- 5.Object.prototype.toString.call

```javascript
var arr = [1, 2, 3];
console.log(arr instanceof Array); // true
console.log(Array.isArray(arr)); // true
console.log(arr.constructor === Array); // true
console.log(Array.prototype.isPrototypeOf(arr)) // true
console.log(Object.prototype.toString.call(arr) === '[object Array]'); // true
````

#### 15、slice作用 ，splice是否改变原数组

- 1.slice() 方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。
- 2.splice() 方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。

```javascript
// slice 浅拷贝
var arr = [1, 2, 3, 4, 5, {a: 1, b: 2}, [1, 2, 3]];
var arrCopy = arr.slice(); // arrCopy 是arr的副本
arrCopy.push(6); // arrCopy 是 [1, 2, 3, 4, 5,{a:1,b:2},[1,2,3], 6]
console.log(arr); // 输出 [1, 2, 3, 4, 5,{a:1,b:2},[1,2,3]]
arrCopy[5].a = 3; // arrCopy 是 [1, 2, 3, 4, 5,{a:3,b:2}
console.log(arr); // 输出 [1, 2, 3, 4, 5,{a:3,b:2}
arrCopy[6][0] = 4; // arrCopy 是 [1, 2, 3, 4, 5,{a:3,b:2,c:4},[4,2,3],6]
console.log(arr); // 输出  [1, 2, 3, 4, 5,{a:3,b:2,c:4},[4,2,3],6]

// 1.slice 截取 3 ~ (arr.length-1)所有数据
let arr3 = arr.slice(3); //  输出 [4, 5,{a:1,b:2},[1,2,3], 6]

// 2.slice 从前到后截取 0 ~ 3 数据
let arr1 = arr.slice(0, 3);
console.log(arr1); // 输出 [1, 2, 3]

// 3.slice 从后往前截取 (arr.length-1) ~ (arr.length-1-3)数据
let arr2 = arr.slice(-3);
console.log(arr2); // 输出 [{a:3,b:2},[1,2,3],6]


```

```javascript
// splice 深拷贝 
var arr = [1, 2, 3, 4, 5, {a: 1, b: 2}, [1, 2, 3]];

var arrCopy = arr.splice(0, 4); // arrCopy 是arr的副本
arrCopy.push(6); // arrCopy 是 [1, 2, 3, 4, 5,6]
console.log(arr); // 输出 [{a:1,b:2},[1,2,3]]
arr[0].a = 3; // arrCopy 是 [1, 2, 3, 4, 5,6]
console.log(arr); // 输出  [{a:3,b:2},[1,2,3]]

// 1.splice 从前往后截取 3 ~ (arr.length-1)所有数据
let arr3 = arr.splice(3); //  输出 [4, 5,{a:3,b:2},[1,2,3],6]
console.log(arr); // 输出 [1, 2, 3]

// 2.splice 从前到后截取 0 ~ 3 数据
let arr4 = arr.splice(0, 3); // 
console.log(arr4); // 输出 [1, 2, 3]
console.log(arr); // 输出 [4, 5,{a:3,b:2},[1,2,3],6]

// 3.splice 从后往前截取 (arr.length-1) ~ (arr.length-1-3)数据
let arr5 = arr.splice(-3); //
console.log(arr5); // 输出 [{a:1,b:2},[1,2,3],6]
console.log(arr); // 输出 [1, 2, 3, 4, 5,]

// 4.splice 修改数据
arr.splice(1, 1, 100); // 从索引为1的位置开始删除1个元素，并插入100
console.log(arr); // 输出 [1, 100, 2, 3, 4, 5]

// 5.splice 添加数据
arr.splice(0, 0, 66); // 从索引为0的位置开始删除0个元素，并插入66 等同于 unshift
console.log(arr); // 输出 [66, 1, 100, 2, 3, 4, 5]

```

#### 16、JS 数组去重

- 1、利用ES6 Set去重

```javascript
let arr = [1, 2, 3, 4, 5, 1, 2, 3, 4, 5];

function unique(arr) {
    return [...new Set(arr)] || Array.from(new Set(arr))
}

const arr2 = unique(arr);
console.log(arr2); // [1, 2, 3, 4, 5]
```

- 2、利用for + indexOf 去重（ES5中最常用）

```javascript
let arr = [1, 2, 3, 4, 5, 1, 2, 3, 4, 5];

function unique(arr) {
    const arr1 = []
    for (let i = 0; i < arr.length; i++) {
        if (arr1.indexOf(arr[i]) === -1) {
            arr1.push(arr[i])
        }
    }
    return arr1;
}

const arr2 = unique(arr);
console.log(arr2); // [1, 2, 3, 4, 5]
```

- 3、利用for + includes 去重

```javascript
let arr = [1, 2, 3, 4, 5, 1, 2, 3, 4, 5];

function unique(arr) {
    const arr1 = []
    for (let i = 0; i < arr.length; i) {
        if (!arr1.includes(arr[i])) {
            arr1.push(arr[i])
        }
    }
    return arr1;
}

const arr2 = unique(arr);
console.log(arr2); // [1, 2, 3, 4, 5]
```

- 4、利用for + sort 去重

```javascript
let arr = [1, 2, 3, 4, 5, 1, 2, 3, 4, 5];

function unique(arr) {
    arr = arr.sort();
    const arr1 = [];
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] !== arr[i - 1]) {
            arr1.push(arr[i])
        }
    }
    return arr1;
}

const arr2 = unique(arr);
console.log(arr2); // [1, 2, 3, 4, 5]
```

- 5、利用filter 去重

```javascript

let arr = [1, 2, 3, 4, 5, 1, 2, 3, 4, 5];

function unique(arr) {
    return arr.filter((item, index) => {
        return arr.indexOf(item) === index;
    })
}

const arr2 = unique(arr);
console.log(arr2); // [1, 2, 3, 4,5]
```

#### 17、多维数组最大值

```javascript

function maxValue(arr) {
    let max = -Infinity;

    function getMax(arr) {
        for (let i = 0; i < arr.length; i++) {
            if (Array.isArray(arr[i])) {
                getMax(arr[i]);
            } else {
                max = Math.max(max, arr[i]);
            }
        }
    }

    getMax(arr);
    return max;
}

const arr = [1, 2, [3, 4, [5, 6, [7, 8]]]];
console.log(maxValue(arr)); // 8
```

#### 18、数组扁平化

```javascript

function flatten(arr) {
    return arr.reduce((pre, cur) => {
        return pre.concat(Array.isArray(cur) ? flatten(cur) : cur);
    }, []);
}

const arr = [1, 2, [3, 4, [5, {a: 1}, 6, [7, 8]]]];
console.log(flatten(arr)); // [1, 2, 3, 4, 5, 6, 7, 8]
```

#### 19、给字符串新增方法实现功能

```javascript
// 字符拼接前缀
let str = '你好'
String.prototype.addPrefix = function (str) {
    return str + this
}
console.log(str.addPrefix('hello')) // hello你好
```

#### 20、字符串出现最多次数的字符及次数

```javascript
let str = 'abcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdef'

function maxStr(str) {
    let obj = {};
    for (let i = 0; i < str.length; i++) {
        if (!obj[str[i]]) {
            obj[str[i]] = 1;
        } else {
            obj[str[i]]++;
        }
    }
    let max = 0;
    let maxStr = '';
    for (let key in obj) {
        if (obj[key] > max) {
            max = obj[key];
            maxStr = key;
        }
    }
    return maxStr + ':' + max;
}

console.log(maxStr(str)) // a:7
```

#### 21、new 操作符具体做了什么

```javascript
// 模拟new操作符 封装new方法
function myNew(fn, ...args) {
// 1.创建一个空对象
    const obj = {}
// 2.将这个空对象的原型指向构造函数的原型
//     obj.__proto__ = fn.prototype
    Object.setPrototypeOf(obj, fn.prototype)
// 3.将这个空对象赋值给函数中的this
    const result = fn.apply(obj, args)
// 4.判断构造函数的返回值类型
// 如果是引用类型([],{})，返回这个引用类型的对象
    if (typeof result === 'object' && result !== null) {
        return result
    } else {
// 如果是值类型(string,boolean,number...)，返回创建的对象
        return obj
    }
}

function Fun(age) {
    this.age = age;
    return {} || [] // 返回引用类型 {} || []
    return 123 || '124' || true  //等基本类型 返回值类型是值类型 {age:18}
}

console.log(myNew(Fun, 18))
```

#### 22、实现一个深拷贝

```javascript
function deepClone(obj) {
    // 如果是值类型，直接返回
    if (typeof obj !== 'object' || obj === null) {
        return obj
    }
    // 如果是引用类型，创建一个新的对象
    let result = Array.isArray(obj) ? [] : {}
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            result[key] = deepClone(obj[key])
        }
    }
    return result
}
```

#### 23、实现一个深比较

```javascript
function deepCompare(obj1, obj2) {
    // 判断是否是引用类型
    if (typeof obj1 !== 'object' || typeof obj2 !== 'object' || obj1 === null || obj2 === null) {
        return obj1 === obj2
    }
}
```

#### 24、闭包

- 1.闭包是什么

<pre>
    闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，
    通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。
</pre>

```javascript
function fn() {
    let num = 10
    return function () {
        num++
        console.log(num)
    }
}

let f = fn();
f() // 11
```

- 2.闭包可以解决什么问题

<pre>
    闭包可以缓存数据，如果一个函数在多次调用时，每次都需要重新计算，
    那么可以使用闭包将计算的结果缓存起来，避免每次调用时都重新计算。
</pre>

```javascript
const lis = document.querySelectorAll('li')
for (let i = 0; i < lis.length; i++) {
    // 使用立即执行函数将i作为变量传递给闭包进行缓存
    // 待同步函数执行完后，执行宏任务这样i就能拿到当前值而不是最后值
    // 从而实现点击时弹出对应索引的效果
    // 闭包的缺点是常驻内存，会增大内存使用量，使用不当很容易导致内存泄露 （IE浏览器）
    (function (i) {
        lis[i].onclick = function () {
            alert(i)
        }
    })(i)
}
```

- 3.闭包的缺点

<pre>
    闭包会常驻内存，会增大内存使用量，使用不当很容易导致内存泄露。
    
    解决方案：
    
    1.及时释放闭包占用的内存 (闭包函数设置为null)
    2.在退出函数之前，将不使用的局部变量全部删除 （设置为null)
</pre>

```javascript
function fn() {
    let num = 10
    return function () {
        num++
        console.log(num)
    }
}

let f = fn();
f() // 11
// 及时释放闭包占用的内存
f = null
```

#### 25、原型链

- 1.原型可以解决什么问题

<pre>
    原型可以实现函数和实例之间的继承，共享属性和方法。
</pre>

- 2.谁有原型

<pre>
    函数拥有：prototype
    对象拥有：__proto__
</pre>

```javascript
function Person() {
}

console.log(Person.prototype) // 输出：Person {}
const person = new Person();
console.log(person.__proto__) // 输出：Person {}
```

- 3.原型链的构成

<pre>
    原型链由原型对象组成，原型对象由构造函数组成，构造函数由实例组成。
</pre>

- 4.对象查找属性和方法的顺序

<pre>
    对象自身查找 -> 构造函数中查找 -> 对象原型中查找 -> 构造函数原型中查找 -> 当前原型的原型中查找 -> ... -> 直到最顶层为止（null）。
    这样一个查找顺序，形成类似于链条的形式，我们称之为原型链。
</pre>

#### 26、JS创建类几种方法

- 1.工厂模式

<pre>
    工厂模式是一种最简单的方法，通过函数来封装以特定接口创建对象的细节。
    缺点：对象无法识别，因为所有的实例都是Object的实例。
</pre>

```javascript
function createPerson(name, age, job) {
    let o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = function () {
        console.log(this.name);
    }
    return o;
}

const person1 = createPerson('Nicholas', 29, 'Software Engineer');
const person2 = createPerson('Greg', 27, 'Doctor');
```

- 2.构造函数模式

<pre>
    构造函数模式可以解决工厂模式中对象无法识别的问题。
    缺点：每个方法都要在每个实例上重新创建一遍。
</pre>

```javascript
function Person(name, age, job) {
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = function () {
        console.log(this.name);
    }
}

const person1 = new Person('Nicholas', 29, 'Software Engineer');
const person2 = new Person('Greg', 27, 'Doctor');
```

- 3.原型模式

<pre>
    原型模式是JavaScript中最简单的创建对象的方式。
    缺点：所有属性和方法都共享，无法向构造函数传递参数。
</pre>

```javascript
function Person() {
}

Person.prototype.name = 'Nicholas';
Person.prototype.age = 29;
Person.prototype.job = 'Software Engineer';
Person.prototype.sayName = function () {
    console.log(this.name);
}
const person1 = new Person();
person1.sayName(); // 输出：Nicholas
const person2 = new Person();
person2.sayName(); // 输出：Nicholas
```

- 4.组合使用构造函数模式和原型模式

<pre>
    组合使用构造函数模式和原型模式是创建自定义类型的最常见方式。
    构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。
</pre>

```javascript
function Person(name, age, job) {
    this.name = name;
    this.age = age;
    this.job = job;
}

Person.prototype.sayName = function () {
    console.log(this.name);
}
const person1 = new Person('Nicholas', 29, 'Software Engineer');
const person2 = new Person('Greg', 27, 'Doctor');
```

- 5.使用ES6 class

<pre>
    ES6 class是JavaScript正式引入的类语法，完全可以取代之前的原型模式。
</pre>

```javascript
class Person {
    constructor(name, age, job) {
        this.name = name;
        this.age = age;
        this.job = job;
    }

    sayName() {
        console.log(this.name);
    }
}

const person1 = new Person('Nicholas', 29, 'Software Engineer');
const person2 = new Person('Greg', 27, 'Doctor');
```

#### 27、JS 继承有哪些

- 1.ES6 class extends

<pre>
    ES6 class通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。
</pre>

```javascript
class Animal {
    constructor(name) {
        this.name = name;
    }

    sayName() {
        console.log('My name is ' + this.name);
    }
}

class Dog extends Animal { // extends关键字 继承父类
    constructor(name, breed) {
        super(name); // 调用父类的constructor(name)
        this.breed = breed;
    }

    sayBreed() {
        console.log('My breed is ' + this.breed);
    }
}

const dog = new Dog('Terra', 'Bull Terrier');
dog.sayName(); // 输出 'My name is Terra'
dog.sayBreed(); // 输出 'My breed is Bull Terrier'
```

- 2.原型链继承

<pre>
    原型链是实现继承的主要方法，其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。
    简单回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。
    那么，假如我们让原型对象等于另一个类型的实例，结果会怎么样呢？显然，此时的原型对象将包含一个指向另一个原型的内部指针，
    相应地，另一个原型中也包含着一个指向另一个构造函数的内部指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，
    就构成了实例与原型的链条。这就是所谓原型链的基本概念。
</pre>

```javascript
function Parent() {
    this.name = 'kevin';
}

Parent.prototype.getName = function () {
    console.log(this.name);
}

function Child() {
    this.age = 18;
}

// 继承Parent
Child.prototype = new Parent();
Child.prototype.constructor = Child;
var child1 = new Child();
console.log(child1.getName()); // kevin
```

- 3.构造函数式继承

<pre>
    在解决原型中包含引用类型值所带来问题的时候，一种常见的做法是：
    在构造函数中，所有变量都先初始化好，然后把this指向这个实例，最后再返回实例。
</pre>

```javascript
function Parent() {
    this.names = ['kevin', 'daisy'];
}

function Child() {
    Parent.call(this);
}

var child1 = new Child();
var child2 = new Child();
child1.names.push('yayu');
console.log(child1.names); // ["kevin", "daisy", "yayu"]
console.log(child2.names); // ["kevin", "daisy"]
```

- 4.组合继承

<pre>
    组合继承就是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。
    其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。
    这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。
</pre>

```javascript
function Parent(name) {
    this.name = name;
    this.colors = ['red', 'blue', 'green'];
}

Parent.prototype.getName = function () {
    console.log(this.name);
}

function Child(name, age) {
    // 继承属性
    Parent.call(this, name);
    this.age = age;
}

// 继承方法
Child.prototype = new Parent();
Child.prototype.constructor = Child;
var child1 = new Child('kevin', '18');
console.log(child1.name); // kevin
console.log(child1.age); // 18
child1.colors.push('black');
console.log(child1.colors); // ["red", "blue", "green", "black"]    

var child2 = new Child('daisy', '20');
console.log(child2.name); // daisy
console.log(child2.age); // 20
console.log(child2.colors); // ["red", "blue", "green"]
```

- 5.原型式继承

<pre>
    道格拉斯在《JavaScript模式》中提出的一种不涉及严格定义类型和构造函数的继承方式。
    他的想法是借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。
</pre>

```javascript
function createObj(o) {
    function F() {
    }

    F.prototype = o;
    return new F();
}
```

- 6.寄生式继承

<pre>
    寄生式（parasitic）继承是与原型式继承紧密相关的一种思路。
    寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，
    最后再像真的是它做了所有工作一样返回对象。
</pre>

```javascript
function createObj(o) {
    var clone = object(o); // 通过调用函数创建一个新对象
    clone.sayName = function () { // 以某种方式来增强这个对象
        console.log('hi');
    };
    return clone; // 返回这个对象
}
```

- 7.寄生组合式继承

<pre>
    通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。
    基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们需要的仅是超类型原型的一个副本。
    本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。
</pre>

```javascript
function objectCopy(obj) {
    function Fun() {
    };
    Fun.prototype = obj;
    return new Fun();
}

function inheritPrototype(child, parent) {
    let prototype = objectCopy(parent.prototype);
    prototype.constructor = child;
    Child.prototype = prototype;
}

function Parent(name) {
    this.name = name;
    this.hoby = ['唱', '跳']
}

Parent.prototype.showName = function () {
    console.log('my name is：', this.name);
}

function Child(name, age) {
    Parent.call(this, name);
    this.age = age;
}

inheritPrototype(Child, Parent);
Child.prototype.showAge = function () {
    console.log('my age is：', this.age);
}

let child1 = new Child("mjy", 18);
child1.showAge(); // 18
child1.showName(); // mjy
child1.hoby.push("rap");
console.log(child1.hoby); // ['唱', '跳', 'rap']

let child2 = new Child("yl", 18);
child2.showAge(); // 18
child2.showName(); // yl
console.log(child2.hoby); // ['唱', '跳']
```

#### 28、call、apply、bind的区别

- 1.共同点：功能一致

<pre>
    改变函数体内的this指向
    call语法： 函数.call(this指向, 参数1, 参数2, ...)
    apply语法：函数.apply(this指向, [参数1, 参数2, ...])
    bind语法： 函数.bind(this指向, 参数1, 参数2, ...)
</pre>

```javascript
let str = '你好';
let obj = {
    str: 'obj内的str'
}

function fn() {
    console.log(this.str);
}

fn(); // 你好
fn.call(obj); //obj内的str
fn.apply(obj); //obj内的str
const a = fn.bind(obj); // fn(){console.log(this.str)}
a(); //obj内的str
```

- 2.不同点：

<pre>
    call和apply会立即调用函数，bind不会立即调用函数，而是返回一个新函数
    call和apply传递参数的方式不同，call传递参数的方式是： 函数.call(this指向, 参数1, 参数2, ...)
    apply传递参数的方式是： 函数.apply(this指向, [参数1, 参数2, ...])
    bind传递参数的方式是： 函数.bind(this指向, 参数1, 参数2, ...)
</pre>

```javascript
function fn(a, b) {
    console.log(a + b);
}

fn.call(null, 1, 2); // 3
fn.apply(null, [1, 2]); // 3
fn.bind(null, 1, 2)(); // 3
```

- 3.使用场景

<pre>
    call和apply的使用场景：当一个对象没有某个方法，但是其他的有，我们可以借助call或apply用其它对象的方法来操作。
    bind的使用场景：当一个函数被多次调用时，bind可以减少重复代码。
</pre>

```javascript
// 用apply 获取数组最大值
let arr = [1, 2, 3, 4, 5];
Math.max.apply(null, arr); // 5
Math.max.call(null, ...arr); // 数组解构获取 5

// 用bind 例子：获取其他元素的实例及属性
const btn1 = document.getElementById('btn1');
const btn2 = document.getElementById('btn2');
btn1.onclick = function () {
    console.log(this); // 输出btn1
}
btn1.onclick = function () {
    console.log(this); // 输出btn2
}.bind(btn2);
```

#### 29、sort背后的原理是什么

- 1.sort的原理

<pre>
    sort() 方法用于对数组的元素进行排序，默认排序顺序是根据字符串Unicode码点。
    sort() 方法会直接修改原数组！
    V8 引擎sort 函数只给出了两种排序 插入排序（InsertionSort） 和 快速排序（QuickSort），
    数量小于10的数组使用插入排序（InsertionSort），大于10的数组使用快速排序（QuickSort）。
    之前版本是：插入排序和快速排序
    现在版本是：冒泡排序
</pre>

- 2.语法

<pre>
    arr.sort(sortBy)；参数sortBy可选。规定排序顺序。必须是函数。
    注：
    如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码进行排序。
    要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。
    如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。
</pre>

- 3.例子

```javascript
// 默认码点排序
var arr = [10, 20, 1, 2];
arr.sort(); // 1,10,2,20
```

```javascript
// 定义排序规则函数 从小到大排序
var arr = [10, 20, 1, 2];
arr.sort(function (a, b) {
        return a - b
    }
); // 1,2,10,20
```

```javascript
// 对象数组排序
var arr = [{name: 'zs', age: 20}
    , {name: 'ls', age: 30}
    , {name: 'ww', age: 25}
];

function compare(property) {
    return function (a, b) {
        var value1 = a[property];
        var value2 = b[property];
        return value1 - value2;
    }
}

arr.sort(compare('age')); // {name: 'ww', age: 25},{name: 'zs', age: 20},{name: 'ls', age: 30}  
```

#### 30、冒泡排序

- 1.冒泡排序的原理

<pre>
    冒泡排序是一种简单的排序算法。它重复地遍历要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。
    遍历数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。
    这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。
</pre>

- 2.冒泡排序的实现

```javascript
function bubbleSort(arr) {
    var len = arr.length;
    for (var i = 0; i < len - 1; i++) {
        for (var j = 0; j < len - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {        // 相邻元素两两对比
                var temp = arr[j + 1];        // 元素交换
                arr[j + 1] = arr[j];
                arr[j] = temp;
            }
        }
    }
    return arr;
}

bubbleSort([6, 1, 2, 7, 9, 3, 4, 5, 10, 8]);
```

#### 31、深拷贝和浅拷贝

- 1.共同点：复制
- 2.浅拷贝：只复制引用，而未复制真正的值
- 3.深拷贝：复制真正的值

```javascript
// 案例：浅拷贝 赋值
var arr = [1, 2, 3, 4]
var arr1 = arr;
arr1[0] = 10;
console.log(arr); // [10,2,3,4]
```

```javascript
// 案例：浅拷贝 Object.assign 
var obj = {
    name: 'zs',
    age: 20,
    info: {
        address: '北京',
        desc: '技术宅'
    }
}

var obj1 = Object.assign(obj);
obj1.info.address = '上海';
console.log(obj.info.address); // 上海
```

```javascript
// 案例：深拷贝 JSON.parse(JSON.stringify(obj))
var obj = {
    name: 'zs',
    age: 20,
    info: {
        address: '北京',
        desc: '技术宅'
    }
}

var obj1 = JSON.parse(JSON.stringify(obj));
obj1.info.address = '上海';
console.log(obj.info.address); // 北京
// 注意：只能拷贝属性 不能拷贝方法
```

```javascript
//案例：深拷贝 递归

function deepClone(obj, hash = new WeakMap()) {
    if (obj === null) return obj; // 如果是null或者undefined我就不进行拷贝操作
    if (obj instanceof Date) return new Date(obj);
    if (obj instanceof RegExp) return new RegExp(obj);
    // 可能是对象或者普通的值  如果是函数的话是不需要深拷贝
    if (typeof obj !== "object") return obj;
    // 是对象的话就要进行深拷贝
    if (hash.get(obj)) return hash.get(obj);
    let cloneObj = new obj.constructor();
    // 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身
    hash.set(obj, cloneObj);
    for (let key in obj) { // 循环引用对象
        if (obj.hasOwnProperty(key)) {
            // 实现一个递归拷贝
            cloneObj[key] = deepClone(obj[key], hash);
        }
    }
    return cloneObj;
}

var obj = {
    name: 'zs',
    age: 20,
    info: {
        address: '北京',
        desc: '技术宅'
    }
}
var obj1 = deepClone(obj);
obj1.info.address = '上海';
console.log(obj.info.address); // 北京
```

#### 32、var、let、const 区别

<pre>
    1.共同点：
        都是用来声明变量的；
    2.不同点：
        2.1 var具有变量提升的机制，let、const 没有变量提升的机制；
        2.2 var可以多次声明同一个变量，let、const 不可以多次声明同一个变量；
        2.3 var、let用来声明变量的，const用来声明常量的，常量值在后面出现的代码中不能再次修改（引用类型可以修改属性值\下标值）；
        2.4 var声明的变量没有块级作用域，let、const声明的变量有块级作用域；
</pre>

```js
// 变量提升
// var
console.log(a) // 输出undefined
var a = 0;

// let
console.log(b) // 报错ReferenceError: b is not defined
let b = 0;

// const
console.log(c) // 报错ReferenceError: c is not defined
const c = 0;
```

```js
// 可以多次声明同
// var
var a = 0;
var a = 1;
console.log(a) // 1

// let
let b = 0;
let b = 1;
console.log(b) // 报错Identifier 'b' has already been declared

// const
const c = 0;
const c = 1;
console.log(c) // 报错Identifier 'c' has already been declared
```

```js
// var、let用来声明变量的，const用来声明常量的
// var
var a = 0;
a = 1;
console.log(a) // 1

// let
let b = 0;
b = 1;
console.log(b) // 1

// const
const c = 0;
c = 1;
console.log(c) // 报错Assignment to constant variable.
```

```js
// 块级作用域
// var
if (true) {
    var a = 0;
}
console.log(a) // 0

// let
if (true) {
    let b = 0;
}
console.log(b) // 报错ReferenceError: b is not defined

// const
if (true) {
    const c = 0;
}
console.log(c) // 报错ReferenceError: c is not defined
```

```js
// 作用域常见实操1
// var
function demo() {
    var n = 2;
    if (true) {
        var n = 1
    }
    console.log(n)// 1
}

demo()

// let
function demo() {
    let n = 2;
    if (true) {
        let n = 1
    }
    console.log(n)// 2
}

demo()

```

```js
// 作用域常见实操2
// const 引用类型可以修改属性值或下标值
const obj = {
    a: 1
}
obj.a = 2;
console.log(obj.a) // 2

const arr = ['a', 'b', 'c']
arr[0] = 'aaaaa';
console.log(arr) // ['aaaaa', 'b', 'c'] 
```

#### 33、对象合并

- 1.Object.assign()

```js
const target = {a: 1}
const source1 = {b: 2}
const source2 = {c: 3}
Object.assign(target, source1, source2) // 方式一
console.log(target) // { a: 1, b: 2, c: 3 }
const obj1 = Object.assign(target, source1, source2) // 方式二
console.log(obj1) // { a: 1, b: 2, c: 3 }
```

- 2.扩展运算符

```js
const target = {a: 1}
const source1 = {b: 2}
const source2 = {c: 3}
const obj1 = {...target, ...source1, ...source2}
console.log(obj1) // { a: 1, b: 2, c: 3 }
```

- 3.Object.setPrototypeOf()

```js
const target = {a: 1}
const source1 = {b: 2}
const source2 = {c: 3}
const obj1 = Object.setPrototypeOf(Object.assign({}, target, source1, source2), source2)
console.log(obj1) // { a: 1, b: 2, c: 3 }
```

- 4.自己封装方法

```js
const target = {a: 1}
const source1 = {b: 2}
const source2 = {c: 3}

function merge(target, ...sources) {
    sources.forEach(source => {
        for (const key in source) {
            if (source.hasOwnProperty(key)) {
                target[key] = source[key]
            }
        }
    })
    return target
}

const obj1 = merge(target, source1, source2)
console.log(obj1) // { a: 1, b: 2, c: 3 }
````

#### 34、箭头函数和普通函数的区别

- 1.this指向问题

<pre>
     箭头函数中的this只在箭头函数定义时就决定的，而且不能通过bind、call、apply来改变this的指向
    （箭头函数中的this指向定义时候、外层第一个普通函数的this，而不是使用它时所处的对象）
</pre>

```js
// 普通对象中的方法this 指向
const obj = {
    a: function () {
        console.log(this)
    },
    b: () => {
        console.log(this)
    }
}
obj.a() // 输出obj对象
obj.b() // 输出window对象
```

```js
// 闭包中的this 指向
const obj = {
    run: function () {
        console.log('run', this) //  输出obj对象
        return function () {
            console.log(this)
        }
    },
    jump: () => {
        console.log('jump', this) // 输出window对象
        return () => {
            console.log(this)
        }
    }
}

obj.run()() // 输出window对象
obj.jump()() // 输出window对象
```

```js
// 闭包中的this 指向通过call\apply\bind改变this指向
const obj = {
    a: function () {
        console.log('a', this) // 输出obj对象
        return function () {
            console.log(this)
        }
    },
    b: function () {
        console.log('b', this) // 输出obj对象
        return () => {
            console.log(this)
        }
    }
}
obj.a().call({x: 100}) // 输出{x:100}
obj.b().call({x: 100}) // 输出obj对象
```

- 2.箭头函数不能作为构造函数(不能使用 new 关键字)

```js
// 箭头函数
const run = () => {
    console.log(this)
}
const obj = new run() // 报错 run is not a constructor

// 普通函数
const run = function () {
    console.log(this)
}
const obj = new run() // 输出obj对象
```

- 3.箭头函数没有arguments

```js
// 箭头函数
const run = () => {
    console.log(arguments) // 报错 arguments is not defined
}

// 普通函数
const jump = function () {
    console.log(arguments) // 输出arguments对象
}
run()
jump()
```

- 4.箭头函数没有原型对象

```js
// 箭头函数
const run = () => {
}
console.log(run.prototype) // undefined

// 普通函数
const jump = function () {
}
console.log(jump.prototype) // 输出原型对象
```

- 5.箭头函数不能使用yield关键字 (不能作为Generator函数)

```js
// 箭头函数
//     const run = ()=>{
//         yield 1
//     }

// 普通函数
function* jump() {
    yield 1
}

// const ru = run(); // 报错 yield cannot be used outside of generator function
// console.log(ru.next()) // 输出{value: 1, done: false}

const ju = jump()
console.log(ju.next()) // 输出{value: 1, done: false}

````

#### 35、find和filter的区别

- filter返回一个新数组，find返回第一个符合条件的数组成员（没有则返回undefined） --- （注意：都不会改变原数组）

```js
const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]
const newArr = arr.filter(item => item > 5) // [6,7,8,9]
const newArr1 = arr.find(item => item > 5) // 6
```

#### 36、some 和 every的区别

- every返回布尔值，some返回布尔值，some只要有一个满足条件就返回true，every所有都满足条件才返回true --- （注意：都不会改变原数组）

```js
const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]
const newArr = arr.some(item => item > 5) // true
const newArr1 = arr.every(item => item > 5) // false
```

#### 37、reduce和reduceRight的区别

- reduce和reduceRight都会把数组中的元素通过函数进行处理
- reduce是从左到右，reduceRight是从右到左

```js   

const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]
const newArr = arr.reduce((prev, curr) => {
    return prev + curr
}) // 25

const newArr1 = arr.reduceRight((prev, curr) => {
    return prev + curr
}) // 25
```
#### 38、连续解构赋值

```js
const obj = {a:{b:{c:1}}}
// 连续解构赋值 获取深嵌套数据
const {a:{b:{c}}} = obj

console.log(c) // 1

// 连续解构赋值 + 重命名
const {a:{b:{c:v}}} = obj

console.log(v) // 1
````
### 4、nodeJS

### 5、Vue

#### 1、什么是渐进式框架

- 渐进式框架：指根据不同需求，从核心功能开始，逐渐添加其他功能，最终形成一个完整功能的框架
- vue.js 核心库 vue-router（渐1） 路由 vuex（渐2） 状态管理 .... 最后形成一个完整功能的框架

#### 2、vue2.x的生命周期

- 1.有哪些生命周期
- 系统自带：

<pre>
    1.beforeCreate
    2.created
    3.beforeMount
    4.mounted
    5.beforeUpdate
    6.updated
    7.beforeDestroy
    8.destroyed
</pre>

- 2.一旦进入到页面或者组件，会执行哪些生命周期，顺序。

<pre>
    1.beforeCreate -> created -> beforeMount -> mounted
</pre>

- 3.在哪个阶段有$el,在哪个阶段有$data

<pre>
    beforeCreate 啥都没有
    created      有data,没有el
    beforeMount  有data,没有el,但是没有dom
    mounted      有data,有el,有dom
</pre>

- 4.如果加入了keep-alive，会执行哪些生命周期

<pre>
    activated   进入页面
    deactivated 离开页面
</pre>

- 5.如果加入了keep-alive，第一次进入组件会执行哪些生命周期

<pre>
    beforeCreate -> created -> beforeMount -> mounted -> activated
</pre>

- 6.如果加入了keep-alive，再次进入组件会执行哪些生命周期

<pre>
  进入执行 activated  离开执行  deactivated 
</pre>

```js
// vue 执行顺序 及 为什么拿不到 data,el
class Vue {
    constructor(options) {
        // 在这里调用顺序为周期的执行顺序，与组件中写入顺序无关
        potions.beforeCreate.bind(this)()
        // 赋值的时机决定是否拿到当前属性
        this.$data = options.data;
        potions.created.bind(this)()
        potions.beforeMount.bind(this)()
        this.$el = document.querySelector(options.el);
        potions.mounted.bind(this)()
    }
}

new Vue({
    data: {
        name: 'zs'
    },
    el: '#app',
    template: '<div>{{name}}</div>',
    beforeCreate() {
        console.log('beforeCreate', this.name)
    },
    created() {
        console.log('created', this.name)
    },
    beforeMount() {
        console.log('beforeMount', this.$el)
    },
    mounted() {
        console.log('mounted', this.$el)
    }
})


```

#### 3、keep-alive

- 1.keep-alive 是什么

<pre>
    keep-alive 是一个 Vue 内置的组件，可以使被包含的组件保留状态，或避免重新渲染。
</pre>

- 2.keep-alive 的作用

<pre>
    1、保持组件的状态，避免重新渲染；
    2、减少组件的重新渲染次数，提高性能；
    3、缓存组件，避免频繁创建和销毁组件；
</pre>

- 3.keep-alive 的使用

<pre>
    1、在组件中使用 keep-alive 标签包裹需要缓存的组件；
    2、在组件中使用 v-if 或者 v-show 控制组件的显示和隐藏；
    3、在组件中使用 v-once 指令，避免组件的重新渲染；
</pre>

- 4.keep-alive 的原理

<pre>
    1、keep-alive 组件在渲染时，会将需要缓存的组件的 vnode 存储到缓存列表中；
    2、在组件被销毁时，会将组件的 vnode 从缓存列表中移除；
    3、在组件被重新渲染时，会从缓存列表中获取对应的 vnode，并重新渲染组件；
</pre>

- 5.keep-alive 的注意事项

<pre>
    1、keep-alive 组件只能包裹动态组件，不能包裹静态组件；
    2、keep-alive 组件的 name 属性可以用于匹配需要缓存的组件；
    3、keep-alive 组件的 include 属性可以用于匹配需要缓存的组件；
    4、keep-alive 组件的 exclude 属性可以用于匹配不需要缓存的组件；
</pre>

- 6.keep-alive 的使用场景

<pre>
    1、需要缓存组件的状态；
    2、需要减少组件的重新渲染次数；
    3、需要缓存组件的性能；
</pre>

- 7.keep-alive 的性能优化

<pre>
    1、使用 include 属性匹配需要缓存的组件；
    2、使用 exclude 属性匹配不需要缓存的组件；
    3、使用 max 属性限制缓存的组件数量；
</pre>

- 8.keep-alive 的最佳实践

<pre>
    1、在需要缓存的组件中使用 v-if 或者 v-show 控制组件的显示和隐藏；
    2、在需要缓存的组件中使用 v-once 指令，避免组件的重新渲染；
    3、在需要缓存的组件中使用 keep-alive 组件包裹；
</pre>

#### 4、v-if 和 v-show 的区别

- 1.两者区别

<pre>
    1、v-if 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；
    2、v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块；
    3、相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换
</pre>

- 2.使用场景

<pre>
    1、v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；
    2、v-show 适用于在运行时需要频繁切换条件的场景；
</pre>

#### 5、v-if 和 v-for 的优先级

```html

首先，官方不推荐v-if和v-for在同一个元素上使用。其次，如果两者同时使用，v-if和v-for的优先级怎么确定？
在vue2和vue3中这两者的优先级顺序不一样。vue2是v-for优先，条件不存在时也会渲染多个注释节点。
在vue3中进行了改进，v-if优先级高。在vue3中，v-if在编译阶段进行了静态节点提升，所以在v-for遍历每个节点，v-if对单个节点判断，这种情况会报错。
不管是vue2还是vue3，都推荐，将v-for遍历的数组用计算属性改写，根据v-if依赖的条件返回过滤后的数组。

vue2:
v-for的优先级要比v-if高，(源码 genElement 方法中查看）
<div>
    <li v-for="item in arr" :key="item" v-if="item % 2">item</li>
</div>
编译就会报错，让你把v-if移到上面标签

vue3:
直接举例v-if和v-for同时存在，并且v-if引用了v-for的遍历结果。
<div>
    <li v-for="item in arr" :key="item" v-if="item % 2">item</li>
</div>
可以看到控制台报错(item is not defined)，item未定义。这是因为item在编译为渲染函数的时候提到v-for的上面一层了。使用的时候还没在定义。

```

#### 6、vue3 中的 watch 和 watchEffect 的区别

- 1.watch 和 watchEffect 的区别

<pre>
    1、watch 需要手动指定监听的属性，而 watchEffect 则可以自动追踪依赖；
    2、watch 支持 immediate 和 deep 选项，而 watchEffect 不支持；
    3、watch 支持同步和异步两种模式，而 watchEffect 只支持异步模式；
    4、watch 可以在监听的属性变化时执行任意的同步或异步操作，而 watchEffect 只能执行同步操作；
</pre>

- 2.使用场景

<pre>
    1、watch 适用于监听特定的属性，而 watchEffect 则适用于监听属性变化的副作用；
    2、watch 适用于需要手动指定监听的属性，而 watchEffect 则适用于不需要手动指定监听的属性；
</pre>

#### 7、vue3 中的 provide 和 inject 的区别

- 1.provide 和 inject 的区别

<pre>
    1、provide 可以在祖先组件中提供数据，而 inject 可以在后代组件中注入数据；
    2、provide 和 inject 都是响应式的，当提供或注入的数据发生变化时，组件会自动更新；
    3、provide 和 inject 都可以传递任何类型的数据，包括对象、数组等；
</pre>

- 2.使用场景

<pre>
    1、provide 适用于提供数据给后代组件，而 inject 适用于注入数据给后代组件；
    2、provide 和 inject 都可以在组件的任意位置使用，不需要在组件的根节点上使用；
</pre>

#### 8、vue3 中的 nextTick 的作用

- 1.nextTick 的作用

<pre>
    1、nextTick 可以在下次 DOM 更新循环结束之后执行延迟回调；
    2、nextTick 返回一个 Promise 对象，可以在 Promise 对象中执行回调函数；
    3、nextTick 可以在组件更新后执行延迟回调；
</pre>

- 2.使用场景

<pre>
    1、nextTick 适用于需要在组件更新后执行延迟回调的场景；
    2、nextTick 可以在组件更新后获取更新后的 DOM 元素；
    3、nextTick 可以在组件更新后执行异步操作；
</pre>

#### 9、vue3 中的 Teleport 的作用

- 1.Teleport 的作用

<pre>
    1、Teleport 可以将组件中的部分内容移动到指定位置；
    2、Teleport 可以通过标签选择器来指定移动的位置；
    3、Teleport 可以通过属性来指定移动的位置；
</pre>

- 2.使用场景

<pre>
    弹框自定义组件
</pre>

#### 10、vue3 中的 Suspense 的作用

- 1.Suspense 的作用

<pre>
    1、Suspense 可以在组件加载过程中显示 loading 状态；

    2、Suspense 可以在组件加载失败时显示错误信息；

    3、Suspense 可以在组件加载完成后显示默认内容；
</pre>

- 2.使用场景

```html
<!--loading-->
<template>
    <Suspense>
        <template #default>
            <!-- 异步组件加载时的占位符 -->
            <div>Loading...</div>
        </template>
        <AsyncComponent/>
    </Suspense
</template>
```

```html
<!--error-->
<template>
    <Suspense>
        <template #default>
            <AsyncComponent/>
        </template>
        <template #fallback>
            <div>Loading...</div>
        </template>
    </Suspense>
</template>
```

#### 11、ref 是什么

- 1.ref 的作用

<pre>
    1、ref 可以用来获取 DOM 元素或组件实例；
    2、ref 可以用来获取响应式数据；
</pre>

- 2.使用场景

```html
<!--获取dom-->
<template>
    <div ref="myDiv" id="Hello">Hello, Vue!</div>
</template>
<script>
    export default {
        mounted() {
            // const myDiv = document.getElementById('Hello');
            const myDiv = this.$refs.myDiv;
            console.log(myDiv); // 输出 DOM 元素
        }
    }
</script>
```

```html
<!--获取响应式数据-->
<template>
    <div ref="myDiv">Hello, Vue!</div>
</template>
<script>
    export default {
        mounted() {
            const myDiv = this.$refs.myDiv;
            console.log(myDiv.textContent); // 输出 "Hello, Vue!"
        }
    }
</script>
```

#### 12、scoped原理

- 1.scoped 的作用

<pre>
    1、scoped 可以用来给组件的样式添加唯一标识，防止样式冲突；
</pre>

- 2.原理

<pre>
    1、在组件的根元素上添加一个唯一的属性，例如 data-v-xxxx；
    2、在组件的样式中，使用该属性作为选择器，来限制样式的作用范围；
</pre>

#### 13、vue 如何做样式穿透

- 样式穿透的三种方法：
- 1.原生CSS样式穿透 （操作符 >>>）：外层 >>> 第三方组件{ 样式 }

```css
.parent >>> .child {
}
```

```stylus
.parent >>> .child {}
```

- 2.less的样式穿透（深度选择器/deep/） ：/deep/
  项目中用到了预处理器 less ，可以使用 /deep/。
  /deep/ 第三方组件 {样式}

```less
.parent /deep/ .child {
  color: red;
}
```

- 3.scss样式穿透（深度选择器::v-deep）：::v-deep
  ::v-deep 第三方组件 {样式}
  (我记得版本更新后的用法建议使用:deep(.child))
-

```scss
.parent :deep (.child) {
  color: red;
}
```

#### 14、vue 组件之间的通信方式

- 1.父传子

<pre>
    1、父组件通过动态属性传递数据给子组件；
    2、子组件通过props属性接收父组件传递的数据；
</pre>

```html
<!-- 父组件-->
<template>
    <ChildComponent :message="parentMessage"></ChildComponent>
</template>

<script>
    export default {
        data() {
            return {
                parentMessage: 'Hello, Child!'
            }
        }
    }
</script>
```

```html
<!--子组件接收数据-->
<template>
    <div>{{ message }}</div>
</template>

<script>
    export default {
        props: ['message']
    }
</script>
```

- 2.子传父

<pre>
    1、父组件通过事件监听子组件触发的自定义事件；
    2、子组件通过$emit()方法触发自定义事件，并传递数据；
</pre>

```html
<!-- 父组件 -->
<template>
    <ChildComponent @child-event="handleChildEvent"></ChildComponent>
</template>

<script>
    export default {
        methods: {
            handleChildEvent(data) {
                console.log(data);
            }
        }
    }
</script>
```

```html
<!-- 子组件 -->
<template>
    <button @click="handleClick">触发事件</button>
</template>

<script>
    export default {
        methods: {
            handleClick() {
                this.$emit('child-event', '子组件传递的数据');
            }
        }
    }
</script>
```

- 3.兄弟组件

<pre>
    1、通过共同的父组件作为中介，通过父组件传递数据；   
</pre>

```html
<!-- 父组件 -->
<template>
    <ChildComponent1 @child-event="handleChildEvent"></ChildComponent1>
    <ChildComponent2 :data="sharedData"></ChildComponent2>
</template>

<script>
    export default {
        data() {
            return {
                sharedData: '共享的数据'
            }
        }
    }
</script>
```

```html
<!-- 子组件1 -->
<template>
    <button @click="handleClick">触发事件</button>
</template>

<script>
    export default {
        methods: {
            handleClick() {
                this.$emit('child-event', '子组件1传递的数据');
            }
        }
    }
</script>
``` 

```html
<!-- 子组件2 -->
<template>
    <p>{{ data }}</p>
</template>

<script>
    export default {
        props: ['data']
    }
</script>
```

<pre>
    2、通过bus传递数据；   
</pre>

```js
// 创建一个bus
import Vue from 'vue'

export default new Vue();
````

```html
<!-- 子组件1 -->
<template>
    <button @click="handleClick">触发事件</button>
</template>

<script>
    export default {
        // import 导入bus
        methods: {
            handleClick() {
                bus.$emit('child-event', '子组件1传递的数据');
            }
        }
    }
</script>
```

```html
<!-- 子组件2 -->
<template>
    <p>{{ sharedData }}</p>
</template>

<script>
    // import 导入bus
    export default {
        data() {
            return {
                sharedData: ''
            }
        },
        created() {
            bus.$on('child-event', (data) => {
                this.sharedData = data;
            });
        }
    }
</script>
```

#### 15、computed、watch、methods的区别

- 1.computed 和 methods 区别
<pre>
    computed 是有缓存的，
    methods 没有缓存。
</pre>
```html

<template>
    <p>{{ fullName() }}</p>
    <p>{{ fullName() }}</p>
    <p>{{ fullName() }}</p>
    <p>{{ fullName() }}</p>

    <p>{{ getName() }}</p>
    <p>{{ getName() }}</p>
    <p>{{ getName() }}</p>
    <p>{{ getName() }}</p>
</template>

<script>
    export default {
        data() {
            return {}
        },
        computed: {
            fullName: function () {
                console.log('computed 被调用'); // 打印了 1次 证明使用了缓存 只调用一次
                return '12334'
            }
        },
        methods: {
            getName() {
                console.log('methods 被调用'); // 打印了4次 证明调用了四次
                return '12334'
            }
        }
    }
</script>
```

- 2.computed 和 watch 区别

<pre>
      1、watch是监听数据或者路由发生了改变才可以相应（执行）
      2、computed 计算某一个属性的改变，如果某一个值变化了，计算属性会监听到并进行返回
</pre>

#### 16、props 和 data 优先级谁高

-  props ===> methods ===> data ===> computed ===> watch

#### 17、vuex

- 1.vuex 是什么

<pre>
    1、vuex 是一个专门为 vue.js 应用程序开发的状态管理模式；
    2、vuex 采用集中式存储管理应用的所有组件的状态；
</pre>

- 2.vuex 有哪些属性 

<pre>
    1、state：状态，用于存储数据；
    2、getters：获取数据，用于对数据进行一些计算，然后返回；
    3、mutations：修改数据，用于修改 state 中的数据；
    4、actions：提交数据，用于提交 mutations 中的数据；
    5、modules：模块化，用于将 vuex 拆分成多个模块；(都放在一个状态管理中会比较庞大 所以拆分成多个模块便于维护user模块，menus模块，....)
</pre>

- 3.vuex 怎么使用

<pre>
    1、安装 vuex：npm install vuex --save
    2、创建 store 文件夹，在 store 文件夹中创建 index.js 文件；
    3、在 main.js 中引入 vuex，并使用 vuex 创建 store 对象；
    4、在组件中使用 vuex 中的数据；
</pre>

```js
// user 模块
export default {
    state: {},
  getters: {},
  mutations: {},
  actions: {}
}
```
```js
// menus 模块
export default {
    state: {
        menuList:[1,2,3]
    },
  getters: {},
  mutations: {},
  actions: {}
}
```

```js
// 创建一个状态管理
import Vue from 'vue'
import Vuex from 'vuex'
import user from './modules/user'
import menus from './modules/menus'
Vue.use(Vuex)

export default new Vuex.Store({
    state: { // 定义状态变量
        count: 0,
      arr:[1,2,3]
    }, 
  getters: { // 定义计算属性方法
    count: state => state.count,
    changeArr: state => state.arr.map(item => item * 2)
  },
  mutations: {
    increment (state,c) { // 如果假如异步操作，视图数据和提交数据可能不同 导致异常问题
      state.count + c
    }
  },
  actions: {
    increments ({commit,state}) { // 异步操作 提交数据和视图数据是一致的
        setTimeout(()=>{
          commit('increment') 
        },1000)
    }
  },
  modules: { // 模块化
        user, // 将user 模块导入
        menus // 将menus 模块导入
  }
})
```

```html
<!--不分模块使用状态管理-->
<template>
    <div>
        <p>{{ count }}</p>
        <p>{{ changeArr }}</p>
        <button @click="increment(3)">+</button>
    </div>
</template>
<script>
    import {mapState, mapGetters, mapMutations, mapActions} from 'vuex'

    export default {
        computed: {
            ...mapState(['count']), //  mapState state状态映射 固定用法
            ...mapGetters(['count', 'changeArr']) //  mapGetters 计算属性映射 固定用法
        },
        methods: {
            ...mapMutations(['increment']), //  mapMutations mutations 映射 固定用法
            ...mapActions(['increments']) //  mapActions actions 映射 固定用法
            // increment() {
            //     this.$store.dispatch('increment')
            // }
        }
    }
</script>
```
```html
<!--分模块使用状态管理-->
<template>
    <div>
        <p>{{ count }}</p>
        <p>{{ changeArr }}</p>
        <button @click="increment(3)">+</button>
    </div>
</template>
<script>
    import {mapState, mapGetters, mapMutations, mapActions} from 'vuex'

    export default {
        computed: {
            ...mapState({
              menuList: state => state.menus.menuList
            }), //  mapState state状态映射
            ...mapGetters('user', ['count', 'changeArr']) //  mapGetters 计算属性映射
        },
      methods: {
            ...mapMutations('user', ['increment']), //  mapMutations mutations 映射
            ...mapActions('user', ['increments']) //  mapActions actions 映射
            // increment() {
            //     this.$store.dispatch('increment')
            // }
        }
    }
</script>   
```
-  4.vuex中 mutations 和 actions 区别

<pre>
    1.mutations 都是同步操作
    2.actions 可以包含任意异步操作
</pre>

-  5.vuex是单向数据流

<pre>
    1.state 中的数据只能通过 mutations 中的方法进行修改
    2.actions 中的方法只能通过 commit 方法触发 mutations 中的方法
</pre>

-  6.vuex 如何做持久化存储

<pre>
    vuex本身不是持久化存储，需要手动封装或者第三方插件，将数据存储到浏览器进行存储（localStorage、sessionStorage、cookie等）
    1.vuex-persistedstate
    2.vuex-persist
</pre>
```js
// 1.下载安装插件第一步： 
// npm install vuex-persistedstate --save
// 2.使用 vuex-persistedstate 进行持久化存储 配置
import createPersistedState from 'vuex-persistedstate'

const store = new Vuex.Store({
    // ...
    plugins: [createPersistedState({storage: window.sessionStorage})]
})
```

```js
// 1.下载安装vuex-persist插件
// npm install vuex-persist --save
// 2.使用vuex-persist进行持久化存储 配置
import createPersistedState from 'vuex-persist'

const store = new Vuex.Store({
    // ...
    plugins: [createPersistedState({storage: window.sessionStorage})]
})
```

#### 18、vue设置代理


<pre>
    1.在vue.config.js中进行配置
</pre>

```js
module.exports = {
    devServer: {
        proxy:{
            '/api':{
              target:'http://localhost:5000',
              
              // 这个配置项可不配 跟解决跨域无关，只是为了修改请求头中的host 
              // 解决问题：一台服务器区分多个虚拟机，http2.0已经没有 host 请求头了
              changeOrigin: true,
            }
        }
     
    }
}
```

#### 19、打包路径和路由模式

<pre>
    1.打包路径：publicPath 进行配置 默认是 /
    2.路由模式：
      默认值：hash
      可选值：hash、history、abstract
      打包路径 publicPath 设置为 './',使用hash路由可以直接访问，使用history路由需要配置服务器
</pre>
```js
module.exports = {
    publicPath: process.env.NODE_ENV === 'production' ? '/vue-admin-template/' : '/'
}
```


#### 20、vue路由

- 1.路由的模式

  - 1.hash模式：默认值，使用#进行分割，#后面的内容就是hash值

  - 2.history模式：使用url中的路径进行分割，没有#

  - 区别

    - 1.表现形式不同  hash url中有#，history 没有#

    - 2.跳转请求：history 会发送请求，hash 不会发送请求

- 2.路由的懒加载

  - 1.路由的懒加载：当路由被访问的时候才加载对应组件，减少js的体积

  - 2.使用方法：

    - 1.使用import()函数进行引入

    - 2.使用webpack的require.ensure()函数进行引入

- 3.路由的嵌套

  - 1.使用children属性进行配置

- 4.路由的命名

  - 1.使用name属性进行配置

- 5.路由的参数传递

  - 1.使用query进行传递

- 6.全局前置守卫

<pre>
    1、全局前置守卫的作用：在路由导航之前进行一些处理；
    2、全局前置守卫的使用：在 router.js 中进行配置；
</pre>

```js
const router = new VueRouter({
    routes: [
        // ...
    ]
})

router.beforeEach((to, from, next) => {
    // 在路由导航之前进行一些处理
    // to: 即将要进入的目标路由对象
    // from: 当前导航正要离开的路由
    // next: 是一个函数，表示放行，next() 放行，next('/login') 强制跳转
})

new Vue({
    router,
    // ...
})
```

- 7.全局后置钩子

<pre>
    1、全局后置钩子的作用：在路由导航之后进行一些处理；
    2、全局后置钩子的使用：在 router.js 中进行配置；
</pre>

```js
const router = new VueRouter({
    routes: [
        // ...
    ]
})

router.afterEach((to, from) => {
    // 在路由导航之后进行一些处理
    // to: 即将要进入的目标路由对象
    // from: 当前导航正要离开的路由
})

new Vue({
    router,
    // ...
})
```

- 8.路由独享的守卫

<pre>
    1、路由独享的守卫的作用：在路由配置中进行一些处理；
    2、路由独享的守卫的使用：在路由配置中进行配置；
</pre>

```js
const router = new VueRouter({
    routes: [
        {
            path: '/',
            component: Home,
            beforeEnter: (to, from, next) => {
                // 在路由导航之前进行一些处理
                // to: 即将要进入的目标路由对象
                // from: 当前导航正要离开的路由
                // next: 是一个函数，表示放行，next() 放行，next('/login') 强制跳转
            }
        }
    ]
})

new Vue({
    router,
    // ...
})
```

- 4.组件内的守卫

<pre>
    1、组件内的守卫的作用：在组件中进行一些处理；
    2、组件内的守卫的使用：在组件中进行配置；
</pre>

```js
const Foo = {
    template: `...`,
    beforeRouteEnter(to, from, next) {
        // 在路由导航之前进行一些处理
        // to: 即将要进入的目标路由对象
        // from: 当前导航正要离开的路由
        // next: 是一个函数，表示放行，next() 放行，next('/login') 强制跳转
    },
    beforeRouteUpdate(to, from, next) {
        // 在路由导航之前进行一些处理
        // to: 即将要进入的目标路由对象
        // from: 当前导航正要离开的路由
        // next: 是一个函数，表示放行，next() 放行，next('/login') 强制跳转
    },
    beforeRouteLeave(to, from, next) {
        // 在路由导航之前进行一些处理
        // to: 即将要进入的目标路由对象
        // from: 当前导航正要离开的路由
        // next: 是一个函数，表示放行，next() 放行，next('/login') 强制跳转
    }
}
```

#### 21、vue 性能优化
-  1.编码优化
```text
1. 不要把所有数据都放在data中；
2. v-for 时给每个元素绑定事件用事件代理；
3. keep-alive缓存组件；
4. 尽可能差分组件，提高复用性、维护性；
5. key值要保证唯一；
6. 合理使用路由懒加载，异步组件；
7. 数据持久化存储的时候尽量用防抖、节流优化。
```
-  2.加载优化
```text
1. 按需加载；
2. 内容懒加载；
3. 图片懒加载；
```
-  3.用户体验
```text
1. 骨架屏；
2. 加载loading；
```
-  4.seo优化
```text
1. 合理的title、description、keywords；
2. 语义化的HTML结构，符合W3C规范；
3. 避免在HTML中写内联样式和内联脚本；
4. 使CSS和JavaScript异步加载；
5. 预渲染；
   @prerender/webpack-plugin + @prerender/renderer-puppeteer
6. 服务端渲染ssr;
   react : next
     vue : nuxt   
```
-  5.打包优化
```text
1. 压缩代码：
      html 使用 html-webpack-plugin 插件进行压缩，
      css 使用 css-loader 的 minimize 选项进行压缩，
      js 使用 uglifyjs-webpack-plugin 进行压缩；
      图片 使用 image-webpack-loader 进行压缩；
2. CDN 形式加载第三方模块；
3. 多线程打包；
4. 抽离公共文件；
```
-  6. 缓存和压缩
```text
1. 客户端缓存，服务端缓存；
2.服务端Gzip压缩；
```

#### 22、首屏优化
```text
1. 使用路由懒加载；
2. 非首屏组件使用异步组件；
3. 首屏不重要的组件延迟加载；
4. 静态资源放在CDN上（CDN加速）；
5. 减小首屏上JS,CSSs等资源文件的大小（使用压缩文件）；
6. 使用服务端渲染(SSR)；
7. 尽量减少DOM的数量和层级；
8. 使用精灵图减少请求次数；
9. 做loading;
10. 开启Gzip压缩；
    vite插件：vite-plugin-compression 
    
11. 图片懒加载；
```
```js
// vite.config.js 配置 gzip压缩插件
import { defineConfig } from 'vite';
import compression from 'vite-plugin-compression';

export default defineConfig({
  plugins: [
    compression({
      verbose: true, // 输出压缩日志
      disable: false, // 是否禁用压缩
      threshold: 10240, // 对超过10KB的文件进行压缩
      algorithm: 'gzip', // 使用gzip压缩
      ext: '.gz', // 压缩后文件的扩展名
    }),
  ],
});
```
```js
// webpack.config.js 配置 gzip压缩插件
const CompressionPlugin = require('compression-webpack-plugin')
 
module.exports = {
    configureWebpack: {
        plugins: [
          // http://doc.ruoyi.vip/ruoyi-vue/other/faq.html#使用gzip解压缩静态文件
          new CompressionPlugin({
            cache: false,                   // 不启用文件缓存
            test: /\.(js|css|html)?$/i,     // 压缩文件格式
            filename: '[path].gz[query]',   // 压缩后的文件名
            algorithm: 'gzip',              // 使用gzip压缩
            minRatio: 0.8                   // 压缩率小于1才会压缩
          })
        ],
    }
}
```
#### 23、vue3 性能要比 vue2
```text
1. diff算法优化；（vue2中的diff算法是递归的，vue3中改成了双指针）
2. 静态提升；（提高复用）
3. 事件监听缓存；（事件缓存复用）

```

#### 24、SEO如何优化
```text
1. 服务端渲染(SSR);
2. 预渲染 prerender-spa-plugin;
```

#### 25、ref 和 reactive 
```text
1. ref 用于定义一个响应式的数据，ref 内部会自动创建一个对应的代理对象，这个代理对象就是响应式数据；
2. reactive 用于定义一个响应式的对象，reactive 内部会自动创建一个对应的代理对象，这个代理对象就是响应式对象
```

#### 26、snabbdom 

-  [github地址](https://github.com/snabbdom/snabbdom)
- [npm地址](https://www.npmjs.com/package/snabbdom)
-  1.snabbdom 是什么？
    
```text
1. snabbdom 是什么？
    
2. snabbdom 怎么用？
3. snabbdom 怎么实现 diff 算法？
4. snabbdom 怎么实现虚拟 DOM？
5. snabbdom 怎么实现组件？
6. snabbdom 怎么实现生命周期？
```

### 6、React

### 7、小程序

### 8、uni-app

#### 1. uni-app 分包

<pre>
1、分包的作用：优化小程序的下载和启动速度；
2、小程序启动默认下载主包并启动页面，当用户进入分包时，才会下载对应的分包，下载完进行展示；
3、首先在 mainfest.json mp-weixin添加以下代码（启动分包）(第一个代码块)
4、在pages.json中加入subPackages，里面是对象(第二个代码块)
</pre>

```json lines
{
  "mp-weixin": {
    "appid": "touristappid",
    "setting": {
      "urlCheck": true,
      "checkSiteMap": false
    },
    "usingComponents": true,
    //在此处加上以下一句话
    "optimization": {
      "subPackages": true
    }
  },
}
```

```json lines
{
  "pages": [
    "pages/index/index",
    "pages/good/index",
  ],
  "subpackages": [
    {
      "root": "pagesA",
      //分包的根路径，彼此之间不可以重复
      "name": "pagesA",
      //分包的标识名字，用于预加载分包时用
      "pages": [
        //分包的路径（不预加载的时候，用户进入分包路径才会加载分包资源）
        "register/register"
      ],
      "independent": false
      //是否独立分包（可以不加载主包就独立加载的包，独能立分包不当做全局资源）
    },
    {
      "root": "pagesB",
      "name": "pagesB",
      "pages": [
        "children/addChildren"
      ],
      "independent": false
    }
  ],
  //预加载
  "preloadRule": {
    "pages/index": {
      "network": "",
      "packages": [
        "pagesA"
      ]
      // 在 pages/index 页面中预加载名为 pagesA分包内容
    }
  }
}
```

### 9、Echarts

#### 1. 常用的配置有哪些？

####

<pre>
1、title标题组件 show text link
2、tooltip 提示框组件 show trigger show formatter
3、legend 图例组件 show orient data
4、toolbox 工具栏组件 show feature saveLoad dataZoom restore
5、grid 直角坐标系内绘图网格 show top left bottom right
6、xAxis 直角坐标系 grid 中的 x 轴 show type axisLabel splitLine
7、yAxis 直角坐标系 grid 中的 y 轴 show type axisLabel splitLine
8、polar 极坐标系 show angleAxis radiusAxis
9、radar 雷达图 show indicator
10、series 系列列表 show type data
11、color 颜色映射组件 show color
12、visualMap 视觉映射组件 show type dimension min max inRange outRange
13、dataZoom 数据区域缩放组件 show type start end
14、timeline 时间轴组件 show type currentIndex autoPlay
15、axisPointer 坐标轴指示器组件 show type axis line
</pre>

### 10、webpack

####

#### 1. webpack 打包和不打包的区别

<pre>
    1、打包：将多个文件打包成一个文件，减少网络请求次数，提高运行效率；
    2、对基础的支持不够；
</pre>

#### 2. webpack 打包原理 babel是做什么的

<pre>
    webpack 会将js 、css、image 看作一个模块，用import/require引入，
    找到入口文件，通过入口文件找到关联的依赖文件，把它们打包到一起，
    把bundle文件拆分成多个小文件，异步按需加载所需要的文件。
    如果一个文件被多个文件引用，打包时只会生成一个文件
    如果引用的文件没有被调用，不会被打包，如果引入的变量和方法没有被调用，也不会被打包。
    对于多个入口文件，假如引用了相同的代码，可以用插件把它抽离到公共文件中。
    babel的作用
    1、将es6、es7、es8等高级语法转换成低级语法，让浏览器可以运行；
    2、将react、vue等高级语法转换成低级语法，让浏览器可以运行；
    3、将typescript转换成js，让浏览器可以运行；
    4、将less、sass、stylus等转换成css，让浏览器可以运行；
</pre>

### 11、算法

#### 1、数据结构

<pre>
计算机存储或者组织数据的方式
</pre>

#### 2、空间复杂度

<pre>
1、什么时空间复杂度
    空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度，它也是程序执行时间的一部分。

2、表示法
    O(1)表示常数阶，O(logN)表示对数阶，O(n)表示线性阶，O(n^2)表示平方阶，O(2^n)表示指数阶

3、如何计算
    1、只关注循环次数最多的循环，其他循环可以忽略不计；
    2、用大O表示法表示循环
</pre>

#### 3、时间复杂度

<pre>
1、什么是时间复杂度
    时间复杂度是对一个算法执行时间的长短度量，它也是程序执行时间的一个量度。

2、表示法
    O(1)表示常数阶，O(logN)表示对数阶，O(n)表示线性阶，O(n^2)表示平方阶，O(2^n)表示指数阶

3、如何计算
    1、只关注循环次数最多的循环，其他循环可以忽略不计；
    2、用大O表示法表示循环
</pre>

```javascript
// 1、时间复杂度 O(1)
let a = 1

function fn(n) {
    return n++;
}

fn(a)
// 2、时间复杂度 O(n)
for (let i = 0; i < n; i++) {
    console.log(i)
}
// 3、时间复杂度 O(n^2)
for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
        console.log(i, j)
    }
}

// 4、时间复杂度 O(2^n)
function fn(n) {
    if (n == 1) {
        return 1
    } else {
        return 2 * fn(n - 1)
    }
}

fn(n)

// 5、空间复杂度 O(logn)
let i = 1;
const n = 6;
while (i < n) {
    i = i * 2;
}

```

#### 4、栈的介绍

<pre>
栈是一种遵从后进先出(LIFO)原则的有序集合。新添加的或待删除的元素都保存在栈的顶端。

1、栈的声明
    let stack = [];

2、栈的常用方法
    push()   添加一个或多个元素到栈顶 [1,2,3] ==> [1,2,3,4]
    pop()    移除栈顶的元素，同时返回被移除的元素 [1,2,3] ==>4
    peek()   返回栈顶的元素，不对栈做任何修改(该方法不会移除栈顶的元素，仅仅返回它) [1,2,3,4] ==> 4
    empty()  如果栈里没有任何元素就返回true，否则返回false [] ==>true  [1] ==>false

3、栈的应用场景
    函数调用栈
    浏览器的前进后退
</pre>

```javascript
// 力扣题  有效的括号 时间复杂度O(n) 空间复杂度O(n)
// 输入 '(){}' 返回true 输入'(]{}' 返回false
function fn(str) {
    const stack = [];
    for (let i = 0; i < str.length; i++) {
        const start = str[i];
        if (str[i] === '(' || str[i] === '{' || str[i] === '[') {
            stack.push(str[i]);
        } else {
            const end = stack[stack.length - 1];
            if (start === ')' && end === '(' ||
                start === ']' && end === '[' ||
                start === '}' && end === '{') {
                stack.pop();
            } else {
                return false;
            }
        }
    }
    return stack.length === 0;
}

console.log(fn('(){}')) // true
console.log(fn('(]{}')) // false
```

```javascript
// 力扣题  删除字符串中所有相邻重复项。

function fn(str) {
    const stack = [];
    for (s of str) {
        let prev = stack.pop();
        if (prev !== s) {
            stack.push(prev);
            stack.push(s);
        }
    }
    return stack.join('');
}

console.log(fn('abbaca')) // ca
```

```javascript
// 力扣题  简化路径

function fn(path) {
    const stack = [];
    let str = '';
    let arr = path.split('/');
    arr.forEach(item => {
        if (item && item === '..') {
            stack.pop();
        } else if (item && item !== '.') {
            stack.push(item);
        }
    })
    return '/' + stack.join('/');
}

console.log(fn('/home/')) // /home
console.log(fn('/../')) // /
console.log(fn('/home//foo/')) // /home/foo
console.log(fn('/a/./b/../../c/')) // /c
```

```javascript
// 力扣题  移掉K位数字

function fn(num, k) {
    if (num.length <= k) {
        return '0';
    }
    let stack = [];
    for (let i = 0; i < num.length; i++) {
        while (k && stack.length && stack[stack.length - 1] > num[i]) {
            stack.pop();
            k--;
        }
        stack.push(num[i]);
    }
    stack.splice(0, k);
    let res = stack.join('');
    return res.length ? res : '0';
}

console.log(fn('1432219', 3)) // 1219
```

#### 5、队列的介绍

队列是遵循FIFO（先进先出）原则的一组有序的项。队列在尾部添加新元素，并从顶部移除元素。

### 12、websocket

#### 1、websocket是什么

<pre>
    WebSocket是一种在单个TCP连接上进行全双工通讯的协议。
    WebSocket使得客户端和服务器可以进行双向通信。
    在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。
</pre>

#### 2、websocket与http的区别

<pre>
    WebSocket是一个持久化的协议，相对于HTTP这种非持久的协议来说。
    WebSocket是双向通信协议，在建立连接之后，WebSocket的server与client都能主动向对方发送或接收数据。
    HTTP是单向的通信协议，也就是请求-响应模式，请求完成之后，连接就关闭了，要进行下一次通信，必须重新建立连接。
</pre>

#### 3、websocket与http2.0的区别

<pre>
    WebSocket和HTTP2.0有着本质的不同，HTTP2.0是一个应用层协议，WebSocket是一个独立的协议。
    WebSocket是一种双向通信协议，在建立连接之后，WebSocket的server与client都能主动向对方发送或接收数据。
    HTTP2.0是一个应用层协议，HTTP2.0的request和response都遵循HTTP协议的格式。
    HTTP2.0是双向通信协议，通信过程中可以同时发送多个请求或响应，而且这些请求或响应都是独立成行的，不必等待其中一个请求或响应完成后再发送下一个请求或响应。
    HTTP2.0采用二进制格式传输数据，比HTTP1.x的文本格式数据更高效；
    HTTP2.0支持服务器推送，即服务端可以主动向客户端推送数据。
    HTTP2.0实现了一些机制让客户端与服务器之间可以进行有效的交互。
</pre>

#### 4、websocket心跳机制

<pre>
        
</pre>

```javascript
    // 客户端的连接 ws服务器
var ws = new WebSocket('wss://echo.websocket.org');
// open 事件
ws.onopen = function (evt) {
    console.log("Connection open ...");
    ws.send("Hello WebSocket!");
};
// message 事件
ws.onmessage = function (evt) {
    console.log("Received Message: " + evt.data);
    ws.close();
};
// close 事件
ws.onclose = function (evt) {
    console.log("Connection closed.");
};
// 心跳机制
setInterval(function () {
    ws.send("ping");
}, 5000);
// 断线重连 重连时间要大于心跳时间
ws.onclose = function () {
    console.log("连接断开，重连中...");
    // 重连
    ws = new WebSocket('wss://echo.websocket.org');
};
ws.onopen = function () {
    console.log("重连成功");
};
```

```javascript
// 封装成类使用
class Socket {
    wsUrl;

    constructor(wsUrl: any) {
        this.wsUrl = wsUrl;
    }

    modeCode = {
        // webSocket 消息类型
        MSG: "message",
        // 心跳类型
        HEART_BEAT: "heart_beat",
    }
    ws: any = null;
    webSocketState: boolean = false;
    heartBeat = {
        // 心跳连接的时间设置
        time: 5 * 1000, // 心跳时间间隔
        timeOut: 3 * 1000, // 心跳超时间隔
        reconnect: 10 * 1000, // 重连时间间隔
    }
    reconnectTimer: any = null; // 断开重连时间器
    /**
     * 连接 ws
     * */
    connectWebSocket() {
        this.ws = new WebSocket(this.wsUrl);
        this.init();
    }

    /**
     * 心跳初始函数
     */

    startHeartBeat(time: number | string) {
        setTimeout(() => {
            this.ws.send(JSON.stringify({
                ModeCode: this.modeCode.HEART_BEAT,
                msg: new Date(),
            }))
            this.waitingServer()
        }, time)
    }

    /**
     * 延迟等待服务端响应，通过webSocketState判断是否连接成功
     * */
    waitingServer() {
        this.webSocketState = false;
        setTimeout(() => {
                if (this.webSocketState) {
                    this.startHeartBeat(this.heartBeat.time)
                    return;
                }
                console.log("心跳无响应，已断开...");
                try {
                    this.ws.close();
                } catch (e) {
                    console.log("关闭连接失败...");
                }
                this.reconnectWebSocket();
            },
            this.heartBeat.timeOut)
    }

    /**
     * 重连操作
     */
    reconnectWebSocket() {
        this.reconnectTimer = setTimeout(() => {
            console.log("尝试重新连接...");
            this.reconnectWs();
        }, this.heartBeat.reconnect)
    }

    /**
     * 初始化
     * */
    init() {
        this.ws.addEventListener('open', () => {
            // socket状态设置为连接， 作为后面的断线重连的拦截器
            this.webSocketState = true;
            // 是否启动心跳级制
            this.heartBeat && this.heartBeat.time ?
                this.startHeartBeat(this.heartBeat.time) : null;
            console.log("连接成功...");
        })
        this.ws.addEventListener('message', (e) => {
            console.log("收到消息：", e.data);
            const data = JSON.parse(e.data);
            switch (data.ModeCode) {
                case this.ModeCode.heartBeat:
                    console.log("收到心跳..." + data.msg);
                    break;
                case this.ModeCode.MSG:
                    console.log("收到消息..." + data.msg);
                    break;
            }
        })
        this.ws.addEventListener('close', (e) => {
            this.webSocketState = false;
            console.log("连接已关闭...", e);
        })
        this.ws.addEventListener('error', () => {
            this.webSocketState = false;
            console.log("连接出错...", e);
            this.reconnectWebSocket(); //重连
        })
    }

    reconnectWs() {
        if (!this.ws) {
            // 第一次执行，初始化
            this.connectWebSocket();
        }
        if (this.ws && this.reconnectTimer) {
            // 防止多个webSocket同时执行
            clearTimeout(this.reconnectTimer);
            this.ws.reconnectTimer = null;
            this.connectWebSocket()
        }
    }

    /**
     *  发送消息
     */
    sendMessage(data: any) {
        this.ws.send(JSON.stringify(data));
    }

    /**
     * 在其他需要socket的地方主动关闭socket
     */
    closeWebSocket(e: any) {
        console.log("主动关闭socket...", e);
        this.ws.close();
        clearTimeout(this.reconnectTimer);
        this.webSocketState = false;
    }
}

export default Socket;
```

```javascript
/**
 * 使用
 * @type {Socket}
 */
import Socket from './socket';

const socket = new Socket("url");
socket.init();
socket.sendMessage("Hello WebSocket!");
```

#### 5、webSocket如何兼容低浏览器版本？

- 1.使用WebSocket的替代方案：在低版本浏览器中，可以使用一些基于HTTP的长轮询或流技术来实现类似于WebSocket的功能。
  常见的替代方案包括Comet、SSE（Server-Sent Events）和Flash Socket等。根据浏览器的支持情况选择相应的技术。

- 2.使用Polyfill库：可以使用一些Polyfill库来模拟WebSocket的功能。这些库会自动检测浏览器是否支持WebSocket，
  如果不支持，则会使用替代方案来提供类似的功能。常见的Polyfill库有Socket.IO和SockJS等。

- 3.使用Flash插件：Flash插件在低版本浏览器中广泛支持并且提供了类似WebSocket的功能。可以使用一些库或框架（如web-socket-js）
  来通过Flash插件实现WebSocket的功能。

```javascript
if ('WebSocket' in window) {
    // 支持 WebSocket
} else {
    // 该浏览器不支持 WebSocket
    // 采用轮询方式检测消息
}
```

### 13、浏览器

#### 1、localStrage、sessionStrage、cookie的区别

- 1.相同点：

<pre>
    在客户端存放数据
</pre>

- 2.不同点：

<pre>
    localStrage、sessionStrage、cookie都是浏览器端存储数据的方式，区别如下：
    1、存储位置不同：
        localStrage、sessionStrage存储在浏览器端，而cookie存储在服务端。
    2、存储大小不同：
        localStrage、sessionStrage、cookie存储大小不同，cookie一般不能超过4k，而localStrage、sessionStrage可以存储不超过5M的数据。
    3、有效时间不同：
        sessionStrage: 仅在当前浏览器窗口关闭前有效。[窗口或浏览器关闭就没了]
        localStrage: 始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据。
        cookie: 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。[必须要在服务环境下才能设置，如：本地启的vue项目或者线上服务]
    4、与服务器端通信不同：
        localStrage、sessionStrage在设置的有效期内一直有效，而cookie在设置的有效期内一直有效，即使窗口或浏览器关闭。
</pre>

```javascript
 // 存储
localStorage.setItem("key", "value");
sessionStorage.setItem("key", "value");
document.cookie = "key=value";
// 读取
var value = localStorage.getItem("key");
var value = sessionStorage.getItem("key");
var value = document.cookie.replace(/(?:(?:^|.*;\s*)key\s*\=\s*([^;]*).*$)|^.*$/, "$1");
// 删除
localStorage.removeItem("key");
sessionStorage.removeItem("key");
document.cookie = "key=;expires=Thu, 01 Jan 1970 00:00GMT;" // expires设置过期时间
// 清除所有
localStorage.clear();
sessionStorage.clear();
document.cookie = "key=;expires=Thu, 01 Jan 1970 00:00GMT;";
```

#### 2、浏览器缓存

<pre>

    浏览器缓存分为强缓存和协商缓存。

    1、强缓存：
        浏览器直接从缓存中读取资源，不会向服务器发送请求。
        强缓存可以通过设置两种HTTP Header实现：Expires和Cache-Control。
        Expires是HTTP/1.0的产物，表示缓存到期时间，但是它受限于本地时间，如果修改了本地时间，可能会造成缓存失效。
        Cache-Control是HTTP/1.1的产物，在Expires出现后，Cache-Control成为主要控制缓存失效的header。
        Cache-Control的几个常用字段：
            public：所有内容都将被缓存（客户端和代理服务器都可缓存）
            private：所有内容只有客户端可以缓存，Cache-Control的默认取值
            no-cache：客户端缓存内容，但是是否使用缓存需要经过协商缓存来验证决定
            no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存
            max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效

    2、协商缓存：
        如果缓存过期了，那么浏览器会发送请求到服务器，服务器根据请求中的相关标识来判断是否命中缓存。
        如果命中缓存，则返回304和Not Modified状态码，浏览器根据此状态码来从缓存中读取资源。
        如果未命中缓存，则返回200和请求的结果资源，并且会更新缓存中的资源。
        协商缓存可以通过设置两种HTTP Header实现：Last-Modified和ETag。
        Last-Modified：标识请求资源在服务器上的最新修改时间。
        ETag：标识请求资源的唯一标识符。

</pre>

#### 3、浏览器输入URL到页面展示的详细过程

<pre>
    1、DNS解析：
        浏览器缓存-&gt;系统缓存-&gt;路由器缓存-&gt;ISP DNS缓存-&gt;递归搜索

    2、TCP连接：
        三次握手：
            客户端发送SYN包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；
            服务器收到SYN包，必须确认客户的SYN(ack=j+1)，同时自己也发送一个SYN包(syn=k)，即SYN+ACK包，此时服务器进入SYN_RECV状态；
            客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

    3、发送HTTP请求：
        客户端向服务器发送一个HTTP请求，请求被发送到服务器的默认端口(80)

    4、服务器处理请求：
        服务器端请求处理完毕后，向客户端发送HTTP响应，客户端接收HTTP响应并渲染页面

    5、关闭TCP连接：
        客户端获取到HTML文档后，会关闭TCP连接，或者等待一段时间后发起TCP连接

</pre>

#### 4、HTTP1.0和HTTP1.1的区别

<pre>

    1、长连接：
        HTTP1.0默认是短连接，也就是说每次请求都要重新建立一次连接，用完就断开。
        HTTP1.1默认是长连接，也就是说，默认会保持连接。

    2、缓存处理：
        HTTP1.0没有指定缓存的处理方式，依赖浏览器或者用户自己进行处理。
        HTTP1.1新增了缓存处理，如缓存请求头字段Cache-Control、Last-Modified、Etag等。

    3、带宽优化及网络连接的使用：
        HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，
        并且不支持断点续传功能，HTTP1.1则在请求头引入了Range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），
        这样就方便了开发者自由的选择以便充分利用带宽和连接。

    4、错误通知的管理：
        在HTTP1.1中，新增了24个错误状态响应码，
        如409（Conflict）表示请求的资源与资源的当前状态发生冲突；
        410（Gone）表示服务器上的某个资源被永久性的删除。

    5、Host头处理：
        在HTTP1.0中，每个请求的header中都有Host信息，例如：Host:www.google.com。
        而在HTTP1.1中，Host信息是必须的，如果客户端没有给出这个信息，服务器将不会处理该请求。

</pre>

#### 5、HTTP2.0的新特性

<pre>

    1、二进制分帧：
        HTTP2.0将报文分成帧（frame）进行传输，和HTTP1.x一样，HTTP2.0也需要客户端和服务器同时支持，才能实现二进制分帧，
        实现二进制分帧的关键是帧头，它由帧类型（type）、帧长度（length）、帧标志（flags）三个字段组成，其中帧长度指的是整个帧的长度，
        而不包括帧头本身的长度。

    2、多路复用：
        多路复用是指在单个连接上可以同时传送多个请求或响应，即可以同时发送多个请求或响应，它的最大优点就是减少了建立和关闭连接的消耗和延迟，
        节省了带宽资源。

    3、头部压缩：
        HTTP2.0实现了头部的压缩功能，即HTTP2.0在客户端和服务器端使用“HPACK”算法来压缩头部，使数据体积变小，提高传输速度。

    4、服务器推送：
        HTTP2.0服务器能够更快的将资源发送给客户端，这被称为服务器推送。

</pre>

#### 6、HTTP请求报文和响应报文的具体格式

<pre>

    请求报文格式：
        请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。

    响应报文格式：
        状态行、响应头部、空行和响应数据四个部分组成。

</pre>

#### 7、HTTP常见状态码

<pre>

    200 OK：客户端请求成功。
    201 Created：已创建，成功请求并创建了新的资源。
    202 Accepted：已接受，已经接受请求，但未处理完成。
    203 Non-Authoritative Information（非授权信息）：请求成功。但返回的meta信息不在原始的服务器，而是一个副本。
    204 No Content：请求成功，但返回的meta信息为空（用null表示）。
    205 Reset Content（重置内容）：服务器处理成功，用户终端（例如：浏览器）应重置文档视图。
    206 Partial Content（部分内容）：服务器成功处理了部分GET请求。

    300 Multiple Choices（多种选择）：请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择。
    301 Moved Permanently（永久移动）：请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。
        今后任何新的请求都应使用新的URI代替。
    302 Found（找到）：临时性重定向。
    303 See Other（查看其他）：临时性重定向，且总是使用GET方法请求新的URI。
    304 Not Modified（未修改）：自从上次请求后，请求的资源未修改过，服务器返回此状态码时，不会包含任何响应的主体部分。
    305 Use Proxy（使用代理）：请求的资源必须通过代理访问。
    306 (Unused)：已经被废弃的代码，将来有可能使用，现在尚未使用。
    307 Temporary Redirect（临时重定向）：临时重定向，与302 Found类似。使用GET方法请求新的URI，但是POST方法提交的请求报文中的地址不会改变。

    400 Bad Request（错误请求）：请求报文存在语法错误。
    401 Unauthorized（未授权）：请求需要有通过HTTP认证的认证信息。
    402 Payment Required（支付要求）：该状态码是为了将来可能的需求而预留的。
    403 Forbidden（禁止）：服务器收到请求，但是拒绝提供服务。
    404 Not Found（未找到）：请求的资源不存在，或不可用。
    405 Method Not Allowed（方法禁用）：客户端请求中的方法被禁止。
    406 Not Acceptable（不可接受）：服务器无法根据客户端请求的内容特性完成请求。
    407 Proxy Authentication Required（代理服务器认证要求）：请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权。
    408 Request Timeout（请求超时）：服务器完成请求处理，但请求超时。
    409 Conflict（冲突）：通常和PUT请求有关。由于请求和资源的当前状态相冲突，因此请求不能成功。
    410 Gone（已删除）：被请求的资源已从这个地址转移，不再可用。
    411 Length Required（需要有效长度）：服务器无法处理客户端发送的不带Content-Length的请求信息。
    412 Precondition Failed（先决条件失败）：请求信息的先决条件错误。
    413 Request Entity Too Large（请求实体过大）：由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，
        服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息。
    414 Request-URI Too Long（请求URI过长）：请求的URI过长（URI通常为网址），服务器无法处理。
    415 Unsupported Media Type（不支持的媒体类型）：服务器无法处理请求附带的媒体格式。
    416 Requested Range Not Satisfiable（请求范围无法满足）：客户端请求的范围无效。
    417 Expectation Failed（期望失败）：服务器无法满足Expect的请求头信息。

    500 Internal Server Error（服务器内部错误）：服务器遇到错误，无法完成请求。
    501 Not Implemented（尚未实施）：服务器不支持请求的功能，无法完成请求。
    502 Bad Gateway（错误网关）：作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应。
    503 Service Unavailable（服务不可用）：由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度由服务器自己决定。
    504 Gateway Timeout（网关超时）：充当网关或代理的服务器，未及时从远端服务器获取请求。
    505 HTTP Version Not Supported（不支持的HTTP版本）：服务器不支持请求的HTTP协议的版本，无法完成处理。
</pre>

#### 8、浏览器渲染原理

<pre>
1. 解析HTML生成DOM树
2. 解析CSS生成CSSOM树
3. 将DOM和CSSOM整合形成渲染树
4. 根据渲染树进行布局
5. 调用GPU进行绘制
</pre>

#### 9、如何实现浏览器内多个标签页之间的通信? (阿里)

<pre>
1. WebSocket、SharedWorker
2. localStorage、sessionStorage
3. postMessage,
4. BroadcastChannel
5. serviceworker
6. storage事件 -- IndexedDB
</pre>

IndexedDB 是什么？
<pre>
IndexedDB 是一种低级、原始的存储机制，用于客户端存储大量结构化数据。
这些数据具有键值对的形式存储，并且具有类似文件系统的目录结构以及事务机制。
</pre>

### 14、页面兼容

#### 1、如何关闭IOS键盘首字母大写？

```html
<!-- 设置属性 autocapitalize off-->
<input type="text" autocapitalize="off"/>
```

#### 2、怎么让Chrome支持小于12px 的文字？

- chrome浏览器默认字体大小是 16px;(每种浏览器的默认字体大小不同)
- 设置body的font-size为10px，通过css3缩放方法实现。

```scss
.font {
  display: inline-block;
  -webkit-transform: scale(0.8);
}
```

#### 3、怎么去掉ios系统中元素被触摸时产生的半透明灰色遮罩

```scss
a, button, input, textarea {
  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
}
```

#### 4、能改变webkit表单输入框placeholder的颜色值吗

```scss
input::-webkit-input-placeholder {
  color: #AAAAAA;
}
```

#### 5、禁止触发系统菜单和长按选中

```scss
html, body {
  // 禁止触发系统菜单
  -webkit-touch-callout: none;
  // 禁用 长按选中
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}
```

#### 6、自适应（适配）

- 1.自适应解决方案： 淘宝无限适配[移动端]（lib-flexible） + 布局单位使用rem
- 2.配置如下：

```json lines
// 项目中引入插件
npm install lib-flexible --save-dev  // 监听页面变化设置根节点font-size 大小
// npm install px2rem-loader --save-dev // 将px 转成 rem
```

```js
// main.js 入口文件引入依赖
// 
import 'lib-flexible/flexible'
// import 'px2rem-loader/src/postcss-px2rem'
```

```js
// 配置px2rem-loader
// 在build文件中找到util.js，将px2rem-loader添加到cssLoaders中，如：
const cssLoader = {
    loader: 'css-loader',
    options: {
        minimize: process.env.NODE_ENV === 'production',
        sourceMap: options.sourceMap
    }
}
const px2remLoader = {
    loader: 'px2rem-loader',
    options: {
        remUnit: 75
    }
}
```

```js
// 在generateLoaders方法中添加px2remLoader
function generateLoaders(loader, loaderOptions) {
    const loaders = options.usePostCSS ? [cssLoader, postcssLoader, px2remLoader] : [cssLoader, px2remLoader]
    if (loader) {
        loaders.push({
            loader: loader + '-loader',
            options: Object.assign({}, loaderOptions, {sourceMap: options.sourceMap})
        })
    }

    if (options.extract) {
        return ExtractTextPlugin.extract({use: loaders, fallback: 'vue-style-loader'})
    } else {
        return ['vue-style-loader'].concat(loaders)
    }
}

```

```js
// vue.config.js
module.exports = {
    css: {
        loaderOptions: {
            css: {},
            postcss: {
                plugins: [
                    require('postcss-px2rem')({
                        // 以设计稿1920为例， 1920 / 10 = 192
                        remUnit: 192
                    }),
                ]
            }
        }
    },
};

```

```js
// vite.config.js
import {fileURLToPath, URL} from 'node:url'
import {defineConfig} from 'vite'
import vue from '@vitejs/plugin-vue'
import px2rem from "postcss-px2rem"  // 分辨率适配
export default defineConfig({
    plugins: [vue()],
    define: {
        'process.env': {},
    },
    // css 分辨率适配
    css: {
        postcss: {
            plugins: [
                px2rem({
                    remUnit: 192
                })
            ]
        }
    }
})

```

```html
<!-- 移动端适配 index.html -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">

<style lang="scss">
    * {
        margin: 0;
        padding: 0;
    }

    html {
        font-size: 16px;
    / / 设置html font-size
    }

    div {
        font-size: 1rem;
    / / 使用 1 rem = = 16 px
    }
</style>
```

- 3.按照px来编写都会转化成rem的形式，但是有些地方我们不想转换，可以用下面两种方法。

<pre>
    1. 在px后面添加/*no*/，不会转化px，会原样输出。 — 一般border需用这个
    2. 在px后面添加/*px*/,会根据dpr的不同，生成三套代码。---- 一般字体需用这个
</pre>

- 4.使用过程中，发现某些import外联样式不会被转化，注意避开这些坑。

```js
<style src='../assets/style.css'>
    /* px2rem能正常转换 */
</style>

<style>
    /* px2rem不能正常转换 */
    @import '../assets/style.css';
</style>

<style>
    /* px2rem不能正常转换 */
    @import url('../assets/style.css');

</style>
```

- 5.无需自己增加html页面name=viewport的meta元标签。flexible会自动添加。

#### 7、响应式

- 响应式是什么

<pre>
    响应式就是根据不同的屏幕尺寸和设备类型，自动调整布局、图片、甚至切换到移动端版本。
</pre>

- 响应式怎么实现

<pre>
    1. 媒体查询
    2. 百分比
    3. rem
</pre>

- 媒体查询

```scss
// @media 媒体类型 and (媒体特性){
// only 可以排除不支持媒体查询的浏览器
// screen 设备类型
// max-width 最大宽度
// min-width 最小宽度
// and 同时满足多个条件
@media only screen and (max-width: 320px) {
}

@media screen and (min-width: 321px) and (max-width: 480px) {
}

@media screen and (max-width: 768px) {
}

@media screen and (min-width: 768px) and (max-width: 992px) {
}

@media screen and (min-width: 992px) and (max-width: 1200px) {
}

@media screen and (min-width: 1200px) {
}
```

- 响应式图片（性能优化）

```html

<picture>
    <!--    大于1000px 显示-->
    <source srcset="1.png" media="(min-width:1000px)"/>
    <!--    大于700px 显示-->
    <source srcset="2.png" media="(min-width:700px)"/>
    <!--    小于 700px 显示-->
    <img src="3.png" alt="">
</picture>
```

#### 8、布局方案

- 1.什么情况下用响应式

 <pre>
    数据不是特别多，用户量不是特别大，纯展示类的项目适合响应式布局
    例如：公司官网、专题页面
    特别是追求性能的项目，不太适合响应式，因为如果添加了很多的响应式就会造成加载速度变慢。（淘宝、京东）
 </pre>

- 2.pc + 移动端应该做什么样的布局方案

 <pre>
    访问量还可以或者比较大，类似于淘宝：pc是一套（会加一点响应式） 、移动端是一套（会使用自适应的布局方式）
</pre>

- 3.pc 设计图 1920，自己笔记本是1280，怎么办？

 <pre>
    1.把ui图进行等比例缩放，缩放成和电脑一样的尺寸；
    2.换1980的电脑；
</pre>

- 4.移动端设计图 750

<pre>
    因为750设计图/2就是375，正好是iphone6的尺寸，我们要把iphone6的尺寸作为基准点。
</pre>

### 9、协作与沟通
```text
1. 明确项目目标和角色
2. 使用协作工具（项目聊天工具，项目管理工具，版本控制系统等）
3. 定期的团队会议（每日站会，周会，月会）
4. 制定统一的代码规范；
5. 注重文档（项目文档，代码注释，技术文档）
6. 保持开放的沟通
7. 有效的代码审查 
```

### 10、开源系统推荐
```text
1. 企业门户网站
    1.1 vuepress
    1.2 vitepress
    1.3 vue argon dashboard

2. 后台管理系统
    2.1 ant design vue pro
    2.2 vue element admin
    2.3 vuetify admin dashboard
    2.4 quasar framework
  
```

### 11、项目遇到的问题及怎么解决
```text
1. 项目遇到的问题

2.解决方案
 2.1 自行查找资料寻求解决方案；
 2.2 寻求团队内其他成员的帮助；
```

### 12.前端如何解决页面请求接大规模并发问题
```text
一、前端如何解决页面请求接大规模并发问题
1.1： 前端处理大规模并发请求的问题主要是通过优化用户体验和减轻服务器压力来实现的。
1.2：大部分并发控制是在后端进行的，前端可以采取一些策略来辅助处理这些问题
二、常见的前端优化方法
1：按需加载（Lazy Loading）
1.1：使用·懒加载·技术可以确保只有当用户滚动到特定内容时才加载该部分内容，从而减少初始页面加载时的数据量。
2：分页与无限滚动
2.1：分页可以限制每次请求的数据量，减轻服务器负担。
2.2：无限滚动可以在用户滚动到页面底部时自动加载更多数据，提供更好的用户体验。
3：缓存机制
3.1：利用浏览器的缓存机制来存储常用资源（如图片、CSS 和 JavaScript 文件），避免重复请求相同的资源。
3.2 ：使用 Service Worker 来缓存静态资源或重要数据，提供离线访问支持。
4：减少HTTP请求
4.1：合并CSS和JavaScript文件。
4.2：使用图片精灵（Sprites）或SVG sprites 技术来减少图片请求。
5：使用CDN（内容分发网络）
5.1 CDN 可以将静态资源分布在全球多个节点上，用户可以从最近的节点获取资源，从而提高加载速度和可用性。
6：前端限流
6.1：在客户端限制某些操作的频率，比如搜索、评论等，可以使用防抖或节流函数来控制事件触发的频率。
7：异步加载
7.1：使用 AJAX 或 Fetch API 异步加载数据，避免阻塞整个页面的渲染。
8：预加载（Preloading）
8.1：预先加载关键资源，如重要的图片或视频，以便用户在真正需要它们之前就已经准备好。
9：优化资源大小
9.1：对图片进行压缩。
9.2：使用更高效的编码格式，如 WebP 图片格式。
9.3：对文本资源进行 GZIP 压缩。
10：代码分割 使用现代前端框架如 React 或 Vue.js 的代码分割功能来按需加载组件。
服务器端渲染（SSR）或静态站点生成（SSG）
对于SEO友好的网站或者大量数据展示的页面，可以考虑使用 SSR 或 SSG 技术来提前生成 HTML 页面，减少服务器动态处理的时间。
二、代码实现
场景：需要显示大量的列表。为了减少页面首次加载时的数据量
1： 懒加载
1.1：实现思路
1.1.1：当页面加载时，只加载可视区域内的列表数据。
1.1.2：当用户滚动页面时，加载新进入可视区域的列表数据。
1.2：技术实现
1.2.1：监听 scroll 事件
1.2.2： 计算元素是否进入可视区域
1.2.3：请求并加载新数据。
```
```js
// 假设你有一个列表，其中每个列表项都有一个 data-src 属性用于存放图片的 URL
const images = document.querySelectorAll('.news-item img');
function loadImage(img) {
  const src = img.getAttribute('data-src');
  if (src) {
    img.src = src;
    img.removeAttribute('data-src'); // 清除属性以避免重复加载
  }
}

function checkImages() {
  images.forEach((img) => {
    if (isInViewport(img)) {
      loadImage(img);
    }
  });
}

function isInViewport(element) {
  const rect = element.getBoundingClientRect();
  return (
    rect.top >= 0 &&
    rect.left >= 0 &&
    rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
    rect.right <= (window.innerWidth || document.documentElement.clientWidth)
  );
}

// 初始化检查
checkImages();

// 添加滚动监听器
window.addEventListener('scroll', checkImages);

```
```text
2：分页与无限滚动
2.1：实现思路
2.1.1：分页：用户点击下一页按钮时，发送请求加载新的文章列表。
2.1.2：无限滚动：当用户滚动到接近页面底部时，自动加载新的文章列表。
2.2：技术实现
2.2.1：使用 IntersectionObserver API 来检测页面底部是否接近可视区域。
2.2.2：发送 AJAX 请求加载新数据。
```
```js
 let currentPage = 1;
const observer = new IntersectionObserver((entries) => {
  entries.forEach((entry) => {
    if (entry.isIntersecting) {
      loadMoreData();
    }
  });
});

const loadMoreData = () => {
  currentPage++;
  fetch(`/articles?page=${currentPage}`)
    .then((response) => response.json())
    .then((data) => {
      // 处理数据并更新 DOM
      appendArticles(data);
    })
    .catch((error) => console.error(error));
};

const appendArticles = (articles) => {
  articles.forEach((article) => {
    const articleElement = createArticleElement(article); // 假设这是一个创建文章元素的函数
    document.querySelector('#articles').appendChild(articleElement);
  });
};

// 监听页面底部元素
observer.observe(document.querySelector('#load-more'));

```
### 13.渲染大数据
- 1.createDocumentFragment
- - 1.createDocumentFragment()方法，是用来创建一个虚拟的节点对象，或者说，是用来创建文档碎片节点，它可以包含各种类型的节点，在创建之初是空的
- - 2.DocumentFragment 节点不属于文档树，继承的parentNode属性总是null。它有一个很实用的特点，当请求把一个DocumentFragment节点插入文档树时，
     插入的不是DocumentFragment自身，而是它的所有子孙节点，即插入的是括号里的节点。这个特性使得DocumentFragment成了占位符，暂时存放那些一次
     插入文档的节点。他还有利于实现文档的剪切、复制和粘贴操作。另外，当需要添加多个dom元素时，如果先将这些元素添加到DocumentFragment中，
     再统一将DocumentFragment添加到页面，会减少页面重绘和回流，提高性能。
- 2.requestAnimationFrame
- - 1.requestAnimationFrame 比起 setTimeout、setInterval 的优势主要有两点：
- - - 1.requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，
       并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率是60Hz，也就是每秒60次。
       而 setTimeout、setInterval 的延迟时间参数则是按毫秒计的。如果刷新频率是60Hz，那么 setTimeout 或 
       setInterval 的延迟时间最小值是 1/60*1000= 16.7ms ，如果设置低于这个值，效果和 16.7ms 是一样的。
- - - 2.在隐藏或不可见的元素中，requestAnimationFrame 将不会执行回调函数，这就意味着不会进行浏览器的重绘和回流，当然性能也就有了很大的提升。
- 3.示例代码：
- ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
       <title>Title</title>
  </head>
  <body>
  <ul></ul>
  <script>
     // 大数据
     // 每次插入条数
     let num = 20
     // 插入次数
     let times =Math.ceil(lar / num)
     // 当前渲染次数
     let current = 0
     // 获取ul元素
     let lar = 1000000
     let ul = document.querySelector('ul');
      // 添加数据方法
     function addData(){
         // 创建虚拟节点
         let fragment = document.createDocumentFragment();
         for(let i=0;i<num;i++){
             let li = document.createElement('li');
             li.innerText= '第'+(i+1)+'条数据';
             fragment.appendChild(li);
          }
         ul.appendChild(fragment);
         current++;
         loop()
      }
      // 循环插入数据
      function loop(){
         if(current < times){
             window.requestAnimationFrame(addData)
         }
      }
      // 执行循环
      loop()
  
  </script>
  </body>
  </html>
  ```
  
- ### 14.插件化的底座实现
- ```js
   // 定义基座
   class Plugin {
      use(plugin) {
        this.plugins.push(plugin)
     }
      run(){
        this.plugins.forEach(plugin => {
          plugin(this) 
         })
     }
  }
  // 定义插件
  const plugin1 = (app) => {
    return{
      name: 'plugin1',
      mounted() {
        console.log('plugin1 mounted')
     }
  }
  }
  const plugin2 = (app) => {
    return{
      name: 'plugin2',
      mounted() {
        console.log('plugin2 mounted')
     }
  }
  }
  // 实例化基座
  const app = new Plugin()
  // 使用插件
  app.use(plugin1)
  app.use(plugin2)
  // 执行插件
  app.run()
  ```
  
- ### 15.前端安全策略
- - 1.数据传输加密（https）
- - 2.数据存储加密（cookie、localStorage、sessionStorage 涉及敏感信息要加密）
- - 3.数据传输完整性校验（token： jwt令牌）
- - 4.输入验证和过滤（对用户输入的验证和过滤，避免sql注入、xss攻击等）
- - 5.访问控制和权限管理（根据用户角色，分配不同的权限，避免未授权用户进行访问和操作）
- - 6.安全编码（遵循安全编码规范和最佳实践，例如避免使用evolve,直接操作DOM等，缓存敏感信息的时候使用加密方法）
- - 7.扫描漏洞和安全测试（定期进行安全扫描，发现潜在问题和bug，及时修复）
  
