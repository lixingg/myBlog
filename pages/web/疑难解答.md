### 1、css
#### 1、说一下css盒模型

 <pre>
 在html页面中的所有元素都可以看成是一个盒模型,盒模型分为两种：IE盒模型和标准W3C盒模型。
 标准W3C盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)。
 IE盒模型： 边界(margin)、内容(content 包含 边框(border)、填充(padding))。
</pre>  

#### 2、css选择器有哪些

 <pre>
 1.id选择器（ # myid）
 2.类选择器（.myclassname）
 3.标签选择器（div, h1, p）
 4.相邻选择器（h1 + p）
 5.子选择器（ul > li）
 6.后代选择器（li a）
 7.通配符选择器（ * ）
 8.属性选择器（a[rel = "external"]）
 9.伪类选择器（a: hover, li: nth-child）
</pre>  

#### 3、CSS优先级算法如何计算

<pre>
优先级就近原则，同权重情况下样式定义最近的生效
载入样式以最后载入的定位为准
优先级为:
!important > 行内样式 >  id > 类or属性选择器or伪类选择器 > 标签 > 通配
重要要加引号，并且要写在最前面，同时css属性不能简写。
</pre>

#### 4、CSS3新增伪类有那些

<pre>
1.p:first-of-type 选择属于其父元素的首个 p 元素。
2.p:last-of-type  选择属于其父元素的最后 p 元素。
3.p:only-of-type  选择属于其父元素唯一的 p 元素。
4.p:only-child        选择属于其父元素的唯一子元素的 p 元素。
5.p:nth-child(2)  选择属于其父元素的第二个子元素的 p 元素。
6.:enabled  :disabled 控制表单控件的禁用状态。
7.:checked        单选框或复选框被选中。
</pre>

#### 5、如何居中div

<pre>
- [x] 1.position + margin
- [x] 2.position + transform
- [x] 3.flexbox
- [x] 4.grid
</pre>

```scss
.parent-block {
  position: relative;
}

// position + margin
.center-block {
  position: absolute;
  left: 0;
  top: 0;
  right: 0;
  bottom: 0;
  margin: auto;
}

// position + transform

.center-block {
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
}

// flexbox
.parent-block {
  display: flex;
  justify-content: center;
  align-items: center;
}

// grid

.parent-block {
  display: grid;
}

.center-block {
  margin: auto;
}
```

#### 6、隐藏元素的方法
```css
.box{
    /* 设置 元素消失 不占据空间*/
    display: none;
    /* 设置透明度为0，元素不可见，占据空间*/
    opacity: 0;
    /* 让元素消失，占据空间位置*/
    visibility: hidden;
    /* 相对其他盒子*/
    position: absolute;
    /* 剪切掉这块*/
    clip-path: circle(30px);
}
```

#### 7、px与rem的区别
<pre>
    px 时像素单位，显示器上最小物理点，每个像素的大小是一样的，是一个绝对单位长度。
    rem是相对单位，
    相对于根元素html的font-size，
    根元素html的font-size默认是62.5%，
    1rem = 10px = (16px * 62.5%)，
    计算公式：
    rem = px / 根元素html的font-size
</pre>

#### 8、使用link和@import引入的区别
<pre>
    1. link是HTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。
    2. link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。
    3. link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。
    4. link支持使用Javascript控制DOM去改变样式；@import不支持。
</pre>

#### 9、title与h1的区别,b与strong的区别,i与em的区别?
<pre>
    title与h1的区别  
        1.定义
            title: 概括了网站信息，可以告诉搜索引擎或者用户关于这个网站的内容主题。
            h1: 文章主题内容，告诉蜘蛛我们的网站内容是什么。
        区别：
            1.从显示上说，title 显示在网页标题上，h1 显示在网页内容上。
            2.从seo上说，title 比 h1 添加重要（title > h1）。
        场景上：
            网站的logo都是用 h1 标签包裹的
</pre>
<pre>
    b与strong的区别
        1.定义
            b: 实体标签，表示粗体文本，没有实际意义，只是视觉上的加粗。
            strong: 逻辑标签，用来加强字符的语气，表示重要文本，有实际意义，搜索引擎会重点抓取。
        区别：
            1.b 没有语义，只是视觉上的加粗，没有实际意义，搜索引擎不会重点抓取。
            2.strong 是有语义的，表示重要文本，有实际意义，搜索引擎会重点抓取。
        场景上：
            1.b 标签一般用于表示一些小字，如：导航栏、侧边栏等。
            2.strong 标签一般用于表示一些重要文本，如：文章标题、文章内容等。
</pre>
<pre>
    i与em的区别
       1.定义
           i: 实体标签，表示斜体文本，没有实际意义，只是视觉上的倾斜。
           em: 逻辑标签，用来强调字符，表示重要文本，有实际意义，搜索引擎会重点抓取。
       区别：
          1.i 没有语义，只是视觉上的倾斜，没有实际意义，搜索引擎不会重点抓取。
          2.em 是有语义的，表示重要文本，有实际意义，搜索引擎会重点抓取。
       场景上：
          i 更多的用在字体图标，em 术语上 （医药、生物）。
</pre>  

#### 10、img 标签的 title 和 alt 有什么区别？
<pre>
    1、显示不同：
        1.title: 鼠标悬停在img上显示的文字。
        2.alt: 图片加载失败时显示的文字。
    2、SEO搜索引擎优化：
        1.title: 给图片起个名字，方便搜索引擎抓取图片信息。
        2.alt: 图片加载失败时显示的文字，方便搜索引擎抓取图片信息。
</pre> 

#### 11、png、jpg、gif 有什么区别，如何选择使用哪种图片格式？

<pre>
    1.png: 无损压缩，尺寸体积要比jpg/jpeg的大，适合做小图标，支持透明度，支持256色，支持动画。
    2.jpg: 采用压缩算法，有一点失真，比png要小，适合做中大图片，不支持透明度，支持256色，不支持动画。
    3.gif: 一般是做动图的。支持透明度，支持256色，支持动画。
    4.webp: 同时支持有损或者无损压缩，相同质量的图片，webp具有更小的体积，兼容性不是特别好。
</pre>

#### 12、line-height 和 height 有什么区别？

<pre>
    1.line-height: 行高，是行距，是基线到基线之间的距离。（每一行文字的高，如果换行则整个盒子高度会增大（行数 * 行高））
    2.height: 元素的高度，是元素边框到元素边框之间的距离。（死值，就是盒子的高度）
</pre>

#### 13、哪些属性可以继承？

<pre>
    1.文字系列属性：font-size font-family color font-weight font-style text-decoration text-align 
                  text-indent vertical-align line-height letter-spacing word-spacing text-shadow text-transform direction
    2.元素可见性：visibility
    3.表格布局属性：caption-side border-collapse empty-cells
    4.列表布局属性：list-style-type list-style-image list-style-position list-style
    5.光标属性：cursor
    6.页面样式属性：page page-break-before page-break-after page-break-inside
    7.声音样式属性：speak speak-punctuation speak-numeral speak-header speak-delay speak-rate speak-volume
</pre>

#### 14、用css 绘制三角形

<pre>
    1.border-width: 10px;
    2.border-style: solid;
    3.border-color: transparent transparent red transparent;
</pre>

#### 15、display 有哪些值，表示什么

<pre>
    1.block         把某个元素转换成块元素。
    2.none          此元素会被隐藏。
    3.inline        把某个元素转换成内联元素。
    4.inline-block  把某个元素转换成行内块元素。
    5.list-item     象块类型元素一样显示，并添加样式列表标记。
    6.table         此元素会作为块级表格来显示（类似 table），表格前后带有换行符。
    7.inherit       规定应该从父元素继承 display 属性的值。
</pre>

#### 16、对BFC规范（块级格式化上下文：block formatting context）的理解？
<pre>
    BFC就是页面上一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。

    1. 了解BFC: 块级格式化上下文。
    2. BFC原则: 如果一个元素具有BFC，那么内部元素再怎么弄，都不会影响到外部元素。
    3. 哪些元素会具有BFC: 根元素、float属性不为none、position为absolute或fixed、display为inline-block、overflow不为visible。
</pre>

#### 17、清除浮动有哪些方法

<pre>
    1. 触发BFC : 给父元素添加overflow:hidden;
    2. 结尾处加空div标签 clear:both;
    3. 使用伪类 父元素:after{ clear:both; display:block; content:""; }
</pre>

#### 18、在网页中字体使用奇数还是偶数？为什么？

<pre>
    偶数
    1、方便开发，布局、计算像素方便。
    2、偶数像素的图片，在放大后不会出现模糊。
    3、让文字在浏览器上表现的更好看。
</pre>

#### 19、有几种定位？ 分别是根据什么定位的

<pre>
    1. static 默认值，没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。
    2. relative 生成相对定位的元素，相对于其正常位置进行定位。
                如果有top, bottom, left, right ==》left top
    3. absolute 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。
                如果有top, bottom, left, right ==》top, bottom, left, right 
    4. fixed 生成固定定位的元素，相对于浏览器窗口进行定位。
    5. sticky 生成粘性定位的元素，元素先按照普通文档流定位，然后相对于该元素在流中的flow根元素进行定位。
</pre>

#### 20、双飞翼布局
```html
<div class="container">
    <div class="main">main</div>
    <div class="left">left</div>
    <div class="right">right</div>
</div>
```
```css
.container {
    width: 100%;
}
.main {
    float: left;
    width: 100%;
    margin: 0 200px;
    background: #f00;
}
.left {
    float: left;
    width: 200px;
    margin-left: -100%;
    background: #0f0;
}
.right {
    float: left;
    width: 200px;
    margin-left: -200px;
    background: #00f;
}
.clearfix::after {  
    content: "";
    display: block;
    clear: both;
}
```

#### 21、什么是css reset?

-    reset.css 是一个CSS文件，它包含了一组重置样式（reset styles），用于将浏览器默认的样式重置为一致的样式。
    在编写CSS样式时，如果需要重置浏览器默认样式，可以引用[reset.css](https://meyerweb.com/eric/tools/css/reset/)文件。
    这样可以确保所有浏览器在渲染页面时都使用一致的样式，避免由于浏览器默认样式不同而导致的样式差异。

-  为了增强跨浏览器渲染的一致性，我们推荐使用 [Normalize.css](https://necolas.github.io/normalize.css/)，这是由 Nicolas Gallagher 和 Jonathan Neal 维护的一个CSS 重置样式库。

-  [bootcss 官网](https://v3.bootcss.com/css/)

#### 22、CSS Sprites 是什么？ 有什么优缺点？（雪碧图|精灵图）

-  CSS Sprites是一种CSS图像合并技术，用于将多个小图标合并成一张大图，从而减少HTTP请求
-  优点：
    1. 减少HTTP请求数，提高页面加载速度
    2. 减少图片大小，提高页面加载效率
    3. 提高页面渲染性能，减少页面加载时间
    4. 提高页面响应速度，提高用户体验
-  缺点：
    1. 维护成本高，需要手动维护合并后的图片
    2. 图片合并后体积较大，增加页面加载时间
    3. 图片合并后，图片无法单独使用，只能作为背景图使用
-  使用：
```css
.container{
    /* 使用雪碧图添加背景图片*/
    /*background: url('./images/sprite.png') no-repeat;*/
    /* 移动雪碧图位置确定哪个雪碧图*/
    /*background-position: -100px -100px;*/
}
```
#### 23、重绘和回流
```scss
.container{
    visibility: hidden; // 产生重绘
    display: none; // 产生回流 + 重绘
  // 产生回流一定会造成重绘，但重绘不一定会造成回流。
}
```
-  重绘（Repaint）：当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color
    等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。
-  回流（Reflow）：当页面中元素的尺寸、结构、位置、显隐或触发某些属性时，浏览器会重新计算元素的几何属性，
    并重新构造渲染树，这个过程称为回流。

#### 24、opacity和rgba区别
-  opacity 取值范围 0 - 1 之间，0表示完全透明，1表示完全不透明。
-  rgba r表示红色，g表示绿色，b表示蓝色，取值可以为正整数或者百分数，a表示透明度，取值范围 0 - 1 之间，0表示完全透明，1表示完全不透明。
-  区别：
-  opacity 作用于元素，以及元素的所有后代元素（会被子元素继承），而 rgba 只作用于元素本身（不会被子元素继承）。
-  opacity 不会触发浏览器的重排和重绘，而 rgba 会导致浏览器重绘。

### 2、Echarts
#### 1. 常用的配置有哪些？

####

<pre>
1、title标题组件 show text link
2、tooltip 提示框组件 show trigger show formatter
3、legend 图例组件 show orient data
4、toolbox 工具栏组件 show feature saveLoad dataZoom restore
5、grid 直角坐标系内绘图网格 show top left bottom right
6、xAxis 直角坐标系 grid 中的 x 轴 show type axisLabel splitLine
7、yAxis 直角坐标系 grid 中的 y 轴 show type axisLabel splitLine
8、polar 极坐标系 show angleAxis radiusAxis
9、radar 雷达图 show indicator
10、series 系列列表 show type data
11、color 颜色映射组件 show color
12、visualMap 视觉映射组件 show type dimension min max inRange outRange
13、dataZoom 数据区域缩放组件 show type start end
14、timeline 时间轴组件 show type currentIndex autoPlay
15、axisPointer 坐标轴指示器组件 show type axis line
</pre>


### 3、uni-app

#### 1. uni-app 分包

<pre>
1、分包的作用：优化小程序的下载和启动速度；
2、小程序启动默认下载主包并启动页面，当用户进入分包时，才会下载对应的分包，下载完进行展示；
3、首先在 mainfest.json mp-weixin添加以下代码（启动分包）(第一个代码块)
4、在pages.json中加入subPackages，里面是对象(第二个代码块)
</pre>

```json lines
{
  "mp-weixin": {
    "appid": "touristappid",
    "setting": {
      "urlCheck": true,
      "checkSiteMap": false
    },
    "usingComponents": true,
    //在此处加上以下一句话
    "optimization": {
      "subPackages": true
    }
  },
}
```

```json lines
{
  "pages": [
    "pages/index/index",
    "pages/good/index",
  ],
  "subpackages": [
    {
      "root": "pagesA",
      //分包的根路径，彼此之间不可以重复
      "name": "pagesA",
      //分包的标识名字，用于预加载分包时用
      "pages": [
        //分包的路径（不预加载的时候，用户进入分包路径才会加载分包资源）
        "register/register"
      ],
      "independent": false
      //是否独立分包（可以不加载主包就独立加载的包，独能立分包不当做全局资源）
    },
    {
      "root": "pagesB",
      "name": "pagesB",
      "pages": [
        "children/addChildren"
      ],
      "independent": false
    }
  ],
  //预加载
  "preloadRule": {
    "pages/index": {
      "network": "",
      "packages": [
        "pagesA"
      ]
      // 在 pages/index 页面中预加载名为 pagesA分包内容
    }
  }
}
```

### 4、webpack

####

#### 1. webpack 打包和不打包的区别

<pre>
    1、打包：将多个文件打包成一个文件，减少网络请求次数，提高运行效率；
    2、对基础的支持不够；
</pre>

#### 2. webpack 打包原理 babel是做什么的

<pre>
    webpack 会将js 、css、image 看作一个模块，用import/require引入，
    找到入口文件，通过入口文件找到关联的依赖文件，把它们打包到一起，
    把bundle文件拆分成多个小文件，异步按需加载所需要的文件。
    如果一个文件被多个文件引用，打包时只会生成一个文件
    如果引用的文件没有被调用，不会被打包，如果引入的变量和方法没有被调用，也不会被打包。
    对于多个入口文件，假如引用了相同的代码，可以用插件把它抽离到公共文件中。
    babel的作用
    1、将es6、es7、es8等高级语法转换成低级语法，让浏览器可以运行；
    2、将react、vue等高级语法转换成低级语法，让浏览器可以运行；
    3、将typescript转换成js，让浏览器可以运行；
    4、将less、sass、stylus等转换成css，让浏览器可以运行；
</pre>

### 5、算法

#### 1、数据结构

<pre>
计算机存储或者组织数据的方式
</pre>

#### 2、空间复杂度

<pre>
1、什么时空间复杂度
    空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度，它也是程序执行时间的一部分。

2、表示法
    O(1)表示常数阶，O(logN)表示对数阶，O(n)表示线性阶，O(n^2)表示平方阶，O(2^n)表示指数阶

3、如何计算
    1、只关注循环次数最多的循环，其他循环可以忽略不计；
    2、用大O表示法表示循环
</pre>

#### 3、时间复杂度

<pre>
1、什么是时间复杂度
    时间复杂度是对一个算法执行时间的长短度量，它也是程序执行时间的一个量度。

2、表示法
    O(1)表示常数阶，O(logN)表示对数阶，O(n)表示线性阶，O(n^2)表示平方阶，O(2^n)表示指数阶

3、如何计算
    1、只关注循环次数最多的循环，其他循环可以忽略不计；
    2、用大O表示法表示循环
</pre>

```javascript
// 1、时间复杂度 O(1)
let a = 1

function fn(n) {
    return n++;
}

fn(a)
// 2、时间复杂度 O(n)
for (let i = 0; i < n; i++) {
    console.log(i)
}
// 3、时间复杂度 O(n^2)
for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
        console.log(i, j)
    }
}

// 4、时间复杂度 O(2^n)
function fn(n) {
    if (n == 1) {
        return 1
    } else {
        return 2 * fn(n - 1)
    }
}

fn(n)

// 5、空间复杂度 O(logn)
let i = 1;
const n = 6;
while (i < n) {
    i = i * 2;
}

```

#### 4、栈的介绍

<pre>
栈是一种遵从后进先出(LIFO)原则的有序集合。新添加的或待删除的元素都保存在栈的顶端。

1、栈的声明
    let stack = [];

2、栈的常用方法
    push()   添加一个或多个元素到栈顶 [1,2,3] ==> [1,2,3,4]
    pop()    移除栈顶的元素，同时返回被移除的元素 [1,2,3] ==>4
    peek()   返回栈顶的元素，不对栈做任何修改(该方法不会移除栈顶的元素，仅仅返回它) [1,2,3,4] ==> 4
    empty()  如果栈里没有任何元素就返回true，否则返回false [] ==>true  [1] ==>false

3、栈的应用场景
    函数调用栈
    浏览器的前进后退
</pre>
```javascript
// 力扣题  有效的括号 时间复杂度O(n) 空间复杂度O(n)
// 输入 '(){}' 返回true 输入'(]{}' 返回false
function fn(str) {
    const stack =[];
    for(let i=0;i<str.length; i++){
        const start = str[i];
        if(str[i] === '(' || str[i] === '{' || str[i] === '['){
            stack.push(str[i]);
        }else{
            const end = stack[stack.length - 1];
            if(start ===')' && end ==='(' ||
            start===']' && end==='[' ||
            start==='}' && end==='{'){
                stack.pop();
            }else{
                return false;
            }
        }
    }
    return stack.length === 0;
}

console.log(fn('(){}')) // true
console.log(fn('(]{}')) // false
```
```javascript
// 力扣题  删除字符串中所有相邻重复项。

function fn(str) {
    const stack =[];
    for(s of str){
        let prev = stack.pop();
        if(prev !== s){
            stack.push(prev);
            stack.push(s);
        }
    }
    return stack.join('');
}

console.log(fn('abbaca')) // ca
```
```javascript
// 力扣题  简化路径

function fn(path) {
        const stack = [];
        let str = '';
        let arr = path.split('/');
        arr.forEach(item => {
            if(item && item=== '..'){
                stack.pop();
            }else if(item && item !=='.'){
                stack.push(item);
            }
        })
        return '/' + stack.join('/');
}

console.log(fn('/home/')) // /home
console.log(fn('/../')) // /
console.log(fn('/home//foo/')) // /home/foo
console.log(fn('/a/./b/../../c/')) // /c
```
```javascript
// 力扣题  移掉K位数字

function fn(num, k) {
    if(num.length <= k){
        return '0';
    }
    let stack = [];
    for(let i = 0; i < num.length; i++){
        while(k && stack.length && stack[stack.length-1] > num[i]){
            stack.pop();
            k--;
        }
        stack.push(num[i]);
    }
    stack.splice(0, k);
    let res = stack.join('');
    return res.length ? res : '0';
}

console.log(fn('1432219',3)) // 1219
```

#### 5、队列的介绍
队列是遵循FIFO（先进先出）原则的一组有序的项。队列在尾部添加新元素，并从顶部移除元素。

### 6、Javascript
#### 1、为什么 javascript 是单线程？
<pre>
    JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么 JavaScript 不能有多个线程呢？
    这样可以同时执行多个任务，提高性能，减少延迟。
    
    JavaScript 单线程，与它的用途有关。作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM。
    这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，
    另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？

    所以，为了避免复杂性，从一诞生，JavaScript 就是单线程，这已经成了这门语言的核心特征，将来也不会改变.
</pre>

#### 2、javascript 是单线程，怎么执行异步代码？
<pre>
    JavaScript 语言的执行环境是“单线程”的，也就是说，一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，
    再执行后面一个任务，以此类推。
    1、同步任务
        同步任务都在主线程上执行，形成一个执行栈。
    2、异步任务（宏任务、微任务）
        除了同步任务以外，其他任务都属于异步任务，又可以分成两种：
        1. 普通事件，如click、resize等。
        2. 资源加载，如load、error等。
        3. 定时器，包括setInterval、setTimeout等。
        4.promise对象。
        5.async/await。
    3、宏任务
        script(整体代码), setTimeout, setInterval, setImmediate(Node.js 环境), requestAnimationFrame(浏览器环境)，
        I/O, UI rendering(浏览器环境)，网络请求
    4、微任务
        process.nextTick(Node.js 环境), Promise.then(null), Promise.catch(null), Promise.finally(null
        promise 回调 、DOM变动观察器
    5、事件循环
        1. 执行一个宏任务（栈中没有就从事件队列中获取）
        2. 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中
        3. 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
        4. 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染
        5. 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）
        6. 如此循环
    6、任务队列
        1. 同步任务都在主线程上执行，形成一个执行栈。
        2. 主线程之外，还存在一个"任务队列"。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。
        3. 一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异
        步任务，于是结束等待状态，进入执行栈，开始执行。
        4. 主线程不断重复上面的第三步。
    7、JS执行流程
        1. 主线程读取JS代码，此时是在同步环境，形成对应的堆和执行栈；
        2. 主线程遇到异步任务，会推给异步线程进行处理；
        3. 异步线程处理完毕后，将对应的异步任务推到任务队列中；
        4. 主线程查询任务队列，执行微任务，将其按照顺序执行，全部执行完毕。
        5. 主线程查询任务队列，执行宏任务，取得第一个宏任务，执行完毕。
        5. 主线程不断重复第四步。
        
    异步任务相关的事件回调函数都在任务队列中等待。
    一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会按次序读取任务队列，将可运行的
    异步任务添加到可执行栈中，开始执行。
</pre>

#### 3、promise

<pre>
    1、Promise的含义
        Promise是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现
        ，ES6将其写进了语言标准，统一了用法，原生提供了Promise对象。 

    2、Promise解决了哪些问题
        1. 回调地狱
        2. 多个异步操作的串行执行
        3. 并行执行异步操作，且可以获得所有异步操作的结果
    3、Promise有几种状态
        1. pending: 初始状态，既不是成功，也不是失败状态。
        2. fulfilled: 意味着操作成功完成。
        3. rejected: 意味着操作失败。
    4、Promise的构造函数是做什么的？
        1. 创建一个Promise实例，需要传入一个函数作为参数，该函数的两个参数分别是resolve和reject。
        2. 该函数会立即执行。
</pre>

#### 4、generator

<pre>
    1、Generator的含义
        Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。
        Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。
        执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成器。
        形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；
        二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。
    2、Generator的用法
        1. 基本用法
            function* helloWorldGenerator() {
                yield 'hello';
                yield 'world';
                return 'ending';
            }

            var hw = helloWorldGenerator();
            console.log(hw.next()); // { value: 'hello', done: false }
            console.log(hw.next()); // { value: 'world', done: false }
            console.log(hw.next()); // { value: 'ending', done: true }
            console.log(hw.next()); // { value: undefined, done: true }
        2. yield表达式
            function* fibonacci() {
                let [prev, curr] = [0, 1];
                for (;;) {
                    yield curr;
                    [prev, curr] = [curr, prev + curr];
                }
            }

            for (let n of fibonacci()) {
                if (n > 1000) break;
                console.log(n);
            }
        3. 与Iterator接口的关系
            Generator 函数就是遍历器生成函数。
            Generator 函数除了状态机，还是一个遍历器对象生成函数。
            Generator 函数可以不用任何修饰符调用，这是因为它就是遍历器对象生成函数。
            Generator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也继承了Generator函数的prototype对象上的方法。
        4. 作为对象属性的Generator函数
            var myIterable = {};
            myIterable[Symbol.iterator] = function* () {
                yield 1;
                yield 2;
                yield 3;
            };

            [...myIterable] // [1, 2, 3]
            let obj = {};
            obj[Symbol.iterator] = function* () {
                yield 1;
                yield 2;
                yield 3;
            };

            obj[Symbol.iterator] // 1
            obj // {1: 2, 2: 3, 3: 4}
        5. Generator函数的this
            Generator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也继承了Generator函数的prototype对象上的方法。
            Generator 函数也不能跟new命令，否则会抛出一个错误。
</pre>

#### 5、JS延迟加载有哪些方式

<pre>
    defer和async、动态创建DOM方式（通过documen.write）、按需异步载入js
    
    defer和async的区别
    defer要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；
    async一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。
</pre>

#### 6、JS数据类型

<pre>
    基本数据类型：String,Number,Boolean,Undefined,Null,Symbol,bigint
    引用数据类型：Object
    NaN 是一个数值类型，但不是一个具体的数字；
</pre>

#### 7、数据类型的隐式转换

```javascript
console.log(true + 1); // 2 number
console.log('name' + true); // 'nametrue' string
console.log(undefined +  1); // NaN number
console.log(typeof NaN); // number
console.log(typeof  undefined); // undefined
```

#### 8、null 和 undefined 的区别

<pre>
    1. 最初设计js的时候借鉴了java语言，java中含有null,就设计了null。
    2. null会被隐式转换为0，很不容易发现错误。
    3. 现有null后有undefined,设计undefined是为了填补之前的坑。
    具体区别：
    javascript的最初版本是这样区分的，null表示一个"无"的对象（空对象指针），转为数值时为0，
    undefined表示一个"无"的值（空值指针），转为数值时为NaN。
</pre>
```javascript
console.log(Number(null)) // 0
console.log(Number(undefined)) // NaN
```

#### 9、== 和 === 有什么不同

-  == : 只进行值的比较，不进行数据类型的比较
-  string == number || boolean || ...都会隐式转换，
-  通过valueOf转换（valueOf() 方法通常由JavaScript自动调用，并不显式地出现在代码中）
-  隐式转换：虽然两个值比较是相等 但是数据类型还是不相同，不做显示只做比较。
-  === : 除了比较值，还比较数据类型（建议使用三等）

```javascript
console.log(1 == '1') // true
console.log(1 === '1') // false

console.log(null == undefined) // true
console.log(null === undefined) // false

console.log(true == 1) // true
console.log(true === 1) // false

console.log([1,2] == '1,2'); // true
console.log([1,2] === '1,2'); // false
```

#### 10、JS 作用域

-  1.除了函数外，js 是没有块级作用域的。

```javascript
function fn(){
    var a = 10;
}

console.log(a); // 报错

for(var i=0;i<10;i++){}
console.log(i); // 10

if(true){
    var b = 11;
}
console.log(b); // 11
```

-  2.作用域链：内部可以访问外部变量，外部不能访问内部变量。
    注意：如果内部有，优先查找内部，如果内部没有就查找外部的。

```javascript
function fn1(){
    var a = 10;
    function fn2(){
        console.log(a);
    }
    fn2();
}
fn1(); // 10
```
-  3.注意声明变量是用var还是没有写（没有写默认全局，注册在window上），
```javascript
function fn(){
    var a= b = 10
    console.log(a); // 10
    console.log(b); // 10
}
console.log(a); // a is not defined
console.log(b); // 10
```
-  4.js有变量提升的机制（变量悬挂声明）
-  5.变量提升只提升声明，不提升赋值
```javascript
var a = '2222'
function fn(){
    console.log(a); // undefined
    var a = '1111'
    console.log(a); // 1111
}
fn(); // undefined
// 如果没有声明a 那么会报错 a is not defined
```
-  6.优先级：声明变量> 声明普通函数> 参数> 变量提升
```javascript
// 声明变量> 声明普通函数
var a = '2222'
function a(){}
console.log(a); // 2222

// 普通声明函数是不看写函数的时候顺序

b() // 声明前面调用
function b(){
    console.log('b');
}

b() // 声明后面调用

// 声明普通函数> 参数

function a(a){
    console.log(a); // f a(){}
    function a(){}
}
a(1111);

// 参数> 变量提升

function fun(a){
    console.log(a); // 1111
    var a = '33333'
}
fun(1111); // 1111

// 声明普通函数> 变量提升
console.log(a); // f a(){}
var a = '33333'
function a(){}

// 变量提升并赋值再次赋值
function fn(){
    a = 10;
    console.log(a); // 10
    var a =20;
    console.log(a); // 20
}
fun()
```

#### 11、JS对象
```javascript
// 1.对象通过new操作符构建出来的，所以对象之间不相等（除了引用外）。
console.log([1,2,3] ===[1,2,3]); // false

// 2.对象注意：引用类型（共同地址）
var a = {name:'zs'}
var b = a;
b.name = 'ls';
console.log(a.name); // ls

// 3.对象key都是字符串， 对象属性为对象时会转换为字符串 [object Object]
var a = {}
var c={key:'c'}
var d ={key:'d'}
a[c]= 'c';
a[d]= 'd';
for(var i in a){ 
    console.log(i) // [object Object]
    console.log(typeof i); // string
}
console.log(a[c]); // d

// 4.对象如何查找属性或者方法
console.log([1,2,3].constructor) // f Array() == new Array()
// 每个函数都自带一个属性prototype，prototype的属性constructor指向构造函数
// 注意：对象拥有__proto__属性，指向构造函数的prototype
// new Fun 该Fun构造函数的原型指向对象（new Fun)的原型
// 实例的指针指向构造函数的原型
function Fun (){};
var obj = new Fun();
console.log(obj.constructor) // f Fun()
obj.__proto__ == Fun.prototype;
console.log(obj.__proto__ == Fun.prototype); // true

function Fn(){
    this.a= '函数中添加的属性'
}

Fn.prototype.say = function(){
    console.log('我是原型中的方法')
}

var fn = new Fn();
fn.a='我是对象本身属性'
fn.__proto__a="我是对象原型中添加的属性"
Object.a="我是Object对象中添加的属性"
console.log(fn.a)
// 对象本身属性 -> 构造函数中添加的属性 -> 对象原型中添加的属性 -> 构造函数原型中查找 -> 对象上一层的原型中查找
 ```

#### 12、this 指向
```javascript
function fn(){
    console.log(this)
}

fn() // window
```

```javascript
function Foo(){
    getName = function (){console.log(1)} // window上的的方法
    return this;
}

Foo.getName=function (){console.log(2)}; // Foo的自有方法

Foo.prototype.getName=function (){console.log(3)}; // Foo原型上的方法

var getName = function (){console.log(4)}; // 全局变量

function getName(){console.log(5)}; // 

Foo.getName();       // 2
getName();           // 4
Foo().getName();     // 1
getName();           // 1
new Foo().getName(); // 3

// 1. 函数执行，首先看函数名前面是否有"."，
// 1.1 有的话， "."前面是谁，this就指向谁
// 1.2 没有的话，this就指向window
var o ={
    a:10,
    b:{
        fn:function (){
            console.log(this.a);
            console.log(this)
        }
    }
}
o.b.fn() // undefined b

// 2. 自执行函数中的this指向window
~function (){console.log(this)}();
```

```javascript
window.name = 'ByteDance';
function A(){
    this.name = 'A';
}
A.prototype.getA = function (){
    console.log(this);
    return this.name + 1;
};

let a = new A();
let funcA = a.getA; // window.funcA =function (){console.log(this);return this.name + 1;}
funcA(); // window
```

```javascript
var length = 10;
function fn() {
    return this.length + 1;
}
var obj = {
    length: 5,
    test1: function () {
        return fn();
    }
};
obj.test2 = fn;
console.log(obj.test1()); // 11
console.log(fn() === obj.test2()) // 11 6 false
console.log(obj.test1() ===obj.test2()) // 11 6 false
console.log(obj.test2()); // 6
```

#### 13、JS判断变量是不是数组，你能写出哪些方法？
-  1.isArray
-  2.instanceof
-  3.constructor
-  4.isPrototypeOf
-  5.Object.prototype.toString.call
```javascript
var arr = [1, 2, 3];
console.log(arr instanceof Array); // true
console.log(Array.isArray(arr)); // true
console.log(arr.constructor === Array); // true
console.log(Array.prototype.isPrototypeOf(arr)) // true
console.log(Object.prototype.toString.call(arr) === '[object Array]'); // true
````

#### 14、slice作用 ，splice是否改变原数组
-  1.slice() 方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。
-  2.splice() 方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。
```javascript
// slice 浅拷贝
var arr = [1, 2, 3, 4, 5,{a:1,b:2},[1,2,3]];
var arrCopy = arr.slice(); // arrCopy 是arr的副本
arrCopy.push(6); // arrCopy 是 [1, 2, 3, 4, 5,{a:1,b:2},[1,2,3], 6]
console.log(arr); // 输出 [1, 2, 3, 4, 5,{a:1,b:2},[1,2,3]]
arrCopy[5].a = 3; // arrCopy 是 [1, 2, 3, 4, 5,{a:3,b:2}
console.log(arr); // 输出 [1, 2, 3, 4, 5,{a:3,b:2}
arrCopy[6][0]=4; // arrCopy 是 [1, 2, 3, 4, 5,{a:3,b:2,c:4},[4,2,3],6]
console.log(arr); // 输出  [1, 2, 3, 4, 5,{a:3,b:2,c:4},[4,2,3],6]

// 1.slice 截取 3 ~ (arr.length-1)所有数据
let arr3 = arr.slice(3); //  输出 [4, 5,{a:1,b:2},[1,2,3], 6]

// 2.slice 从前到后截取 0 ~ 3 数据
let arr1 = arr.slice(0,3);
console.log(arr1); // 输出 [1, 2, 3]

// 3.slice 从后往前截取 (arr.length-1) ~ (arr.length-1-3)数据
let arr2 = arr.slice(-3);
console.log(arr2); // 输出 [{a:3,b:2},[1,2,3],6]


```
```javascript
// splice 深拷贝 
var arr = [1, 2, 3, 4, 5,{a:1,b:2},[1,2,3]];

var arrCopy = arr.splice(0,4); // arrCopy 是arr的副本
arrCopy.push(6); // arrCopy 是 [1, 2, 3, 4, 5,6]
console.log(arr); // 输出 [{a:1,b:2},[1,2,3]]
arr[0].a = 3; // arrCopy 是 [1, 2, 3, 4, 5,6]
console.log(arr); // 输出  [{a:3,b:2},[1,2,3]]

// 1.splice 从前往后截取 3 ~ (arr.length-1)所有数据
let arr3 = arr.splice(3); //  输出 [4, 5,{a:3,b:2},[1,2,3],6]
console.log(arr); // 输出 [1, 2, 3]

// 2.splice 从前到后截取 0 ~ 3 数据
let arr4 = arr.splice(0,3); // 
console.log(arr4); // 输出 [1, 2, 3]
console.log(arr); // 输出 [4, 5,{a:3,b:2},[1,2,3],6]

// 3.splice 从后往前截取 (arr.length-1) ~ (arr.length-1-3)数据
let arr5 = arr.splice(-3); //
console.log(arr5); // 输出 [{a:1,b:2},[1,2,3],6]
console.log(arr); // 输出 [1, 2, 3, 4, 5,]

// 4.splice 修改数据
arr.splice(1,1,100); // 从索引为1的位置开始删除1个元素，并插入100
console.log(arr); // 输出 [1, 100, 2, 3, 4, 5]

// 5.splice 添加数据
arr.splice(0,0,66); // 从索引为0的位置开始删除0个元素，并插入66 等同于 unshift
console.log(arr); // 输出 [66, 1, 100, 2, 3, 4, 5]

```

#### 15、JS 数组去重
-  1、利用ES6 Set去重
```javascript
let arr = [1, 2, 3, 4, 5, 1, 2, 3, 4, 5];

function unique(arr) {
    return [...new Set(arr)] || Array.from(new Set(arr))
}
const arr2 = unique(arr);
console.log(arr2); // [1, 2, 3, 4, 5]
```
-  2、利用for + indexOf 去重（ES5中最常用）
```javascript
let arr = [1, 2, 3, 4, 5, 1, 2, 3, 4, 5];

function unique(arr) {
    const arr1 =[]
    for(let i = 0; i < arr.length; i++) {
        if(arr1.indexOf(arr[i])=== -1){
            arr1.push(arr[i])
        }
    }
    return arr1;
}

const arr2 = unique(arr);
console.log(arr2); // [1, 2, 3, 4, 5]
```
-  3、利用for + includes 去重
```javascript
let arr = [1, 2, 3, 4, 5, 1, 2, 3, 4, 5];

function unique(arr) {
    const arr1 =[]
    for(let i = 0; i < arr.length; i) {
        if(!arr1.includes(arr[i])){
            arr1.push(arr[i])
        }
    }
    return arr1;
}

const arr2 = unique(arr);
console.log(arr2); // [1, 2, 3, 4, 5]
```
-  4、利用for + sort 去重
```javascript
let arr = [1, 2, 3, 4, 5, 1, 2, 3, 4, 5];

function unique(arr) {
    arr = arr.sort();
    const arr1 =[];
    for(let i = 0; i < arr.length; i++) {
        if(arr[i] !== arr[i-1]){
            arr1.push(arr[i])
        }
    }
    return arr1;
}

const arr2 = unique(arr);
console.log(arr2); // [1, 2, 3, 4, 5]
```
-  5、利用filter 去重
```javascript
    
let arr = [1, 2, 3, 4, 5, 1, 2, 3, 4, 5];

function unique(arr) {
    return arr.filter((item, index) => {
        return arr.indexOf(item) === index;
    })
}

const arr2 = unique(arr);
console.log(arr2); // [1, 2, 3, 4,5]
```

#### 16、多维数组最大值
```javascript

function maxValue(arr) {
    let max = -Infinity;
    function getMax(arr) {
        for(let i = 0; i < arr.length; i++) {
            if(Array.isArray(arr[i])) {
                getMax(arr[i]);
            } else {
                max = Math.max(max, arr[i]);
            }
        }
    }
    getMax(arr);
    return max;
} 

const arr = [1, 2, [3, 4, [5, 6, [7, 8]]]];
console.log(maxValue(arr)); // 8
```

#### 17、数组扁平化
```javascript

function flatten(arr) {
    return arr.reduce((pre, cur) => {
        return pre.concat(Array.isArray(cur) ? flatten(cur) : cur);
    }, []);
}

const arr = [1, 2, [3, 4, [5, {a:1},6, [7, 8]]]];
console.log(flatten(arr)); // [1, 2, 3, 4, 5, 6, 7, 8]
```

#### 18、给字符串新增方法实现功能
```javascript
// 字符拼接前缀
let str = '你好'
String.prototype.addPrefix = function (str) {
    return str + this
}
console.log(str.addPrefix('hello')) // hello你好
```

#### 19、字符串出现最多次数的字符及次数
```javascript
let str = 'abcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdef'
function maxStr(str) {
    let obj = {};
    for(let i = 0; i < str.length; i++) {
        if(!obj[str[i]]) {
            obj[str[i]] = 1;
        } else {
            obj[str[i]]++;
        }
    }
    let max = 0;
    let maxStr = '';
    for(let key in obj) {
        if(obj[key] > max) {
            max = obj[key];
            maxStr = key;
        }
    }
    return maxStr + ':' + max;
}
console.log(maxStr(str)) // a:7
```

#### 20、new 操作符具体做了什么

```javascript
// 模拟new操作符 封装new方法
function myNew(fn, ...args) {
// 1.创建一个空对象
    const obj = {}
// 2.将这个空对象的原型指向构造函数的原型
//     obj.__proto__ = fn.prototype
    Object.setPrototypeOf(obj, fn.prototype)
// 3.将这个空对象赋值给函数中的this
    const result = fn.apply(obj, args)
// 4.判断构造函数的返回值类型
// 如果是引用类型([],{})，返回这个引用类型的对象
    if (typeof result === 'object' && result !== null) {
        return result
    } else {
// 如果是值类型(string,boolean,number...)，返回创建的对象
        return obj
    }
}

function Fun(age) {
    this.age = age;
    return {} || [] // 返回引用类型 {} || []
    return 123 || '124' || true  //等基本类型 返回值类型是值类型 {age:18}
}

console.log(myNew(Fun, 18))
```

#### 21、实现一个深拷贝

```javascript
function deepClone(obj) {
    // 如果是值类型，直接返回
    if(typeof obj !== 'object' || obj === null) {
        return obj
    }
    // 如果是引用类型，创建一个新的对象
    let result = Array.isArray(obj) ? [] : {}
    for(let key in obj) {
        if(obj.hasOwnProperty(key)) {
            result[key] = deepClone(obj[key])
        }
    }
    return result
}
```

#### 22、实现一个深比较

```javascript
function deepCompare(obj1, obj2) {
    // 判断是否是引用类型
    if (typeof obj1 !== 'object' || typeof obj2 !== 'object' || obj1 === null || obj2 === null) {
        return obj1 === obj2
    }
}
```

#### 23、闭包

-  1.闭包是什么
<pre>
    闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，
    通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。
</pre>
```javascript
function fn() {
    let num = 10
    return function() {
        num++
        console.log(num)
    }
}
let f = fn();
f() // 11
```
-  2.闭包可以解决什么问题
<pre>
    闭包可以缓存数据，如果一个函数在多次调用时，每次都需要重新计算，
    那么可以使用闭包将计算的结果缓存起来，避免每次调用时都重新计算。
</pre>
```javascript
const lis = document.querySelectorAll('li')
for(let i = 0; i < lis.length; i++) {
    // 使用立即执行函数将i作为变量传递给闭包进行缓存
    // 待同步函数执行完后，执行宏任务这样i就能拿到当前值而不是最后值
    // 从而实现点击时弹出对应索引的效果
    // 闭包的缺点是常驻内存，会增大内存使用量，使用不当很容易导致内存泄露 （IE浏览器）
    (function(i){
        lis[i].onclick = function() {
            alert(i)
        }
    })(i)
}
```
-  3.闭包的缺点
<pre>
    闭包会常驻内存，会增大内存使用量，使用不当很容易导致内存泄露。
    
    解决方案：
    
    1.及时释放闭包占用的内存 (闭包函数设置为null)
    2.在退出函数之前，将不使用的局部变量全部删除 （设置为null)
</pre>
```javascript
function fn() {
    let num = 10
    return function() {
        num++
        console.log(num)
    }
}
let f = fn();
f() // 11
// 及时释放闭包占用的内存
f = null
```
#### 24、原型链

### 7、websocket

###
#### 1、websocket是什么

<pre>
    WebSocket是一种在单个TCP连接上进行全双工通讯的协议。
    WebSocket使得客户端和服务器可以进行双向通信。
    在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。
</pre>

#### 2、websocket与http的区别

<pre>
    WebSocket是一个持久化的协议，相对于HTTP这种非持久的协议来说。
    WebSocket是双向通信协议，在建立连接之后，WebSocket的server与client都能主动向对方发送或接收数据。
    HTTP是单向的通信协议，也就是请求-响应模式，请求完成之后，连接就关闭了，要进行下一次通信，必须重新建立连接。
</pre>

#### 3、websocket与http2.0的区别

<pre>
    WebSocket和HTTP2.0有着本质的不同，HTTP2.0是一个应用层协议，WebSocket是一个独立的协议。
    WebSocket是一种双向通信协议，在建立连接之后，WebSocket的server与client都能主动向对方发送或接收数据。
    HTTP2.0是一个应用层协议，HTTP2.0的request和response都遵循HTTP协议的格式。
    HTTP2.0是双向通信协议，通信过程中可以同时发送多个请求或响应，而且这些请求或响应都是独立成行的，不必等待其中一个请求或响应完成后再发送下一个请求或响应。
    HTTP2.0采用二进制格式传输数据，比HTTP1.x的文本格式数据更高效；
    HTTP2.0支持服务器推送，即服务端可以主动向客户端推送数据。
    HTTP2.0实现了一些机制让客户端与服务器之间可以进行有效的交互。
</pre>

#### 4、websocket心跳机制

<pre>
        
</pre>

```javascript
    // 客户端的连接 ws服务器
    var ws = new WebSocket('wss://echo.websocket.org');
    // open 事件
    ws.onopen = function(evt) {
        console.log("Connection open ...");
        ws.send("Hello WebSocket!");
    };
    // message 事件
    ws.onmessage = function(evt) {
        console.log( "Received Message: " + evt.data);
        ws.close();
    };
    // close 事件
    ws.onclose = function(evt) {
        console.log("Connection closed.");
    };
    // 心跳机制
    setInterval(function(){
        ws.send("ping");
    }, 5000);
    // 断线重连 重连时间要大于心跳时间
    ws.onclose = function(){
        console.log("连接断开，重连中...");
        // 重连
        ws = new WebSocket('wss://echo.websocket.org');
    };
    ws.onopen = function(){
        console.log("重连成功");
    };
```
```javascript
// 封装成类使用
class Socket {
    wsUrl;
   constructor(wsUrl:any) {
        this.wsUrl = wsUrl;
    }
    modeCode={
       // webSocket 消息类型
        MSG:"message",
        // 心跳类型
        HEART_BEAT:"heart_beat",
    }
    ws:any=null;
    webSocketState:boolean=false;
    heartBeat ={
        // 心跳连接的时间设置
        time:5 * 1000, // 心跳时间间隔
        timeOut:3 * 1000, // 心跳超时间隔
        reconnect:10 * 1000, // 重连时间间隔
    }
    reconnectTimer:any=null; // 断开重连时间器
    /**
     * 连接 ws
     * */
    connectWebSocket(){
        this.ws = new WebSocket(this.wsUrl);
       this.init();
    }

    /**
     * 心跳初始函数
     */
    
    startHeartBeat(time:number | string){
        setTimeout(()=>{
            this.ws.send(JSON.stringify({
                ModeCode:this.modeCode.HEART_BEAT,
                msg:new Date(),
            }))
            this.waitingServer()
        },time)
    }
    
    /**
     * 延迟等待服务端响应，通过webSocketState判断是否连接成功
     * */
    waitingServer(){
        this.webSocketState = false;
        setTimeout(()=>{
            if (this.webSocketState){
                this.startHeartBeat(this.heartBeat.time)
                return;
            }
            console.log("心跳无响应，已断开...");
            try{
                this.ws.close();
            }catch(e){
                console.log("关闭连接失败...");
            }
            this.reconnectWebSocket();
        },
        this.heartBeat.timeOut)
    }

    /**
     * 重连操作
     */
    reconnectWebSocket(){
        this.reconnectTimer = setTimeout(()=>{
            console.log("尝试重新连接...");
            this.reconnectWs();
        },this.heartBeat.reconnect)
    }
    
    /**
     * 初始化
     * */
   init(){
       this.ws.addEventListener('open',()=>{
           // socket状态设置为连接， 作为后面的断线重连的拦截器
           this.webSocketState = true;
           // 是否启动心跳级制
           this.heartBeat && this.heartBeat.time ?
           this.startHeartBeat(this.heartBeat.time) : null;
           console.log("连接成功...");
       })
       this.ws.addEventListener('message',(e)=>{
           console.log("收到消息：",e.data);
           const data = JSON.parse(e.data);
           switch (data.ModeCode){
               case this.ModeCode.heartBeat:
                   console.log("收到心跳..."+data.msg);
                   break;
               case this.ModeCode.MSG:
                   console.log("收到消息..."+data.msg);
                   break;
           }
       })
       this.ws.addEventListener('close',(e)=>{
           this.webSocketState = false;
           console.log("连接已关闭...",e);
       })
       this.ws.addEventListener('error',()=>{
           this.webSocketState = false;
           console.log("连接出错...",e);
           this.reconnectWebSocket(); //重连
       })
    }
    reconnectWs(){
       if(!this.ws){
           // 第一次执行，初始化
           this.connectWebSocket();
       }
       if(this.ws && this.reconnectTimer){
           // 防止多个webSocket同时执行
           clearTimeout(this.reconnectTimer);
           this.ws.reconnectTimer = null;
           this.connectWebSocket()
       }
    }

    /**
     *  发送消息
     */
    sendMessage(data:any){
        this.ws.send(JSON.stringify(data));
    }

    /**
     * 在其他需要socket的地方主动关闭socket
     */
    closeWebSocket(e:any){
        console.log("主动关闭socket...",e);
        this.ws.close();
        clearTimeout(this.reconnectTimer);
        this.webSocketState = false;
    }
}

export default Socket;
```
```javascript
/**
 * 使用
 * @type {Socket}
 */
import Socket from './socket';

const socket = new Socket("url");
socket.init();
socket.sendMessage("Hello WebSocket!");
```

### 8、浏览器
###
#### 1、localStrage、sessionStrage、cookie的区别

<pre>
    localStrage、sessionStrage、cookie都是浏览器端存储数据的方式，区别如下：
    1、存储位置不同：
        localStrage、sessionStrage存储在浏览器端，而cookie存储在服务端。
    2、存储大小不同：
        localStrage、sessionStrage、cookie存储大小不同，cookie一般不能超过4k，而localStrage、sessionStrage可以存储超过4k的数据。
    3、有效时间不同：
        localStrage、sessionStrage在设置的有效时间内一直有效，而cookie在设置的有效期内一直有效，即使窗口或浏览器关闭。
    4、与服务器端通信不同：
        localStrage、sessionStrage在设置的有效期内一直有效，而cookie在设置的有效期内一直有效，即使窗口或浏览器关闭。
</pre>

#### 2、浏览器缓存

<pre>

    浏览器缓存分为强缓存和协商缓存。

    1、强缓存：
        浏览器直接从缓存中读取资源，不会向服务器发送请求。
        强缓存可以通过设置两种HTTP Header实现：Expires和Cache-Control。
        Expires是HTTP/1.0的产物，表示缓存到期时间，但是它受限于本地时间，如果修改了本地时间，可能会造成缓存失效。
        Cache-Control是HTTP/1.1的产物，在Expires出现后，Cache-Control成为主要控制缓存失效的header。
        Cache-Control的几个常用字段：
            public：所有内容都将被缓存（客户端和代理服务器都可缓存）
            private：所有内容只有客户端可以缓存，Cache-Control的默认取值
            no-cache：客户端缓存内容，但是是否使用缓存需要经过协商缓存来验证决定
            no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存
            max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效

    2、协商缓存：
        如果缓存过期了，那么浏览器会发送请求到服务器，服务器根据请求中的相关标识来判断是否命中缓存。
        如果命中缓存，则返回304和Not Modified状态码，浏览器根据此状态码来从缓存中读取资源。
        如果未命中缓存，则返回200和请求的结果资源，并且会更新缓存中的资源。
        协商缓存可以通过设置两种HTTP Header实现：Last-Modified和ETag。
        Last-Modified：标识请求资源在服务器上的最新修改时间。
        ETag：标识请求资源的唯一标识符。

</pre>

#### 3、浏览器输入URL到页面展示的详细过程

<pre>

    1、DNS解析：
        浏览器缓存-&gt;系统缓存-&gt;路由器缓存-&gt;ISP DNS缓存-&gt;递归搜索

    2、TCP连接：
        三次握手：
            客户端发送SYN包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；
            服务器收到SYN包，必须确认客户的SYN(ack=j+1)，同时自己也发送一个SYN包(syn=k)，即SYN+ACK包，此时服务器进入SYN_RECV状态；
            客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

    3、发送HTTP请求：
        客户端向服务器发送一个HTTP请求，请求被发送到服务器的默认端口(80)

    4、服务器处理请求：
        服务器端请求处理完毕后，向客户端发送HTTP响应，客户端接收HTTP响应并渲染页面

    5、关闭TCP连接：
        客户端获取到HTML文档后，会关闭TCP连接，或者等待一段时间后发起TCP连接

</pre>

#### 4、HTTP1.0和HTTP1.1的区别

<pre>

    1、长连接：
        HTTP1.0默认是短连接，也就是说每次请求都要重新建立一次连接，用完就断开。
        HTTP1.1默认是长连接，也就是说，默认会保持连接。

    2、缓存处理：
        HTTP1.0没有指定缓存的处理方式，依赖浏览器或者用户自己进行处理。
        HTTP1.1新增了缓存处理，如缓存请求头字段Cache-Control、Last-Modified、Etag等。

    3、带宽优化及网络连接的使用：
        HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，
        并且不支持断点续传功能，HTTP1.1则在请求头引入了Range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），
        这样就方便了开发者自由的选择以便充分利用带宽和连接。

    4、错误通知的管理：
        在HTTP1.1中，新增了24个错误状态响应码，
        如409（Conflict）表示请求的资源与资源的当前状态发生冲突；
        410（Gone）表示服务器上的某个资源被永久性的删除。

    5、Host头处理：
        在HTTP1.0中，每个请求的header中都有Host信息，例如：Host:www.google.com。
        而在HTTP1.1中，Host信息是必须的，如果客户端没有给出这个信息，服务器将不会处理该请求。

</pre>

#### 5、HTTP2.0的新特性

<pre>

    1、二进制分帧：
        HTTP2.0将报文分成帧（frame）进行传输，和HTTP1.x一样，HTTP2.0也需要客户端和服务器同时支持，才能实现二进制分帧，
        实现二进制分帧的关键是帧头，它由帧类型（type）、帧长度（length）、帧标志（flags）三个字段组成，其中帧长度指的是整个帧的长度，
        而不包括帧头本身的长度。

    2、多路复用：
        多路复用是指在单个连接上可以同时传送多个请求或响应，即可以同时发送多个请求或响应，它的最大优点就是减少了建立和关闭连接的消耗和延迟，
        节省了带宽资源。

    3、头部压缩：
        HTTP2.0实现了头部的压缩功能，即HTTP2.0在客户端和服务器端使用“HPACK”算法来压缩头部，使数据体积变小，提高传输速度。

    4、服务器推送：
        HTTP2.0服务器能够更快的将资源发送给客户端，这被称为服务器推送。

</pre>

#### 6、HTTP请求报文和响应报文的具体格式

<pre>

    请求报文格式：
        请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。

    响应报文格式：
        状态行、响应头部、空行和响应数据四个部分组成。

</pre>

#### 7、HTTP常见状态码

<pre>

    200 OK：客户端请求成功。
    201 Created：已创建，成功请求并创建了新的资源。
    202 Accepted：已接受，已经接受请求，但未处理完成。
    203 Non-Authoritative Information（非授权信息）：请求成功。但返回的meta信息不在原始的服务器，而是一个副本。
    204 No Content：请求成功，但返回的meta信息为空（用null表示）。
    205 Reset Content（重置内容）：服务器处理成功，用户终端（例如：浏览器）应重置文档视图。
    206 Partial Content（部分内容）：服务器成功处理了部分GET请求。

    300 Multiple Choices（多种选择）：请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择。
    301 Moved Permanently（永久移动）：请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。
        今后任何新的请求都应使用新的URI代替。
    302 Found（找到）：临时性重定向。
    303 See Other（查看其他）：临时性重定向，且总是使用GET方法请求新的URI。
    304 Not Modified（未修改）：自从上次请求后，请求的资源未修改过，服务器返回此状态码时，不会包含任何响应的主体部分。
    305 Use Proxy（使用代理）：请求的资源必须通过代理访问。
    306 (Unused)：已经被废弃的代码，将来有可能使用，现在尚未使用。
    307 Temporary Redirect（临时重定向）：临时重定向，与302 Found类似。使用GET方法请求新的URI，但是POST方法提交的请求报文中的地址不会改变。

    400 Bad Request（错误请求）：请求报文存在语法错误。
    401 Unauthorized（未授权）：请求需要有通过HTTP认证的认证信息。
    402 Payment Required（支付要求）：该状态码是为了将来可能的需求而预留的。
    403 Forbidden（禁止）：服务器收到请求，但是拒绝提供服务。
    404 Not Found（未找到）：请求的资源不存在，或不可用。
    405 Method Not Allowed（方法禁用）：客户端请求中的方法被禁止。
    406 Not Acceptable（不可接受）：服务器无法根据客户端请求的内容特性完成请求。
    407 Proxy Authentication Required（代理服务器认证要求）：请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权。
    408 Request Timeout（请求超时）：服务器完成请求处理，但请求超时。
    409 Conflict（冲突）：通常和PUT请求有关。由于请求和资源的当前状态相冲突，因此请求不能成功。
    410 Gone（已删除）：被请求的资源已从这个地址转移，不再可用。
    411 Length Required（需要有效长度）：服务器无法处理客户端发送的不带Content-Length的请求信息。
    412 Precondition Failed（先决条件失败）：请求信息的先决条件错误。
    413 Request Entity Too Large（请求实体过大）：由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，
        服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息。
    414 Request-URI Too Long（请求URI过长）：请求的URI过长（URI通常为网址），服务器无法处理。
    415 Unsupported Media Type（不支持的媒体类型）：服务器无法处理请求附带的媒体格式。
    416 Requested Range Not Satisfiable（请求范围无法满足）：客户端请求的范围无效。
    417 Expectation Failed（期望失败）：服务器无法满足Expect的请求头信息。

    500 Internal Server Error（服务器内部错误）：服务器遇到错误，无法完成请求。
    501 Not Implemented（尚未实施）：服务器不支持请求的功能，无法完成请求。
    502 Bad Gateway（错误网关）：作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应。
    503 Service Unavailable（服务不可用）：由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度由服务器自己决定。
    504 Gateway Timeout（网关超时）：充当网关或代理的服务器，未及时从远端服务器获取请求。
    505 HTTP Version Not Supported（不支持的HTTP版本）：服务器不支持请求的HTTP协议的版本，无法完成处理。
</pre>



#### 8、如何实现浏览器内多个标签页之间的通信? (阿里)

<pre>
1. WebSocket、SharedWorker
2. localStorage、sessionStorage
3. postMessage,
4. BroadcastChannel
5. serviceworker
6. storage事件 -- IndexedDB
</pre>



