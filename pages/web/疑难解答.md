### 1、说一下css盒模型

 <pre>
 在html页面中的所有元素都可以看成是一个盒模型,盒模型分为两种：IE盒模型和标准W3C盒模型。
 标准W3C盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)。
 IE盒模型： 边界(margin)、内容(content 包含 边框(border)、填充(padding))。
</pre>  

### 2、css选择器有哪些

 <pre>
 1.id选择器（ # myid）
 2.类选择器（.myclassname）
 3.标签选择器（div, h1, p）
 4.相邻选择器（h1 + p）
 5.子选择器（ul > li）
 6.后代选择器（li a）
 7.通配符选择器（ * ）
 8.属性选择器（a[rel = "external"]）
 9.伪类选择器（a: hover, li: nth-child）
</pre>  

### 3、CSS优先级算法如何计算

<pre>
优先级就近原则，同权重情况下样式定义最近的生效
载入样式以最后载入的定位为准
优先级为:
!important > 行内样式 >  id > 类or属性选择器or伪类选择器 > tag
重要要加引号，并且要写在最前面，同时css属性不能简写。
</pre>

### 4、CSS3新增伪类有那些

<pre>
1.p:first-of-type 选择属于其父元素的首个 p 元素。
2.p:last-of-type  选择属于其父元素的最后 p 元素。
3.p:only-of-type  选择属于其父元素唯一的 p 元素。
4.p:only-child        选择属于其父元素的唯一子元素的 p 元素。
5.p:nth-child(2)  选择属于其父元素的第二个子元素的 p 元素。
6.:enabled  :disabled 控制表单控件的禁用状态。
7.:checked        单选框或复选框被选中。
</pre>

### 5、如何居中div

<pre>
- [x] 1.position + margin
- [x] 2.position + transform
- [x] 3.flexbox
- [x] 4.grid
</pre>

```scss
.parent-block {
  position: relative;
}

// position + margin
.center-block {
  position: absolute;
  left: 0;
  top: 0;
  right: 0;
  bottom: 0;
  margin: auto;
}

// position + transform

.center-block {
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
}

// flexbox
.parent-block {
  display: flex;
  justify-content: center;
  align-items: center;
}

// grid

.parent-block {
  display: grid;
}

.center-block {
  margin: auto;
}
```

### 6、Echarts有用过吗？常用的组件有哪些？

####

<pre>
1、title标题组件 show text link
2、tooltip 提示框组件 show trigger show formatter
3、legend 图例组件 show orient data
4、toolbox 工具栏组件 show feature saveLoad dataZoom restore
5、grid 直角坐标系内绘图网格 show top left bottom right
6、xAxis 直角坐标系 grid 中的 x 轴 show type axisLabel splitLine
7、yAxis 直角坐标系 grid 中的 y 轴 show type axisLabel splitLine
8、polar 极坐标系 show angleAxis radiusAxis
9、radar 雷达图 show indicator
10、series 系列列表 show type data
11、color 颜色映射组件 show color
12、visualMap 视觉映射组件 show type dimension min max inRange outRange
13、dataZoom 数据区域缩放组件 show type start end
14、timeline 时间轴组件 show type currentIndex autoPlay
15、axisPointer 坐标轴指示器组件 show type axis line
</pre>

### 7、uni-app

#### 1、uni-app 分包

<pre>
1、分包的作用：优化小程序的下载和启动速度；
2、小程序启动默认下载主包并启动页面，当用户进入分包时，才会下载对应的分包，下载完进行展示；
3、首先在 mainfest.json mp-weixin添加以下代码（启动分包）(第一个代码块)
4、在pages.json中加入subPackages，里面是对象(第二个代码块)
</pre>

```json lines
{
  "mp-weixin": {
    "appid": "touristappid",
    "setting": {
      "urlCheck": true,
      "checkSiteMap": false
    },
    "usingComponents": true,
    //在此处加上以下一句话
    "optimization": {
      "subPackages": true
    }
  },
}
```

```json lines
{
  "pages": [
    "pages/index/index",
    "pages/good/index",
  ],
  "subpackages": [
    {
      "root": "pagesA",
      //分包的根路径，彼此之间不可以重复
      "name": "pagesA",
      //分包的标识名字，用于预加载分包时用
      "pages": [
        //分包的路径（不预加载的时候，用户进入分包路径才会加载分包资源）
        "register/register"
      ],
      "independent": false
      //是否独立分包（可以不加载主包就独立加载的包，独能立分包不当做全局资源）
    },
    {
      "root": "pagesB",
      "name": "pagesB",
      "pages": [
        "children/addChildren"
      ],
      "independent": false
    }
  ],
  //预加载
  "preloadRule": {
    "pages/index": {
      "network": "",
      "packages": [
        "pagesA"
      ]
      // 在 pages/index 页面中预加载名为 pagesA分包内容
    }
  }
}
```

### 8、webpack

####

#### 1、webpack 打包和不打包的区别

<pre>
    1、打包：将多个文件打包成一个文件，减少网络请求次数，提高运行效率；
    2、对基础的支持不够；
</pre>

#### 2、webpack 打包原理 babel是做什么的

<pre>
    webpack 会将js 、css、image 看作一个模块，用import/require引入，
    找到入口文件，通过入口文件找到关联的依赖文件，把它们打包到一起，
    把bundle文件拆分成多个小文件，异步按需加载所需要的文件。
    如果一个文件被多个文件引用，打包时只会生成一个文件
    如果引用的文件没有被调用，不会被打包，如果引入的变量和方法没有被调用，也不会被打包。
    对于多个入口文件，假如引用了相同的代码，可以用插件把它抽离到公共文件中。
    babel的作用
    1、将es6、es7、es8等高级语法转换成低级语法，让浏览器可以运行；
    2、将react、vue等高级语法转换成低级语法，让浏览器可以运行；
    3、将typescript转换成js，让浏览器可以运行；
    4、将less、sass、stylus等转换成css，让浏览器可以运行；
</pre>

### 9、算法

#### 1、数据结构

<pre>
计算机存储或者组织数据的方式
</pre>

#### 2、空间复杂度

<pre>
1、什么时空间复杂度
    空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度，它也是程序执行时间的一部分。

2、表示法
    O(1)表示常数阶，O(logN)表示对数阶，O(n)表示线性阶，O(n^2)表示平方阶，O(2^n)表示指数阶

3、如何计算
    1、只关注循环次数最多的循环，其他循环可以忽略不计；
    2、用大O表示法表示循环
</pre>

#### 3、时间复杂度

<pre>
1、什么是时间复杂度
    时间复杂度是对一个算法执行时间的长短度量，它也是程序执行时间的一个量度。

2、表示法
    O(1)表示常数阶，O(logN)表示对数阶，O(n)表示线性阶，O(n^2)表示平方阶，O(2^n)表示指数阶

3、如何计算
    1、只关注循环次数最多的循环，其他循环可以忽略不计；
    2、用大O表示法表示循环
</pre>

```javascript
// 1、时间复杂度 O(1)
let a = 1

function fn(n) {
    return n++;
}

fn(a)
// 2、时间复杂度 O(n)
for (let i = 0; i < n; i++) {
    console.log(i)
}
// 3、时间复杂度 O(n^2)
for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
        console.log(i, j)
    }
}

// 4、时间复杂度 O(2^n)
function fn(n) {
    if (n == 1) {
        return 1
    } else {
        return 2 * fn(n - 1)
    }
}

fn(n)

// 5、空间复杂度 O(logn)
let i = 1;
const n = 6;
while (i < n) {
    i = i * 2;
}

```

#### 4、栈的介绍

<pre>
栈是一种遵从后进先出(LIFO)原则的有序集合。新添加的或待删除的元素都保存在栈的顶端。

1、栈的声明
    let stack = [];

2、栈的常用方法
    push()   添加一个或多个元素到栈顶 [1,2,3] ==> [1,2,3,4]
    pop()    移除栈顶的元素，同时返回被移除的元素 [1,2,3] ==>4
    peek()   返回栈顶的元素，不对栈做任何修改(该方法不会移除栈顶的元素，仅仅返回它) [1,2,3,4] ==> 4
    empty()  如果栈里没有任何元素就返回true，否则返回false [] ==>true  [1] ==>false

3、栈的应用场景
    函数调用栈
    浏览器的前进后退
</pre>
```javascript
// 力扣题  有效的括号 时间复杂度O(n) 空间复杂度O(n)
// 输入 '(){}' 返回true 输入'(]{}' 返回false
function fn(str) {
    const stack =[];
    for(let i=0;i<str.length; i++){
        const start = str[i];
        if(str[i] === '(' || str[i] === '{' || str[i] === '['){
            stack.push(str[i]);
        }else{
            const end = stack[stack.length - 1];
            if(start ===')' && end ==='(' ||
            start===']' && end==='[' ||
            start==='}' && end==='{'){
                stack.pop();
            }else{
                return false;
            }
        }
    }
    return stack.length === 0;
}

console.log(fn('(){}')) // true
console.log(fn('(]{}')) // false
```
```javascript
// 力扣题  删除字符串中所有相邻重复项。

function fn(str) {
    const stack =[];
    for(s of str){
        let prev = stack.pop();
        if(prev !== s){
            stack.push(prev);
            stack.push(s);
        }
    }
    return stack.join('');
}

console.log(fn('abbaca')) // ca
```
```javascript
// 力扣题  简化路径

function fn(path) {
        const stack = [];
        let str = '';
        let arr = path.split('/');
        arr.forEach(item => {
            if(item && item=== '..'){
                stack.pop();
            }else if(item && item !=='.'){
                stack.push(item);
            }
        })
        return '/' + stack.join('/');
}

console.log(fn('/home/')) // /home
console.log(fn('/../')) // /
console.log(fn('/home//foo/')) // /home/foo
console.log(fn('/a/./b/../../c/')) // /c
```
```javascript
// 力扣题  移掉K位数字

function fn(num, k) {
    if(num.length <= k){
        return '0';
    }
    let stack = [];
    for(let i = 0; i < num.length; i++){
        while(k && stack.length && stack[stack.length-1] > num[i]){
            stack.pop();
            k--;
        }
        stack.push(num[i]);
    }
    stack.splice(0, k);
    let res = stack.join('');
    return res.length ? res : '0';
}

console.log(fn('1432219',3)) // 1219
```

#### 5、队列的介绍
队列是遵循FIFO（先进先出）原则的一组有序的项。队列在尾部添加新元素，并从顶部移除元素。

### 10、为什么 javascript 是单线程？
<pre>
    JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么 JavaScript 不能有多个线程呢？
    这样可以同时执行多个任务，提高性能，减少延迟。
    
    JavaScript 单线程，与它的用途有关。作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM。
    这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，
    另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？

    所以，为了避免复杂性，从一诞生，JavaScript 就是单线程，这已经成了这门语言的核心特征，将来也不会改变.
</pre>

### 11、javascript 是单线程，怎么执行异步代码？


