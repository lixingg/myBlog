### 1、HTML
#### 1、语义化标签
-  1.语义化标签有哪些？
 <pre>
     1.header 头部标签
     2.nav 导航标签
     3.section 定义文档某个区域
     4.article 定义独立的内容
     5.aside 定义页面的侧边栏
     6.footer 尾部标签
</pre>
-  2.语义化标签的作用
 <pre>
     1.让页面的内容结构化，便于对浏览器、搜索引擎解析
     2.即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的
     3.搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO
     4.使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解
</pre>
-  3.语义化标签的缺点：
 <pre>
     语义化标签在IE6-8浏览器下无效;(解决的办法: 可以通过html5shiv让IE6-8支持H5标签)
</pre>

#### 2、Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?
 <pre>
 1.<!DOCTYPE>声明位于位于HTML文档中的第一行，处于 html 标签之前。告知浏览器的解析器，用什么文档标准解析这个文档。
 2.严格模式的排版和JS运作模式是以该浏览器支持的最高标准运行。在混杂模式中，页面以宽松的向后兼容模式显示。模拟老式浏览器的行为以防止站点无法工作。
 3.DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。
</pre>

#### 3. ::before 和 :after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用。
 <pre>
 1.单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。
 2.before元素之前。
 3.after元素之后。
 4.作用：清除浮动、样式布局上也有用。
</pre>
```scss
div:before { // 伪类 添加样式
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 20px;
  height: 20px;
  background-color: red;
  border: 1px solid #000;
  border-radius: 50%;
}

div::after { // 伪元素 清除浮动
  content: '';
  display: block;
  clear: both;
}
```

### 2、css
#### 1、说一下css盒模型

 <pre>
 在html页面中的所有元素都可以看成是一个盒模型,盒模型分为两种：IE盒模型和标准W3C盒模型。
 标准W3C盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)。
 IE盒模型： 边界(margin)、内容(content 包含 边框(border)、填充(padding))。
</pre>  

#### 2、css选择器有哪些

 <pre>
 1.id选择器（ # myid）
 2.类选择器（.myclassname）
 3.标签选择器（div, h1, p）
 4.相邻选择器（h1 + p）
 5.子选择器（ul > li）
 6.后代选择器（li a）
 7.通配符选择器（ * ）
 8.属性选择器（a[rel = "external"]）
 9.伪类选择器（a: hover, li: nth-child）
</pre>  

#### 3、CSS优先级算法如何计算

<pre>
优先级就近原则，同权重情况下样式定义最近的生效
载入样式以最后载入的定位为准
优先级为:
!important > 行内样式 >  id > 类or属性选择器or伪类选择器 > 标签 > 通配
重要要加引号，并且要写在最前面，同时css属性不能简写。
</pre>

#### 4、CSS3新增伪类有那些

<pre>
1.p:first-of-type 选择属于其父元素的首个 p 元素。
2.p:last-of-type  选择属于其父元素的最后 p 元素。
3.p:only-of-type  选择属于其父元素唯一的 p 元素。
4.p:only-child        选择属于其父元素的唯一子元素的 p 元素。
5.p:nth-child(2)  选择属于其父元素的第二个子元素的 p 元素。
6.:enabled  :disabled 控制表单控件的禁用状态。
7.:checked        单选框或复选框被选中。
</pre>

#### 5、如何居中div

<pre>
- [x] 1.position + margin
- [x] 2.position + transform
- [x] 3.flexbox
- [x] 4.grid
</pre>

```scss
.parent-block {
  position: relative;
}

// position + margin
.center-block {
  position: absolute;
  left: 0;
  top: 0;
  right: 0;
  bottom: 0;
  margin: auto;
}

// position + transform

.center-block {
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
}

// flexbox
.parent-block {
  display: flex;
  justify-content: center;
  align-items: center;
}

// grid

.parent-block {
  display: grid;
}

.center-block {
  margin: auto;
}
```

#### 6、隐藏元素的方法
```css
.box{
    /* 设置 元素消失 不占据空间*/
    display: none;
    /* 设置透明度为0，元素不可见，占据空间*/
    opacity: 0;
    /* 让元素消失，占据空间位置*/
    visibility: hidden;
    /* 相对其他盒子*/
    position: absolute;
    /* 剪切掉这块*/
    clip-path: circle(30px);
}
```

#### 7、px与rem的区别
<pre>
    px 时像素单位，显示器上最小物理点，每个像素的大小是一样的，是一个绝对单位长度。
    rem是相对单位，
    相对于根元素html的font-size，
    根元素html的font-size默认是62.5%，
    1rem = 10px = (16px * 62.5%)，
    计算公式：
    rem = px / 根元素html的font-size
</pre>

#### 8、使用link和@import引入的区别
<pre>
    1. link是HTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。
    2. link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。
    3. link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。
    4. link支持使用Javascript控制DOM去改变样式；@import不支持。
</pre>

#### 9、title与h1的区别,b与strong的区别,i与em的区别?
<pre>
    title与h1的区别  
        1.定义
            title: 概括了网站信息，可以告诉搜索引擎或者用户关于这个网站的内容主题。
            h1: 文章主题内容，告诉蜘蛛我们的网站内容是什么。
        区别：
            1.从显示上说，title 显示在网页标题上，h1 显示在网页内容上。
            2.从seo上说，title 比 h1 添加重要（title > h1）。
        场景上：
            网站的logo都是用 h1 标签包裹的
</pre>
<pre>
    b与strong的区别
        1.定义
            b: 实体标签，表示粗体文本，没有实际意义，只是视觉上的加粗。
            strong: 逻辑标签，用来加强字符的语气，表示重要文本，有实际意义，搜索引擎会重点抓取。
        区别：
            1.b 没有语义，只是视觉上的加粗，没有实际意义，搜索引擎不会重点抓取。
            2.strong 是有语义的，表示重要文本，有实际意义，搜索引擎会重点抓取。
        场景上：
            1.b 标签一般用于表示一些小字，如：导航栏、侧边栏等。
            2.strong 标签一般用于表示一些重要文本，如：文章标题、文章内容等。
</pre>
<pre>
    i与em的区别
       1.定义
           i: 实体标签，表示斜体文本，没有实际意义，只是视觉上的倾斜。
           em: 逻辑标签，用来强调字符，表示重要文本，有实际意义，搜索引擎会重点抓取。
       区别：
          1.i 没有语义，只是视觉上的倾斜，没有实际意义，搜索引擎不会重点抓取。
          2.em 是有语义的，表示重要文本，有实际意义，搜索引擎会重点抓取。
       场景上：
          i 更多的用在字体图标，em 术语上 （医药、生物）。
</pre>  

#### 10、img 标签的 title 和 alt 有什么区别？
<pre>
    1、显示不同：
        1.title: 鼠标悬停在img上显示的文字。
        2.alt: 图片加载失败时显示的文字。
    2、SEO搜索引擎优化：
        1.title: 给图片起个名字，方便搜索引擎抓取图片信息。
        2.alt: 图片加载失败时显示的文字，方便搜索引擎抓取图片信息。
</pre> 

#### 11、png、jpg、gif 有什么区别，如何选择使用哪种图片格式？

<pre>
    1.png: 无损压缩，尺寸体积要比jpg/jpeg的大，适合做小图标，支持透明度，支持256色，支持动画。
    2.jpg: 采用压缩算法，有一点失真，比png要小，适合做中大图片，不支持透明度，支持256色，不支持动画。
    3.gif: 一般是做动图的。支持透明度，支持256色，支持动画。
    4.webp: 同时支持有损或者无损压缩，相同质量的图片，webp具有更小的体积，兼容性不是特别好。
</pre>

#### 12、line-height 和 height 有什么区别？

<pre>
    1.line-height: 行高，是行距，是基线到基线之间的距离。（每一行文字的高，如果换行则整个盒子高度会增大（行数 * 行高））
    2.height: 元素的高度，是元素边框到元素边框之间的距离。（死值，就是盒子的高度）
</pre>

#### 13、哪些属性可以继承？

<pre>
    1.文字系列属性：font-size font-family color font-weight font-style text-decoration text-align 
                  text-indent vertical-align line-height letter-spacing word-spacing text-shadow text-transform direction
    2.元素可见性：visibility
    3.表格布局属性：caption-side border-collapse empty-cells
    4.列表布局属性：list-style-type list-style-image list-style-position list-style
    5.光标属性：cursor
    6.页面样式属性：page page-break-before page-break-after page-break-inside
    7.声音样式属性：speak speak-punctuation speak-numeral speak-header speak-delay speak-rate speak-volume
</pre>

#### 14、用css 绘制三角形

<pre>
    1.border-width: 10px;
    2.border-style: solid;
    3.border-color: transparent transparent red transparent;
</pre>

#### 15、display 有哪些值，表示什么

<pre>
    1.block         把某个元素转换成块元素。
    2.none          此元素会被隐藏。
    3.inline        把某个元素转换成内联元素。
    4.inline-block  把某个元素转换成行内块元素。
    5.list-item     象块类型元素一样显示，并添加样式列表标记。
    6.table         此元素会作为块级表格来显示（类似 table），表格前后带有换行符。
    7.inherit       规定应该从父元素继承 display 属性的值。
</pre>

#### 16、对BFC规范（块级格式化上下文：block formatting context）的理解？
<pre>
    BFC就是页面上一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。

    1. 了解BFC: 块级格式化上下文。
    2. BFC原则: 如果一个元素具有BFC，那么内部元素再怎么弄，都不会影响到外部元素。
    3. 哪些元素会具有BFC: 根元素、float属性不为none、position为absolute或fixed、display为inline-block、overflow不为visible。
</pre>

#### 17、清除浮动有哪些方法

<pre>
    1. 触发BFC : 给父元素添加overflow:hidden;
    2. 结尾处加空div标签 clear:both;
    3. 使用伪类 父元素:after{ clear:both; display:block; content:""; }
</pre>

#### 18、在网页中字体使用奇数还是偶数？为什么？

<pre>
    偶数
    1、方便开发，布局、计算像素方便。
    2、偶数像素的图片，在放大后不会出现模糊。
    3、让文字在浏览器上表现的更好看。
</pre>

#### 19、有几种定位？ 分别是根据什么定位的

<pre>
    1. static 默认值，没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。
    2. relative 生成相对定位的元素，相对于其正常位置进行定位。
                如果有top, bottom, left, right ==》left top
    3. absolute 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。
                如果有top, bottom, left, right ==》top, bottom, left, right 
    4. fixed 生成固定定位的元素，相对于浏览器窗口进行定位。
    5. sticky 生成粘性定位的元素，元素先按照普通文档流定位，然后相对于该元素在流中的flow根元素进行定位。
</pre>

#### 20、双飞翼布局
```html
<div class="container">
    <div class="main">main</div>
    <div class="left">left</div>
    <div class="right">right</div>
</div>
```
```css
.container {
    width: 100%;
}
.main {
    float: left;
    width: 100%;
    margin: 0 200px;
    background: #f00;
}
.left {
    float: left;
    width: 200px;
    margin-left: -100%;
    background: #0f0;
}
.right {
    float: left;
    width: 200px;
    margin-left: -200px;
    background: #00f;
}
.clearfix::after {  
    content: "";
    display: block;
    clear: both;
}
```

#### 21、什么是css reset?

-    reset.css 是一个CSS文件，它包含了一组重置样式（reset styles），用于将浏览器默认的样式重置为一致的样式。
    在编写CSS样式时，如果需要重置浏览器默认样式，可以引用[reset.css](https://meyerweb.com/eric/tools/css/reset/)文件。
    这样可以确保所有浏览器在渲染页面时都使用一致的样式，避免由于浏览器默认样式不同而导致的样式差异。

-  为了增强跨浏览器渲染的一致性，我们推荐使用 [Normalize.css](https://necolas.github.io/normalize.css/)，这是由 Nicolas Gallagher 和 Jonathan Neal 维护的一个CSS 重置样式库。

-  [bootcss 官网](https://v3.bootcss.com/css/)

#### 22、CSS Sprites 是什么？ 有什么优缺点？（雪碧图|精灵图）

-  CSS Sprites是一种CSS图像合并技术，用于将多个小图标合并成一张大图，从而减少HTTP请求
-  优点：
    1. 减少HTTP请求数，提高页面加载速度
    2. 减少图片大小，提高页面加载效率
    3. 提高页面渲染性能，减少页面加载时间
    4. 提高页面响应速度，提高用户体验
-  缺点：
    1. 维护成本高，需要手动维护合并后的图片
    2. 图片合并后体积较大，增加页面加载时间
    3. 图片合并后，图片无法单独使用，只能作为背景图使用
-  使用：
```css
.container{
    /* 使用雪碧图添加背景图片*/
    /*background: url('./images/sprite.png') no-repeat;*/
    /* 移动雪碧图位置确定哪个雪碧图*/
    /*background-position: -100px -100px;*/
}
```

#### 23、重绘和回流
```scss
.container{
    visibility: hidden; // 产生重绘
    display: none; // 产生回流 + 重绘
  // 产生回流一定会造成重绘，但重绘不一定会造成回流。
}
```
-  重绘（Repaint）：当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color
    等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。
-  回流（Reflow）：当页面中元素的尺寸、结构、位置、显隐或触发某些属性时，浏览器会重新计算元素的几何属性，
    并重新构造渲染树，这个过程称为回流。

#### 24、opacity和rgba区别
-  opacity 取值范围 0 - 1 之间，0表示完全透明，1表示完全不透明。
-  rgba r表示红色，g表示绿色，b表示蓝色，取值可以为正整数或者百分数，a表示透明度，取值范围 0 - 1 之间，0表示完全透明，1表示完全不透明。
-  区别：
-  opacity 作用于元素，以及元素的所有后代元素（会被子元素继承），而 rgba 只作用于元素本身（不会被子元素继承）。
-  opacity 不会触发浏览器的重排和重绘，而 rgba 会导致浏览器重绘。

#### 25、rem和em区别
-  rem 相对于根元素（html 元素）的 font-size 进行计算，em 相对于其父元素的 font-size 进行计算
-  rem 值不会被浏览器缓存，而 em 值会被浏览器缓存
-  rem 值在移动端使用更加合适，而 em 值在 PC 端使用更加合适

### 3、Javascript
#### 1、为什么 javascript 是单线程？
<pre>
    JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么 JavaScript 不能有多个线程呢？
    这样可以同时执行多个任务，提高性能，减少延迟。
    
    JavaScript 单线程，与它的用途有关。作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM。
    这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，
    另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？

    所以，为了避免复杂性，从一诞生，JavaScript 就是单线程，这已经成了这门语言的核心特征，将来也不会改变.
</pre>

#### 2、javascript 是单线程，怎么执行异步代码？
<pre>
    JavaScript 语言的执行环境是“单线程”的，也就是说，一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，
    再执行后面一个任务，以此类推。
    1、同步任务
        同步任务都在主线程上执行，形成一个执行栈。
    2、异步任务（宏任务、微任务）
        除了同步任务以外，其他任务都属于异步任务，又可以分成两种：
        1. 普通事件，如click、resize等。
        2. 资源加载，如load、error等。
        3. 定时器，包括setInterval、setTimeout等。
        4.promise对象。
        5.async/await。
    3、宏任务
        script(整体代码), setTimeout, setInterval, setImmediate(Node.js 环境), requestAnimationFrame(浏览器环境)，
        I/O, UI rendering(浏览器环境)，网络请求
    4、微任务
        process.nextTick(Node.js 环境), Promise.then(null), Promise.catch(null), Promise.finally(null
        promise 回调 、DOM变动观察器
    5、事件循环
        1. 执行一个宏任务（栈中没有就从事件队列中获取）
        2. 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中
        3. 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
        4. 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染
        5. 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）
        6. 如此循环
    6、任务队列
        1. 同步任务都在主线程上执行，形成一个执行栈。
        2. 主线程之外，还存在一个"任务队列"。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。
        3. 一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异
        步任务，于是结束等待状态，进入执行栈，开始执行。
        4. 主线程不断重复上面的第三步。
    7、JS执行流程
        1. 主线程读取JS代码，此时是在同步环境，形成对应的堆和执行栈；
        2. 主线程遇到异步任务，会推给异步线程进行处理；
        3. 异步线程处理完毕后，将对应的异步任务推到任务队列中；
        4. 主线程查询任务队列，执行微任务，将其按照顺序执行，全部执行完毕。
        5. 主线程查询任务队列，执行宏任务，取得第一个宏任务，执行完毕。
        5. 主线程不断重复第四步。
        
    异步任务相关的事件回调函数都在任务队列中等待。
    一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会按次序读取任务队列，将可运行的
    异步任务添加到可执行栈中，开始执行。
</pre>

#### 3、promise

<pre>
    1、Promise的含义
        Promise是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现
        ，ES6将其写进了语言标准，统一了用法，原生提供了Promise对象。 

    2、Promise解决了哪些问题
        1. 回调地狱
        2. 多个异步操作的串行执行
        3. 并行执行异步操作，且可以获得所有异步操作的结果
    3、Promise有几种状态
        1. pending: 初始状态，既不是成功，也不是失败状态。
        2. fulfilled: 意味着操作成功完成。
        3. rejected: 意味着操作失败。
    4、Promise的构造函数是做什么的？
        1. 创建一个Promise实例，需要传入一个函数作为参数，该函数的两个参数分别是resolve和reject。
        2. 该函数会立即执行。
</pre>

#### 4、generator

<pre>
    1、Generator的含义
        Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。
        Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。
        执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成器。
        形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；
        二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。
    2、Generator的用法
        1. 基本用法
            function* helloWorldGenerator() {
                yield 'hello';
                yield 'world';
                return 'ending';
            }

            var hw = helloWorldGenerator();
            console.log(hw.next()); // { value: 'hello', done: false }
            console.log(hw.next()); // { value: 'world', done: false }
            console.log(hw.next()); // { value: 'ending', done: true }
            console.log(hw.next()); // { value: undefined, done: true }
        2. yield表达式
            function* fibonacci() {
                let [prev, curr] = [0, 1];
                for (;;) {
                    yield curr;
                    [prev, curr] = [curr, prev + curr];
                }
            }

            for (let n of fibonacci()) {
                if (n > 1000) break;
                console.log(n);
            }
        3. 与Iterator接口的关系
            Generator 函数就是遍历器生成函数。
            Generator 函数除了状态机，还是一个遍历器对象生成函数。
            Generator 函数可以不用任何修饰符调用，这是因为它就是遍历器对象生成函数。
            Generator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也继承了Generator函数的prototype对象上的方法。
        4. 作为对象属性的Generator函数
            var myIterable = {};
            myIterable[Symbol.iterator] = function* () {
                yield 1;
                yield 2;
                yield 3;
            };

            [...myIterable] // [1, 2, 3]
            let obj = {};
            obj[Symbol.iterator] = function* () {
                yield 1;
                yield 2;
                yield 3;
            };

            obj[Symbol.iterator] // 1
            obj // {1: 2, 2: 3, 3: 4}
        5. Generator函数的this
            Generator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也继承了Generator函数的prototype对象上的方法。
            Generator 函数也不能跟new命令，否则会抛出一个错误。
</pre>

#### 5、JS延迟加载有哪些方式

<pre>
    defer和async、动态创建DOM方式（通过documen.write）、按需异步载入js
    
    defer和async的区别
    defer要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；
    async一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。
</pre>

#### 6、JS数据类型

<pre>
    基本数据类型：String,Number,Boolean,Undefined,Null,Symbol,bigint
    引用数据类型：Object
    NaN 是一个数值类型，但不是一个具体的数字；
</pre>

#### 7、数据类型的隐式转换

```javascript
console.log(true + 1); // 2 number
console.log('name' + true); // 'nametrue' string
console.log(undefined +  1); // NaN number
console.log(typeof NaN); // number
console.log(typeof  undefined); // undefined
```

#### 8、null 和 undefined 的区别

<pre>
    1. 最初设计js的时候借鉴了java语言，java中含有null,就设计了null。
    2. null会被隐式转换为0，很不容易发现错误。
    3. 现有null后有undefined,设计undefined是为了填补之前的坑。
    具体区别：
    javascript的最初版本是这样区分的，null表示一个"无"的对象（空对象指针），转为数值时为0，
    undefined表示一个"无"的值（空值指针），转为数值时为NaN。
</pre>
```javascript
console.log(Number(null)) // 0
console.log(Number(undefined)) // NaN
```

#### 9、== 和 === 有什么不同

-  == : 只进行值的比较，不进行数据类型的比较
-  string == number || boolean || ...都会隐式转换，
-  通过valueOf转换（valueOf() 方法通常由JavaScript自动调用，并不显式地出现在代码中）
-  隐式转换：虽然两个值比较是相等 但是数据类型还是不相同，不做显示只做比较。
-  === : 除了比较值，还比较数据类型（建议使用三等）

```javascript
console.log(1 == '1') // true
console.log(1 === '1') // false

console.log(null == undefined) // true
console.log(null === undefined) // false

console.log(true == 1) // true
console.log(true === 1) // false

console.log([1,2] == '1,2'); // true
console.log([1,2] === '1,2'); // false
```

#### 10、JS 作用域

-  1.除了函数外，js 是没有块级作用域的。

```javascript
function fn(){
    var a = 10;
}

console.log(a); // 报错

for(var i=0;i<10;i++){}
console.log(i); // 10

if(true){
    var b = 11;
}
console.log(b); // 11
```

-  2.作用域链：内部可以访问外部变量，外部不能访问内部变量。
   注意：如果内部有，优先查找内部，如果内部没有就查找外部的。

```javascript
function fn1(){
    var a = 10;
    function fn2(){
        console.log(a);
    }
    fn2();
}
fn1(); // 10
```
-  3.注意声明变量是用var还是没有写（没有写默认全局，注册在window上），
```javascript
function fn(){
    var a= b = 10
    console.log(a); // 10
    console.log(b); // 10
}
console.log(a); // a is not defined
console.log(b); // 10
```
-  4.js有变量提升的机制（变量悬挂声明）
-  5.变量提升只提升声明，不提升赋值
```javascript
var a = '2222'
function fn(){
    console.log(a); // undefined
    var a = '1111'
    console.log(a); // 1111
}
fn(); // undefined
// 如果没有声明a 那么会报错 a is not defined
```
-  6.优先级：声明变量> 声明普通函数> 参数> 变量提升
```javascript
// 声明变量> 声明普通函数
var a = '2222'
function a(){}
console.log(a); // 2222

// 普通声明函数是不看写函数的时候顺序

b() // 声明前面调用
function b(){
    console.log('b');
}

b() // 声明后面调用

// 声明普通函数> 参数

function a(a){
    console.log(a); // f a(){}
    function a(){}
}
a(1111);

// 参数> 变量提升

function fun(a){
    console.log(a); // 1111
    var a = '33333'
}
fun(1111); // 1111

// 声明普通函数> 变量提升
console.log(a); // f a(){}
var a = '33333'
function a(){}

// 变量提升并赋值再次赋值
function fn(){
    a = 10;
    console.log(a); // 10
    var a =20;
    console.log(a); // 20
}
fun()
```

#### 11、JS对象
```javascript
// 1.对象通过new操作符构建出来的，所以对象之间不相等（除了引用外）。
console.log([1,2,3] ===[1,2,3]); // false

// 2.对象注意：引用类型（共同地址）
var a = {name:'zs'}
var b = a;
b.name = 'ls';
console.log(a.name); // ls

// 3.对象key都是字符串， 对象属性为对象时会转换为字符串 [object Object]
var a = {}
var c={key:'c'}
var d ={key:'d'}
a[c]= 'c';
a[d]= 'd';
for(var i in a){ 
    console.log(i) // [object Object]
    console.log(typeof i); // string
}
console.log(a[c]); // d

// 4.对象如何查找属性或者方法
console.log([1,2,3].constructor) // f Array() == new Array()
// 每个函数都自带一个属性prototype，prototype的属性constructor指向构造函数
// 注意：对象拥有__proto__属性，指向构造函数的prototype
// new Fun 该Fun构造函数的原型指向对象（new Fun)的原型
// 实例的指针指向构造函数的原型
function Fun (){};
var obj = new Fun();
console.log(obj.constructor) // f Fun()
obj.__proto__ == Fun.prototype;
console.log(obj.__proto__ == Fun.prototype); // true

function Fn(){
    this.a= '函数中添加的属性'
}

Fn.prototype.say = function(){
    console.log('我是原型中的方法')
}

var fn = new Fn();
fn.a='我是对象本身属性'
fn.__proto__a="我是对象原型中添加的属性"
Object.a="我是Object对象中添加的属性"
console.log(fn.a)
// 对象本身属性 -> 构造函数中添加的属性 -> 对象原型中添加的属性 -> 构造函数原型中查找 -> 对象上一层的原型中查找
 ```

#### 12、this 指向
```javascript
function fn(){
    console.log(this)
}

fn() // window
```

```javascript
function Foo(){
    getName = function (){console.log(1)} // window上的的方法
    return this;
}

Foo.getName=function (){console.log(2)}; // Foo的自有方法

Foo.prototype.getName=function (){console.log(3)}; // Foo原型上的方法

var getName = function (){console.log(4)}; // 全局变量

function getName(){console.log(5)}; // 

Foo.getName();       // 2
getName();           // 4
Foo().getName();     // 1
getName();           // 1
new Foo().getName(); // 3

// 1. 函数执行，首先看函数名前面是否有"."，
// 1.1 有的话， "."前面是谁，this就指向谁
// 1.2 没有的话，this就指向window
var o ={
    a:10,
    b:{
        fn:function (){
            console.log(this.a);
            console.log(this)
        }
    }
}
o.b.fn() // undefined b

// 2. 自执行函数中的this指向window
~function (){console.log(this)}();
```

```javascript
window.name = 'ByteDance';
function A(){
    this.name = 'A';
}
A.prototype.getA = function (){
    console.log(this);
    return this.name + 1;
};

let a = new A();
let funcA = a.getA; // window.funcA =function (){console.log(this);return this.name + 1;}
funcA(); // window
```

```javascript
var length = 10;
function fn() {
    return this.length + 1;
}
var obj = {
    length: 5,
    test1: function () {
        return fn();
    }
};
obj.test2 = fn;
console.log(obj.test1()); // 11
console.log(fn() === obj.test2()) // 11 6 false
console.log(obj.test1() ===obj.test2()) // 11 6 false
console.log(obj.test2()); // 6
```

#### 13、JS判断变量是不是数组，你能写出哪些方法？
-  1.isArray
-  2.instanceof
-  3.constructor
-  4.isPrototypeOf
-  5.Object.prototype.toString.call
```javascript
var arr = [1, 2, 3];
console.log(arr instanceof Array); // true
console.log(Array.isArray(arr)); // true
console.log(arr.constructor === Array); // true
console.log(Array.prototype.isPrototypeOf(arr)) // true
console.log(Object.prototype.toString.call(arr) === '[object Array]'); // true
````

#### 14、slice作用 ，splice是否改变原数组
-  1.slice() 方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。
-  2.splice() 方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。
```javascript
// slice 浅拷贝
var arr = [1, 2, 3, 4, 5,{a:1,b:2},[1,2,3]];
var arrCopy = arr.slice(); // arrCopy 是arr的副本
arrCopy.push(6); // arrCopy 是 [1, 2, 3, 4, 5,{a:1,b:2},[1,2,3], 6]
console.log(arr); // 输出 [1, 2, 3, 4, 5,{a:1,b:2},[1,2,3]]
arrCopy[5].a = 3; // arrCopy 是 [1, 2, 3, 4, 5,{a:3,b:2}
console.log(arr); // 输出 [1, 2, 3, 4, 5,{a:3,b:2}
arrCopy[6][0]=4; // arrCopy 是 [1, 2, 3, 4, 5,{a:3,b:2,c:4},[4,2,3],6]
console.log(arr); // 输出  [1, 2, 3, 4, 5,{a:3,b:2,c:4},[4,2,3],6]

// 1.slice 截取 3 ~ (arr.length-1)所有数据
let arr3 = arr.slice(3); //  输出 [4, 5,{a:1,b:2},[1,2,3], 6]

// 2.slice 从前到后截取 0 ~ 3 数据
let arr1 = arr.slice(0,3);
console.log(arr1); // 输出 [1, 2, 3]

// 3.slice 从后往前截取 (arr.length-1) ~ (arr.length-1-3)数据
let arr2 = arr.slice(-3);
console.log(arr2); // 输出 [{a:3,b:2},[1,2,3],6]


```
```javascript
// splice 深拷贝 
var arr = [1, 2, 3, 4, 5,{a:1,b:2},[1,2,3]];

var arrCopy = arr.splice(0,4); // arrCopy 是arr的副本
arrCopy.push(6); // arrCopy 是 [1, 2, 3, 4, 5,6]
console.log(arr); // 输出 [{a:1,b:2},[1,2,3]]
arr[0].a = 3; // arrCopy 是 [1, 2, 3, 4, 5,6]
console.log(arr); // 输出  [{a:3,b:2},[1,2,3]]

// 1.splice 从前往后截取 3 ~ (arr.length-1)所有数据
let arr3 = arr.splice(3); //  输出 [4, 5,{a:3,b:2},[1,2,3],6]
console.log(arr); // 输出 [1, 2, 3]

// 2.splice 从前到后截取 0 ~ 3 数据
let arr4 = arr.splice(0,3); // 
console.log(arr4); // 输出 [1, 2, 3]
console.log(arr); // 输出 [4, 5,{a:3,b:2},[1,2,3],6]

// 3.splice 从后往前截取 (arr.length-1) ~ (arr.length-1-3)数据
let arr5 = arr.splice(-3); //
console.log(arr5); // 输出 [{a:1,b:2},[1,2,3],6]
console.log(arr); // 输出 [1, 2, 3, 4, 5,]

// 4.splice 修改数据
arr.splice(1,1,100); // 从索引为1的位置开始删除1个元素，并插入100
console.log(arr); // 输出 [1, 100, 2, 3, 4, 5]

// 5.splice 添加数据
arr.splice(0,0,66); // 从索引为0的位置开始删除0个元素，并插入66 等同于 unshift
console.log(arr); // 输出 [66, 1, 100, 2, 3, 4, 5]

```

#### 15、JS 数组去重
-  1、利用ES6 Set去重
```javascript
let arr = [1, 2, 3, 4, 5, 1, 2, 3, 4, 5];

function unique(arr) {
    return [...new Set(arr)] || Array.from(new Set(arr))
}
const arr2 = unique(arr);
console.log(arr2); // [1, 2, 3, 4, 5]
```
-  2、利用for + indexOf 去重（ES5中最常用）
```javascript
let arr = [1, 2, 3, 4, 5, 1, 2, 3, 4, 5];

function unique(arr) {
    const arr1 =[]
    for(let i = 0; i < arr.length; i++) {
        if(arr1.indexOf(arr[i])=== -1){
            arr1.push(arr[i])
        }
    }
    return arr1;
}

const arr2 = unique(arr);
console.log(arr2); // [1, 2, 3, 4, 5]
```
-  3、利用for + includes 去重
```javascript
let arr = [1, 2, 3, 4, 5, 1, 2, 3, 4, 5];

function unique(arr) {
    const arr1 =[]
    for(let i = 0; i < arr.length; i) {
        if(!arr1.includes(arr[i])){
            arr1.push(arr[i])
        }
    }
    return arr1;
}

const arr2 = unique(arr);
console.log(arr2); // [1, 2, 3, 4, 5]
```
-  4、利用for + sort 去重
```javascript
let arr = [1, 2, 3, 4, 5, 1, 2, 3, 4, 5];

function unique(arr) {
    arr = arr.sort();
    const arr1 =[];
    for(let i = 0; i < arr.length; i++) {
        if(arr[i] !== arr[i-1]){
            arr1.push(arr[i])
        }
    }
    return arr1;
}

const arr2 = unique(arr);
console.log(arr2); // [1, 2, 3, 4, 5]
```
-  5、利用filter 去重
```javascript
    
let arr = [1, 2, 3, 4, 5, 1, 2, 3, 4, 5];

function unique(arr) {
    return arr.filter((item, index) => {
        return arr.indexOf(item) === index;
    })
}

const arr2 = unique(arr);
console.log(arr2); // [1, 2, 3, 4,5]
```

#### 16、多维数组最大值
```javascript

function maxValue(arr) {
    let max = -Infinity;
    function getMax(arr) {
        for(let i = 0; i < arr.length; i++) {
            if(Array.isArray(arr[i])) {
                getMax(arr[i]);
            } else {
                max = Math.max(max, arr[i]);
            }
        }
    }
    getMax(arr);
    return max;
} 

const arr = [1, 2, [3, 4, [5, 6, [7, 8]]]];
console.log(maxValue(arr)); // 8
```

#### 17、数组扁平化
```javascript

function flatten(arr) {
    return arr.reduce((pre, cur) => {
        return pre.concat(Array.isArray(cur) ? flatten(cur) : cur);
    }, []);
}

const arr = [1, 2, [3, 4, [5, {a:1},6, [7, 8]]]];
console.log(flatten(arr)); // [1, 2, 3, 4, 5, 6, 7, 8]
```

#### 18、给字符串新增方法实现功能
```javascript
// 字符拼接前缀
let str = '你好'
String.prototype.addPrefix = function (str) {
    return str + this
}
console.log(str.addPrefix('hello')) // hello你好
```

#### 19、字符串出现最多次数的字符及次数
```javascript
let str = 'abcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdef'
function maxStr(str) {
    let obj = {};
    for(let i = 0; i < str.length; i++) {
        if(!obj[str[i]]) {
            obj[str[i]] = 1;
        } else {
            obj[str[i]]++;
        }
    }
    let max = 0;
    let maxStr = '';
    for(let key in obj) {
        if(obj[key] > max) {
            max = obj[key];
            maxStr = key;
        }
    }
    return maxStr + ':' + max;
}
console.log(maxStr(str)) // a:7
```

#### 20、new 操作符具体做了什么

```javascript
// 模拟new操作符 封装new方法
function myNew(fn, ...args) {
// 1.创建一个空对象
    const obj = {}
// 2.将这个空对象的原型指向构造函数的原型
//     obj.__proto__ = fn.prototype
    Object.setPrototypeOf(obj, fn.prototype)
// 3.将这个空对象赋值给函数中的this
    const result = fn.apply(obj, args)
// 4.判断构造函数的返回值类型
// 如果是引用类型([],{})，返回这个引用类型的对象
    if (typeof result === 'object' && result !== null) {
        return result
    } else {
// 如果是值类型(string,boolean,number...)，返回创建的对象
        return obj
    }
}

function Fun(age) {
    this.age = age;
    return {} || [] // 返回引用类型 {} || []
    return 123 || '124' || true  //等基本类型 返回值类型是值类型 {age:18}
}

console.log(myNew(Fun, 18))
```

#### 21、实现一个深拷贝

```javascript
function deepClone(obj) {
    // 如果是值类型，直接返回
    if(typeof obj !== 'object' || obj === null) {
        return obj
    }
    // 如果是引用类型，创建一个新的对象
    let result = Array.isArray(obj) ? [] : {}
    for(let key in obj) {
        if(obj.hasOwnProperty(key)) {
            result[key] = deepClone(obj[key])
        }
    }
    return result
}
```

#### 22、实现一个深比较

```javascript
function deepCompare(obj1, obj2) {
    // 判断是否是引用类型
    if (typeof obj1 !== 'object' || typeof obj2 !== 'object' || obj1 === null || obj2 === null) {
        return obj1 === obj2
    }
}
```

#### 23、闭包

-  1.闭包是什么
<pre>
    闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，
    通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。
</pre>
```javascript
function fn() {
    let num = 10
    return function() {
        num++
        console.log(num)
    }
}
let f = fn();
f() // 11
```
-  2.闭包可以解决什么问题
<pre>
    闭包可以缓存数据，如果一个函数在多次调用时，每次都需要重新计算，
    那么可以使用闭包将计算的结果缓存起来，避免每次调用时都重新计算。
</pre>
```javascript
const lis = document.querySelectorAll('li')
for(let i = 0; i < lis.length; i++) {
    // 使用立即执行函数将i作为变量传递给闭包进行缓存
    // 待同步函数执行完后，执行宏任务这样i就能拿到当前值而不是最后值
    // 从而实现点击时弹出对应索引的效果
    // 闭包的缺点是常驻内存，会增大内存使用量，使用不当很容易导致内存泄露 （IE浏览器）
    (function(i){
        lis[i].onclick = function() {
            alert(i)
        }
    })(i)
}
```
-  3.闭包的缺点
<pre>
    闭包会常驻内存，会增大内存使用量，使用不当很容易导致内存泄露。
    
    解决方案：
    
    1.及时释放闭包占用的内存 (闭包函数设置为null)
    2.在退出函数之前，将不使用的局部变量全部删除 （设置为null)
</pre>
```javascript
function fn() {
    let num = 10
    return function() {
        num++
        console.log(num)
    }
}
let f = fn();
f() // 11
// 及时释放闭包占用的内存
f = null
```

#### 24、原型链

-  1.原型可以解决什么问题
<pre>
    原型可以实现函数和实例之间的继承，共享属性和方法。
</pre>

-  2.谁有原型
<pre>
    函数拥有：prototype
    对象拥有：__proto__
</pre>
```javascript
function Person() {}
console.log(Person.prototype) // 输出：Person {}
const person = new Person();
console.log(person.__proto__) // 输出：Person {}
```
-  3.原型链的构成
<pre>
    原型链由原型对象组成，原型对象由构造函数组成，构造函数由实例组成。
</pre>

-  4.对象查找属性和方法的顺序
<pre>
    对象自身查找 -> 构造函数中查找 -> 对象原型中查找 -> 构造函数原型中查找 -> 当前原型的原型中查找 -> ... -> 直到最顶层为止（null）。
    这样一个查找顺序，形成类似于链条的形式，我们称之为原型链。
</pre>

#### 25、JS创建类几种方法

-  1.工厂模式
<pre>
    工厂模式是一种最简单的方法，通过函数来封装以特定接口创建对象的细节。
    缺点：对象无法识别，因为所有的实例都是Object的实例。
</pre>
```javascript
function createPerson(name, age, job) {
    let o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = function() {
        console.log(this.name);
    }
    return o;
}
const person1 = createPerson('Nicholas', 29, 'Software Engineer');
const person2 = createPerson('Greg', 27, 'Doctor');
```
-  2.构造函数模式
<pre>
    构造函数模式可以解决工厂模式中对象无法识别的问题。
    缺点：每个方法都要在每个实例上重新创建一遍。
</pre>
```javascript
function Person(name, age, job) {
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = function() {
        console.log(this.name);
    }
}
const person1 = new Person('Nicholas', 29, 'Software Engineer');
const person2 = new Person('Greg', 27, 'Doctor');
```
-  3.原型模式
<pre>
    原型模式是JavaScript中最简单的创建对象的方式。
    缺点：所有属性和方法都共享，无法向构造函数传递参数。
</pre>
```javascript
function Person() {}
Person.prototype.name = 'Nicholas';
Person.prototype.age = 29;
Person.prototype.job = 'Software Engineer';
Person.prototype.sayName = function() {
    console.log(this.name);
}
const person1 = new Person();
person1.sayName(); // 输出：Nicholas
const person2 = new Person();
person2.sayName(); // 输出：Nicholas
```
-  4.组合使用构造函数模式和原型模式
<pre>
    组合使用构造函数模式和原型模式是创建自定义类型的最常见方式。
    构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。
</pre>
```javascript
function Person(name, age, job) {
    this.name = name;
    this.age = age;
    this.job = job;
}
Person.prototype.sayName = function() {
    console.log(this.name);
}
const person1 = new Person('Nicholas', 29, 'Software Engineer');
const person2 = new Person('Greg', 27, 'Doctor');
```
-  5.使用ES6 class

<pre>
    ES6 class是JavaScript正式引入的类语法，完全可以取代之前的原型模式。
</pre>
```javascript
class Person {
    constructor(name, age, job) {
        this.name = name;
        this.age = age;
        this.job = job;
    }
    sayName() {
        console.log(this.name);
    }
}
const person1 = new Person('Nicholas', 29, 'Software Engineer');
const person2 = new Person('Greg', 27, 'Doctor');
```

#### 26、JS 继承有哪些

-  1.ES6 class extends
<pre>
    ES6 class通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。
</pre>
```javascript
class Animal {
    constructor(name) {
        this.name = name;
    }
    sayName() {
        console.log('My name is ' + this.name);
    }
}
class Dog extends Animal { // extends关键字 继承父类
    constructor(name, breed) {
        super(name); // 调用父类的constructor(name)
        this.breed = breed;
    }
    sayBreed() {
        console.log('My breed is ' + this.breed);
    }
}
const dog = new Dog('Terra', 'Bull Terrier');
dog.sayName(); // 输出 'My name is Terra'
dog.sayBreed(); // 输出 'My breed is Bull Terrier'
```

-  2.原型链继承
<pre>
    原型链是实现继承的主要方法，其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。
    简单回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。
    那么，假如我们让原型对象等于另一个类型的实例，结果会怎么样呢？显然，此时的原型对象将包含一个指向另一个原型的内部指针，
    相应地，另一个原型中也包含着一个指向另一个构造函数的内部指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，
    就构成了实例与原型的链条。这就是所谓原型链的基本概念。
</pre>
```javascript
function Parent() {
    this.name = 'kevin';
}
Parent.prototype.getName = function () {
    console.log(this.name);
}
function Child() {
    this.age = 18;
}
// 继承Parent
Child.prototype = new Parent();
Child.prototype.constructor = Child;
var child1 = new Child();
console.log(child1.getName()); // kevin
```
-  3.构造函数式继承
<pre>
    在解决原型中包含引用类型值所带来问题的时候，一种常见的做法是：
    在构造函数中，所有变量都先初始化好，然后把this指向这个实例，最后再返回实例。
</pre>
```javascript
function Parent() {
    this.names = ['kevin', 'daisy'];
}
function Child() {
    Parent.call(this);
}
var child1 = new Child();
var child2 = new Child();
child1.names.push('yayu');
console.log(child1.names); // ["kevin", "daisy", "yayu"]
console.log(child2.names); // ["kevin", "daisy"]
```

-  4.组合继承
<pre>
    组合继承就是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。
    其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。
    这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。
</pre>
```javascript
function Parent(name) {
    this.name = name;
    this.colors = ['red', 'blue', 'green'];
}
Parent.prototype.getName = function () {
    console.log(this.name);
}
function Child(name, age) {
    // 继承属性
    Parent.call(this, name);
    this.age = age;
}
// 继承方法
Child.prototype = new Parent();
Child.prototype.constructor = Child;
var child1 = new Child('kevin', '18');
console.log(child1.name); // kevin
console.log(child1.age); // 18
child1.colors.push('black');
console.log(child1.colors); // ["red", "blue", "green", "black"]    

var child2 = new Child('daisy', '20');
console.log(child2.name); // daisy
console.log(child2.age); // 20
console.log(child2.colors); // ["red", "blue", "green"]
```

-  5.原型式继承
<pre>
    道格拉斯在《JavaScript模式》中提出的一种不涉及严格定义类型和构造函数的继承方式。
    他的想法是借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。
</pre>
```javascript
function createObj(o) {
    function F() {}
    F.prototype = o;
    return new F();
}
```

-  6.寄生式继承
<pre>
    寄生式（parasitic）继承是与原型式继承紧密相关的一种思路。
    寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，
    最后再像真的是它做了所有工作一样返回对象。
</pre>
```javascript
function createObj(o) {
    var clone = object(o); // 通过调用函数创建一个新对象
    clone.sayName = function() { // 以某种方式来增强这个对象
        console.log('hi');
    };
    return clone; // 返回这个对象
}
```

-  7.寄生组合式继承
<pre>
    通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。
    基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们需要的仅是超类型原型的一个副本。
    本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。
</pre>
```javascript
function objectCopy(obj) {
    function Fun() { };
    Fun.prototype = obj;
    return new Fun();
}

function inheritPrototype(child, parent) {
    let prototype = objectCopy(parent.prototype);
    prototype.constructor = child;
    Child.prototype = prototype;
}

function Parent(name) {
    this.name = name;
    this.hoby = ['唱', '跳']
}

Parent.prototype.showName = function () {
    console.log('my name is：', this.name);
}

function Child(name, age) {
    Parent.call(this, name);
    this.age = age;
}

inheritPrototype(Child, Parent);
Child.prototype.showAge = function () {
    console.log('my age is：', this.age);
}

let child1 = new Child("mjy", 18);
child1.showAge(); // 18
child1.showName(); // mjy
child1.hoby.push("rap");
console.log(child1.hoby); // ['唱', '跳', 'rap']

let child2 = new Child("yl", 18);
child2.showAge(); // 18
child2.showName(); // yl
console.log(child2.hoby); // ['唱', '跳']
```

#### 27、call、apply、bind的区别
-  1.共同点：功能一致
<pre>
    改变函数体内的this指向
    call语法： 函数.call(this指向, 参数1, 参数2, ...)
    apply语法：函数.apply(this指向, [参数1, 参数2, ...])
    bind语法： 函数.bind(this指向, 参数1, 参数2, ...)
</pre>
```javascript
let str = '你好'; 
let obj = {
    str: 'obj内的str'
} 

function fn() {
    console.log(this.str);
}
fn(); // 你好
fn.call(obj); //obj内的str
fn.apply(obj); //obj内的str
const a = fn.bind(obj); // fn(){console.log(this.str)}
a(); //obj内的str
```
-  2.不同点：
<pre>
    call和apply会立即调用函数，bind不会立即调用函数，而是返回一个新函数
    call和apply传递参数的方式不同，call传递参数的方式是： 函数.call(this指向, 参数1, 参数2, ...)
    apply传递参数的方式是： 函数.apply(this指向, [参数1, 参数2, ...])
    bind传递参数的方式是： 函数.bind(this指向, 参数1, 参数2, ...)
</pre>
```javascript
function fn(a, b) {
    console.log(a + b);
}
fn.call(null, 1, 2); // 3
fn.apply(null, [1, 2]); // 3
fn.bind(null, 1, 2)(); // 3
```
-  3.使用场景
<pre>
    call和apply的使用场景：当一个对象没有某个方法，但是其他的有，我们可以借助call或apply用其它对象的方法来操作。
    bind的使用场景：当一个函数被多次调用时，bind可以减少重复代码。
</pre>
```javascript
// 用apply 获取数组最大值
let arr = [1, 2, 3, 4, 5];
Math.max.apply(null, arr); // 5
Math.max.call(null, ...arr); // 数组解构获取 5

// 用bind 例子：获取其他元素的实例及属性
const btn1 = document.getElementById('btn1');
const btn2 = document.getElementById('btn2');
btn1.onclick = function() {
    console.log(this); // 输出btn1
}
btn1.onclick = function() {
    console.log(this); // 输出btn2
}.bind(btn2);
```

#### 28、sort背后的原理是什么
-  1.sort的原理
<pre>
    sort() 方法用于对数组的元素进行排序，默认排序顺序是根据字符串Unicode码点。
    sort() 方法会直接修改原数组！
    V8 引擎sort 函数只给出了两种排序 插入排序（InsertionSort） 和 快速排序（QuickSort），
    数量小于10的数组使用插入排序（InsertionSort），大于10的数组使用快速排序（QuickSort）。
    之前版本是：插入排序和快速排序
    现在版本是：冒泡排序
</pre>

-  2.语法
<pre>
    arr.sort(sortBy)；参数sortBy可选。规定排序顺序。必须是函数。
    注：
    如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码进行排序。
    要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。
    如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。
</pre>

-  3.例子
```javascript
// 默认码点排序
var arr = [10, 20, 1, 2];
arr.sort(); // 1,10,2,20
```
```javascript
// 定义排序规则函数 从小到大排序
var arr = [10, 20, 1, 2];
arr.sort(function(a, b){return a - b}
); // 1,2,10,20
```
```javascript
// 对象数组排序
var arr = [{name: 'zs', age: 20}
, {name: 'ls', age: 30}
, {name: 'ww', age: 25}
];

function compare(property){
    return function(a,b){
        var value1 = a[property];
        var value2 = b[property];
        return value1 - value2;
    }
}
arr.sort(compare('age')); // {name: 'ww', age: 25},{name: 'zs', age: 20},{name: 'ls', age: 30}  
```

#### 29、冒泡排序
-  1.冒泡排序的原理
<pre>
    冒泡排序是一种简单的排序算法。它重复地遍历要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。
    遍历数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。
    这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。
</pre>
-  2.冒泡排序的实现
```javascript
function bubbleSort(arr) {
    var len = arr.length;
    for (var i = 0; i < len - 1; i++) {
        for (var j = 0; j < len - 1 - i; j++) {
            if (arr[j] > arr[j+1]) {        // 相邻元素两两对比
                var temp = arr[j+1];        // 元素交换
                arr[j+1] = arr[j];
                arr[j] = temp;
            }
        }
    }
    return arr;
}
bubbleSort([6, 1, 2, 7, 9, 3, 4, 5, 10, 8]);
```

#### 30、深拷贝和浅拷贝
-  1.共同点：复制
-  2.浅拷贝：只复制引用，而未复制真正的值
-  3.深拷贝：复制真正的值

```javascript
// 案例：浅拷贝 赋值
var arr =[1,2,3,4]
var arr1 = arr;
arr1[0] = 10;
console.log(arr); // [10,2,3,4]
```

```javascript
// 案例：浅拷贝 Object.assign 
var obj = {
    name: 'zs',
    age: 20,
    info: {
        address: '北京',
        desc: '技术宅'
    }}

var obj1 = Object.assign(obj);
obj1.info.address = '上海';
console.log(obj.info.address); // 上海
```

```javascript
// 案例：深拷贝 JSON.parse(JSON.stringify(obj))
var obj = {
    name: 'zs',
    age: 20,
    info: {
        address: '北京',
        desc: '技术宅'
    }}

var obj1 = JSON.parse(JSON.stringify(obj));
obj1.info.address = '上海';
console.log(obj.info.address); // 北京
// 注意：只能拷贝属性 不能拷贝方法
```

```javascript
//案例：深拷贝 递归

function deepClone(obj, hash = new WeakMap()) {
    if (obj === null) return obj; // 如果是null或者undefined我就不进行拷贝操作
    if (obj instanceof Date) return new Date(obj);
    if (obj instanceof RegExp) return new RegExp(obj);
    // 可能是对象或者普通的值  如果是函数的话是不需要深拷贝
    if (typeof obj !== "object") return obj;
    // 是对象的话就要进行深拷贝
    if (hash.get(obj)) return hash.get(obj);
    let cloneObj = new obj.constructor();
    // 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身
    hash.set(obj, cloneObj);
    for (let key in obj) { // 循环引用对象
        if (obj.hasOwnProperty(key)) {
            // 实现一个递归拷贝
            cloneObj[key] = deepClone(obj[key], hash);
        }
    }
    return cloneObj;
}

var obj = {
    name: 'zs',
    age: 20,
    info: {
        address: '北京',
        desc: '技术宅'
    }}
var obj1 = deepClone(obj);
obj1.info.address = '上海';
console.log(obj.info.address); // 北京
```

### 4、nodeJS

### 5、Vue

### 6、React

### 7、小程序

### 8、uni-app

#### 1. uni-app 分包

<pre>
1、分包的作用：优化小程序的下载和启动速度；
2、小程序启动默认下载主包并启动页面，当用户进入分包时，才会下载对应的分包，下载完进行展示；
3、首先在 mainfest.json mp-weixin添加以下代码（启动分包）(第一个代码块)
4、在pages.json中加入subPackages，里面是对象(第二个代码块)
</pre>

```json lines
{
  "mp-weixin": {
    "appid": "touristappid",
    "setting": {
      "urlCheck": true,
      "checkSiteMap": false
    },
    "usingComponents": true,
    //在此处加上以下一句话
    "optimization": {
      "subPackages": true
    }
  },
}
```

```json lines
{
  "pages": [
    "pages/index/index",
    "pages/good/index",
  ],
  "subpackages": [
    {
      "root": "pagesA",
      //分包的根路径，彼此之间不可以重复
      "name": "pagesA",
      //分包的标识名字，用于预加载分包时用
      "pages": [
        //分包的路径（不预加载的时候，用户进入分包路径才会加载分包资源）
        "register/register"
      ],
      "independent": false
      //是否独立分包（可以不加载主包就独立加载的包，独能立分包不当做全局资源）
    },
    {
      "root": "pagesB",
      "name": "pagesB",
      "pages": [
        "children/addChildren"
      ],
      "independent": false
    }
  ],
  //预加载
  "preloadRule": {
    "pages/index": {
      "network": "",
      "packages": [
        "pagesA"
      ]
      // 在 pages/index 页面中预加载名为 pagesA分包内容
    }
  }
}
```

### 9、Echarts
#### 1. 常用的配置有哪些？

####

<pre>
1、title标题组件 show text link
2、tooltip 提示框组件 show trigger show formatter
3、legend 图例组件 show orient data
4、toolbox 工具栏组件 show feature saveLoad dataZoom restore
5、grid 直角坐标系内绘图网格 show top left bottom right
6、xAxis 直角坐标系 grid 中的 x 轴 show type axisLabel splitLine
7、yAxis 直角坐标系 grid 中的 y 轴 show type axisLabel splitLine
8、polar 极坐标系 show angleAxis radiusAxis
9、radar 雷达图 show indicator
10、series 系列列表 show type data
11、color 颜色映射组件 show color
12、visualMap 视觉映射组件 show type dimension min max inRange outRange
13、dataZoom 数据区域缩放组件 show type start end
14、timeline 时间轴组件 show type currentIndex autoPlay
15、axisPointer 坐标轴指示器组件 show type axis line
</pre>

### 10、webpack

####

#### 1. webpack 打包和不打包的区别

<pre>
    1、打包：将多个文件打包成一个文件，减少网络请求次数，提高运行效率；
    2、对基础的支持不够；
</pre>

#### 2. webpack 打包原理 babel是做什么的

<pre>
    webpack 会将js 、css、image 看作一个模块，用import/require引入，
    找到入口文件，通过入口文件找到关联的依赖文件，把它们打包到一起，
    把bundle文件拆分成多个小文件，异步按需加载所需要的文件。
    如果一个文件被多个文件引用，打包时只会生成一个文件
    如果引用的文件没有被调用，不会被打包，如果引入的变量和方法没有被调用，也不会被打包。
    对于多个入口文件，假如引用了相同的代码，可以用插件把它抽离到公共文件中。
    babel的作用
    1、将es6、es7、es8等高级语法转换成低级语法，让浏览器可以运行；
    2、将react、vue等高级语法转换成低级语法，让浏览器可以运行；
    3、将typescript转换成js，让浏览器可以运行；
    4、将less、sass、stylus等转换成css，让浏览器可以运行；
</pre>

### 11、算法

#### 1、数据结构

<pre>
计算机存储或者组织数据的方式
</pre>

#### 2、空间复杂度

<pre>
1、什么时空间复杂度
    空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度，它也是程序执行时间的一部分。

2、表示法
    O(1)表示常数阶，O(logN)表示对数阶，O(n)表示线性阶，O(n^2)表示平方阶，O(2^n)表示指数阶

3、如何计算
    1、只关注循环次数最多的循环，其他循环可以忽略不计；
    2、用大O表示法表示循环
</pre>

#### 3、时间复杂度

<pre>
1、什么是时间复杂度
    时间复杂度是对一个算法执行时间的长短度量，它也是程序执行时间的一个量度。

2、表示法
    O(1)表示常数阶，O(logN)表示对数阶，O(n)表示线性阶，O(n^2)表示平方阶，O(2^n)表示指数阶

3、如何计算
    1、只关注循环次数最多的循环，其他循环可以忽略不计；
    2、用大O表示法表示循环
</pre>

```javascript
// 1、时间复杂度 O(1)
let a = 1

function fn(n) {
    return n++;
}

fn(a)
// 2、时间复杂度 O(n)
for (let i = 0; i < n; i++) {
    console.log(i)
}
// 3、时间复杂度 O(n^2)
for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
        console.log(i, j)
    }
}

// 4、时间复杂度 O(2^n)
function fn(n) {
    if (n == 1) {
        return 1
    } else {
        return 2 * fn(n - 1)
    }
}

fn(n)

// 5、空间复杂度 O(logn)
let i = 1;
const n = 6;
while (i < n) {
    i = i * 2;
}

```

#### 4、栈的介绍

<pre>
栈是一种遵从后进先出(LIFO)原则的有序集合。新添加的或待删除的元素都保存在栈的顶端。

1、栈的声明
    let stack = [];

2、栈的常用方法
    push()   添加一个或多个元素到栈顶 [1,2,3] ==> [1,2,3,4]
    pop()    移除栈顶的元素，同时返回被移除的元素 [1,2,3] ==>4
    peek()   返回栈顶的元素，不对栈做任何修改(该方法不会移除栈顶的元素，仅仅返回它) [1,2,3,4] ==> 4
    empty()  如果栈里没有任何元素就返回true，否则返回false [] ==>true  [1] ==>false

3、栈的应用场景
    函数调用栈
    浏览器的前进后退
</pre>
```javascript
// 力扣题  有效的括号 时间复杂度O(n) 空间复杂度O(n)
// 输入 '(){}' 返回true 输入'(]{}' 返回false
function fn(str) {
    const stack =[];
    for(let i=0;i<str.length; i++){
        const start = str[i];
        if(str[i] === '(' || str[i] === '{' || str[i] === '['){
            stack.push(str[i]);
        }else{
            const end = stack[stack.length - 1];
            if(start ===')' && end ==='(' ||
            start===']' && end==='[' ||
            start==='}' && end==='{'){
                stack.pop();
            }else{
                return false;
            }
        }
    }
    return stack.length === 0;
}

console.log(fn('(){}')) // true
console.log(fn('(]{}')) // false
```
```javascript
// 力扣题  删除字符串中所有相邻重复项。

function fn(str) {
    const stack =[];
    for(s of str){
        let prev = stack.pop();
        if(prev !== s){
            stack.push(prev);
            stack.push(s);
        }
    }
    return stack.join('');
}

console.log(fn('abbaca')) // ca
```
```javascript
// 力扣题  简化路径

function fn(path) {
        const stack = [];
        let str = '';
        let arr = path.split('/');
        arr.forEach(item => {
            if(item && item=== '..'){
                stack.pop();
            }else if(item && item !=='.'){
                stack.push(item);
            }
        })
        return '/' + stack.join('/');
}

console.log(fn('/home/')) // /home
console.log(fn('/../')) // /
console.log(fn('/home//foo/')) // /home/foo
console.log(fn('/a/./b/../../c/')) // /c
```
```javascript
// 力扣题  移掉K位数字

function fn(num, k) {
    if(num.length <= k){
        return '0';
    }
    let stack = [];
    for(let i = 0; i < num.length; i++){
        while(k && stack.length && stack[stack.length-1] > num[i]){
            stack.pop();
            k--;
        }
        stack.push(num[i]);
    }
    stack.splice(0, k);
    let res = stack.join('');
    return res.length ? res : '0';
}

console.log(fn('1432219',3)) // 1219
```

#### 5、队列的介绍
队列是遵循FIFO（先进先出）原则的一组有序的项。队列在尾部添加新元素，并从顶部移除元素。

### 12、websocket

#### 1、websocket是什么

<pre>
    WebSocket是一种在单个TCP连接上进行全双工通讯的协议。
    WebSocket使得客户端和服务器可以进行双向通信。
    在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。
</pre>

#### 2、websocket与http的区别

<pre>
    WebSocket是一个持久化的协议，相对于HTTP这种非持久的协议来说。
    WebSocket是双向通信协议，在建立连接之后，WebSocket的server与client都能主动向对方发送或接收数据。
    HTTP是单向的通信协议，也就是请求-响应模式，请求完成之后，连接就关闭了，要进行下一次通信，必须重新建立连接。
</pre>

#### 3、websocket与http2.0的区别

<pre>
    WebSocket和HTTP2.0有着本质的不同，HTTP2.0是一个应用层协议，WebSocket是一个独立的协议。
    WebSocket是一种双向通信协议，在建立连接之后，WebSocket的server与client都能主动向对方发送或接收数据。
    HTTP2.0是一个应用层协议，HTTP2.0的request和response都遵循HTTP协议的格式。
    HTTP2.0是双向通信协议，通信过程中可以同时发送多个请求或响应，而且这些请求或响应都是独立成行的，不必等待其中一个请求或响应完成后再发送下一个请求或响应。
    HTTP2.0采用二进制格式传输数据，比HTTP1.x的文本格式数据更高效；
    HTTP2.0支持服务器推送，即服务端可以主动向客户端推送数据。
    HTTP2.0实现了一些机制让客户端与服务器之间可以进行有效的交互。
</pre>

#### 4、websocket心跳机制

<pre>
        
</pre>

```javascript
    // 客户端的连接 ws服务器
    var ws = new WebSocket('wss://echo.websocket.org');
    // open 事件
    ws.onopen = function(evt) {
        console.log("Connection open ...");
        ws.send("Hello WebSocket!");
    };
    // message 事件
    ws.onmessage = function(evt) {
        console.log( "Received Message: " + evt.data);
        ws.close();
    };
    // close 事件
    ws.onclose = function(evt) {
        console.log("Connection closed.");
    };
    // 心跳机制
    setInterval(function(){
        ws.send("ping");
    }, 5000);
    // 断线重连 重连时间要大于心跳时间
    ws.onclose = function(){
        console.log("连接断开，重连中...");
        // 重连
        ws = new WebSocket('wss://echo.websocket.org');
    };
    ws.onopen = function(){
        console.log("重连成功");
    };
```
```javascript
// 封装成类使用
class Socket {
    wsUrl;
   constructor(wsUrl:any) {
        this.wsUrl = wsUrl;
    }
    modeCode={
       // webSocket 消息类型
        MSG:"message",
        // 心跳类型
        HEART_BEAT:"heart_beat",
    }
    ws:any=null;
    webSocketState:boolean=false;
    heartBeat ={
        // 心跳连接的时间设置
        time:5 * 1000, // 心跳时间间隔
        timeOut:3 * 1000, // 心跳超时间隔
        reconnect:10 * 1000, // 重连时间间隔
    }
    reconnectTimer:any=null; // 断开重连时间器
    /**
     * 连接 ws
     * */
    connectWebSocket(){
        this.ws = new WebSocket(this.wsUrl);
       this.init();
    }

    /**
     * 心跳初始函数
     */
    
    startHeartBeat(time:number | string){
        setTimeout(()=>{
            this.ws.send(JSON.stringify({
                ModeCode:this.modeCode.HEART_BEAT,
                msg:new Date(),
            }))
            this.waitingServer()
        },time)
    }
    
    /**
     * 延迟等待服务端响应，通过webSocketState判断是否连接成功
     * */
    waitingServer(){
        this.webSocketState = false;
        setTimeout(()=>{
            if (this.webSocketState){
                this.startHeartBeat(this.heartBeat.time)
                return;
            }
            console.log("心跳无响应，已断开...");
            try{
                this.ws.close();
            }catch(e){
                console.log("关闭连接失败...");
            }
            this.reconnectWebSocket();
        },
        this.heartBeat.timeOut)
    }

    /**
     * 重连操作
     */
    reconnectWebSocket(){
        this.reconnectTimer = setTimeout(()=>{
            console.log("尝试重新连接...");
            this.reconnectWs();
        },this.heartBeat.reconnect)
    }
    
    /**
     * 初始化
     * */
   init(){
       this.ws.addEventListener('open',()=>{
           // socket状态设置为连接， 作为后面的断线重连的拦截器
           this.webSocketState = true;
           // 是否启动心跳级制
           this.heartBeat && this.heartBeat.time ?
           this.startHeartBeat(this.heartBeat.time) : null;
           console.log("连接成功...");
       })
       this.ws.addEventListener('message',(e)=>{
           console.log("收到消息：",e.data);
           const data = JSON.parse(e.data);
           switch (data.ModeCode){
               case this.ModeCode.heartBeat:
                   console.log("收到心跳..."+data.msg);
                   break;
               case this.ModeCode.MSG:
                   console.log("收到消息..."+data.msg);
                   break;
           }
       })
       this.ws.addEventListener('close',(e)=>{
           this.webSocketState = false;
           console.log("连接已关闭...",e);
       })
       this.ws.addEventListener('error',()=>{
           this.webSocketState = false;
           console.log("连接出错...",e);
           this.reconnectWebSocket(); //重连
       })
    }
    reconnectWs(){
       if(!this.ws){
           // 第一次执行，初始化
           this.connectWebSocket();
       }
       if(this.ws && this.reconnectTimer){
           // 防止多个webSocket同时执行
           clearTimeout(this.reconnectTimer);
           this.ws.reconnectTimer = null;
           this.connectWebSocket()
       }
    }

    /**
     *  发送消息
     */
    sendMessage(data:any){
        this.ws.send(JSON.stringify(data));
    }

    /**
     * 在其他需要socket的地方主动关闭socket
     */
    closeWebSocket(e:any){
        console.log("主动关闭socket...",e);
        this.ws.close();
        clearTimeout(this.reconnectTimer);
        this.webSocketState = false;
    }
}

export default Socket;
```
```javascript
/**
 * 使用
 * @type {Socket}
 */
import Socket from './socket';

const socket = new Socket("url");
socket.init();
socket.sendMessage("Hello WebSocket!");
```

#### 5、webSocket如何兼容低浏览器版本？
-  1.使用WebSocket的替代方案：在低版本浏览器中，可以使用一些基于HTTP的长轮询或流技术来实现类似于WebSocket的功能。
     常见的替代方案包括Comet、SSE（Server-Sent Events）和Flash Socket等。根据浏览器的支持情况选择相应的技术。

-  2.使用Polyfill库：可以使用一些Polyfill库来模拟WebSocket的功能。这些库会自动检测浏览器是否支持WebSocket，
     如果不支持，则会使用替代方案来提供类似的功能。常见的Polyfill库有Socket.IO和SockJS等。

-  3.使用Flash插件：Flash插件在低版本浏览器中广泛支持并且提供了类似WebSocket的功能。可以使用一些库或框架（如web-socket-js）
     来通过Flash插件实现WebSocket的功能。

```javascript
if ('WebSocket' in window) {
    // 支持 WebSocket
} else {
    // 该浏览器不支持 WebSocket
    // 采用轮询方式检测消息
}
```

### 13、浏览器
#### 1、localStrage、sessionStrage、cookie的区别
- 1.相同点：
<pre>
    在客户端存放数据
</pre>
- 2.不同点：
<pre>
    localStrage、sessionStrage、cookie都是浏览器端存储数据的方式，区别如下：
    1、存储位置不同：
        localStrage、sessionStrage存储在浏览器端，而cookie存储在服务端。
    2、存储大小不同：
        localStrage、sessionStrage、cookie存储大小不同，cookie一般不能超过4k，而localStrage、sessionStrage可以存储不超过5M的数据。
    3、有效时间不同：
        sessionStrage: 仅在当前浏览器窗口关闭前有效。[窗口或浏览器关闭就没了]
        localStrage: 始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据。
        cookie: 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。[必须要在服务环境下才能设置，如：本地启的vue项目或者线上服务]
    4、与服务器端通信不同：
        localStrage、sessionStrage在设置的有效期内一直有效，而cookie在设置的有效期内一直有效，即使窗口或浏览器关闭。
</pre>

```javascript
 // 存储
    localStorage.setItem("key", "value");
    sessionStorage.setItem("key", "value");
    document.cookie = "key=value";
    // 读取
    var value = localStorage.getItem("key");
    var value = sessionStorage.getItem("key");
    var value = document.cookie.replace(/(?:(?:^|.*;\s*)key\s*\=\s*([^;]*).*$)|^.*$/, "$1");
    // 删除
    localStorage.removeItem("key");
    sessionStorage.removeItem("key");
    document.cookie = "key=;expires=Thu, 01 Jan 1970 00:00GMT;" // expires设置过期时间
    // 清除所有
    localStorage.clear();
    sessionStorage.clear();
    document.cookie = "key=;expires=Thu, 01 Jan 1970 00:00GMT;";
```
#### 2、浏览器缓存

<pre>

    浏览器缓存分为强缓存和协商缓存。

    1、强缓存：
        浏览器直接从缓存中读取资源，不会向服务器发送请求。
        强缓存可以通过设置两种HTTP Header实现：Expires和Cache-Control。
        Expires是HTTP/1.0的产物，表示缓存到期时间，但是它受限于本地时间，如果修改了本地时间，可能会造成缓存失效。
        Cache-Control是HTTP/1.1的产物，在Expires出现后，Cache-Control成为主要控制缓存失效的header。
        Cache-Control的几个常用字段：
            public：所有内容都将被缓存（客户端和代理服务器都可缓存）
            private：所有内容只有客户端可以缓存，Cache-Control的默认取值
            no-cache：客户端缓存内容，但是是否使用缓存需要经过协商缓存来验证决定
            no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存
            max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效

    2、协商缓存：
        如果缓存过期了，那么浏览器会发送请求到服务器，服务器根据请求中的相关标识来判断是否命中缓存。
        如果命中缓存，则返回304和Not Modified状态码，浏览器根据此状态码来从缓存中读取资源。
        如果未命中缓存，则返回200和请求的结果资源，并且会更新缓存中的资源。
        协商缓存可以通过设置两种HTTP Header实现：Last-Modified和ETag。
        Last-Modified：标识请求资源在服务器上的最新修改时间。
        ETag：标识请求资源的唯一标识符。

</pre>

#### 3、浏览器输入URL到页面展示的详细过程

<pre>
    1、DNS解析：
        浏览器缓存-&gt;系统缓存-&gt;路由器缓存-&gt;ISP DNS缓存-&gt;递归搜索

    2、TCP连接：
        三次握手：
            客户端发送SYN包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；
            服务器收到SYN包，必须确认客户的SYN(ack=j+1)，同时自己也发送一个SYN包(syn=k)，即SYN+ACK包，此时服务器进入SYN_RECV状态；
            客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

    3、发送HTTP请求：
        客户端向服务器发送一个HTTP请求，请求被发送到服务器的默认端口(80)

    4、服务器处理请求：
        服务器端请求处理完毕后，向客户端发送HTTP响应，客户端接收HTTP响应并渲染页面

    5、关闭TCP连接：
        客户端获取到HTML文档后，会关闭TCP连接，或者等待一段时间后发起TCP连接

</pre>

#### 4、HTTP1.0和HTTP1.1的区别

<pre>

    1、长连接：
        HTTP1.0默认是短连接，也就是说每次请求都要重新建立一次连接，用完就断开。
        HTTP1.1默认是长连接，也就是说，默认会保持连接。

    2、缓存处理：
        HTTP1.0没有指定缓存的处理方式，依赖浏览器或者用户自己进行处理。
        HTTP1.1新增了缓存处理，如缓存请求头字段Cache-Control、Last-Modified、Etag等。

    3、带宽优化及网络连接的使用：
        HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，
        并且不支持断点续传功能，HTTP1.1则在请求头引入了Range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），
        这样就方便了开发者自由的选择以便充分利用带宽和连接。

    4、错误通知的管理：
        在HTTP1.1中，新增了24个错误状态响应码，
        如409（Conflict）表示请求的资源与资源的当前状态发生冲突；
        410（Gone）表示服务器上的某个资源被永久性的删除。

    5、Host头处理：
        在HTTP1.0中，每个请求的header中都有Host信息，例如：Host:www.google.com。
        而在HTTP1.1中，Host信息是必须的，如果客户端没有给出这个信息，服务器将不会处理该请求。

</pre>

#### 5、HTTP2.0的新特性

<pre>

    1、二进制分帧：
        HTTP2.0将报文分成帧（frame）进行传输，和HTTP1.x一样，HTTP2.0也需要客户端和服务器同时支持，才能实现二进制分帧，
        实现二进制分帧的关键是帧头，它由帧类型（type）、帧长度（length）、帧标志（flags）三个字段组成，其中帧长度指的是整个帧的长度，
        而不包括帧头本身的长度。

    2、多路复用：
        多路复用是指在单个连接上可以同时传送多个请求或响应，即可以同时发送多个请求或响应，它的最大优点就是减少了建立和关闭连接的消耗和延迟，
        节省了带宽资源。

    3、头部压缩：
        HTTP2.0实现了头部的压缩功能，即HTTP2.0在客户端和服务器端使用“HPACK”算法来压缩头部，使数据体积变小，提高传输速度。

    4、服务器推送：
        HTTP2.0服务器能够更快的将资源发送给客户端，这被称为服务器推送。

</pre>

#### 6、HTTP请求报文和响应报文的具体格式

<pre>

    请求报文格式：
        请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。

    响应报文格式：
        状态行、响应头部、空行和响应数据四个部分组成。

</pre>

#### 7、HTTP常见状态码

<pre>

    200 OK：客户端请求成功。
    201 Created：已创建，成功请求并创建了新的资源。
    202 Accepted：已接受，已经接受请求，但未处理完成。
    203 Non-Authoritative Information（非授权信息）：请求成功。但返回的meta信息不在原始的服务器，而是一个副本。
    204 No Content：请求成功，但返回的meta信息为空（用null表示）。
    205 Reset Content（重置内容）：服务器处理成功，用户终端（例如：浏览器）应重置文档视图。
    206 Partial Content（部分内容）：服务器成功处理了部分GET请求。

    300 Multiple Choices（多种选择）：请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择。
    301 Moved Permanently（永久移动）：请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。
        今后任何新的请求都应使用新的URI代替。
    302 Found（找到）：临时性重定向。
    303 See Other（查看其他）：临时性重定向，且总是使用GET方法请求新的URI。
    304 Not Modified（未修改）：自从上次请求后，请求的资源未修改过，服务器返回此状态码时，不会包含任何响应的主体部分。
    305 Use Proxy（使用代理）：请求的资源必须通过代理访问。
    306 (Unused)：已经被废弃的代码，将来有可能使用，现在尚未使用。
    307 Temporary Redirect（临时重定向）：临时重定向，与302 Found类似。使用GET方法请求新的URI，但是POST方法提交的请求报文中的地址不会改变。

    400 Bad Request（错误请求）：请求报文存在语法错误。
    401 Unauthorized（未授权）：请求需要有通过HTTP认证的认证信息。
    402 Payment Required（支付要求）：该状态码是为了将来可能的需求而预留的。
    403 Forbidden（禁止）：服务器收到请求，但是拒绝提供服务。
    404 Not Found（未找到）：请求的资源不存在，或不可用。
    405 Method Not Allowed（方法禁用）：客户端请求中的方法被禁止。
    406 Not Acceptable（不可接受）：服务器无法根据客户端请求的内容特性完成请求。
    407 Proxy Authentication Required（代理服务器认证要求）：请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权。
    408 Request Timeout（请求超时）：服务器完成请求处理，但请求超时。
    409 Conflict（冲突）：通常和PUT请求有关。由于请求和资源的当前状态相冲突，因此请求不能成功。
    410 Gone（已删除）：被请求的资源已从这个地址转移，不再可用。
    411 Length Required（需要有效长度）：服务器无法处理客户端发送的不带Content-Length的请求信息。
    412 Precondition Failed（先决条件失败）：请求信息的先决条件错误。
    413 Request Entity Too Large（请求实体过大）：由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，
        服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息。
    414 Request-URI Too Long（请求URI过长）：请求的URI过长（URI通常为网址），服务器无法处理。
    415 Unsupported Media Type（不支持的媒体类型）：服务器无法处理请求附带的媒体格式。
    416 Requested Range Not Satisfiable（请求范围无法满足）：客户端请求的范围无效。
    417 Expectation Failed（期望失败）：服务器无法满足Expect的请求头信息。

    500 Internal Server Error（服务器内部错误）：服务器遇到错误，无法完成请求。
    501 Not Implemented（尚未实施）：服务器不支持请求的功能，无法完成请求。
    502 Bad Gateway（错误网关）：作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应。
    503 Service Unavailable（服务不可用）：由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度由服务器自己决定。
    504 Gateway Timeout（网关超时）：充当网关或代理的服务器，未及时从远端服务器获取请求。
    505 HTTP Version Not Supported（不支持的HTTP版本）：服务器不支持请求的HTTP协议的版本，无法完成处理。
</pre>



#### 8、如何实现浏览器内多个标签页之间的通信? (阿里)
<pre>
1. WebSocket、SharedWorker
2. localStorage、sessionStorage
3. postMessage,
4. BroadcastChannel
5. serviceworker
6. storage事件 -- IndexedDB
</pre>

IndexedDB 是什么？
<pre>
IndexedDB 是一种低级、原始的存储机制，用于客户端存储大量结构化数据。
这些数据具有键值对的形式存储，并且具有类似文件系统的目录结构以及事务机制。
</pre>

### 14、页面兼容
#### 1、如何关闭IOS键盘首字母大写？
```html
<!-- 设置属性 autocapitalize off-->
<input type="text" autocapitalize="off" />
```

#### 2、怎么让Chrome支持小于12px 的文字？
-  chrome浏览器默认字体大小是 16px;(每种浏览器的默认字体大小不同)
-  设置body的font-size为10px，通过css3缩放方法实现。
```scss
.font{
  display: inline-block;
  -webkit-transform: scale(0.8);
}
```

#### 3、怎么去掉ios系统中元素被触摸时产生的半透明灰色遮罩
```scss
a,button,input,textarea{
  -webkit-tap-highlight-color: rgba(0,0,0,0);
}
```

#### 4、能改变webkit表单输入框placeholder的颜色值吗
```scss
input::-webkit-input-placeholder {
  color: #AAAAAA;
}
```




#### 5、禁止触发系统菜单和长按选中
```scss
html,body{
  // 禁止触发系统菜单
  -webkit-touch-callout: none;
  // 禁用 长按选中
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}
```

#### 6、自适应（适配）
-  1.自适应解决方案： 淘宝无限适配[移动端]（lib-flexible） + 布局单位使用rem
-  2.配置如下：
```json lines
// 项目中引入插件
npm install lib-flexible --save-dev  // 监听页面变化设置根节点font-size 大小
// npm install px2rem-loader --save-dev // 将px 转成 rem
```

```js
// main.js 入口文件引入依赖
// 
import 'lib-flexible/flexible'
// import 'px2rem-loader/src/postcss-px2rem'
```

```js
// 配置px2rem-loader
// 在build文件中找到util.js，将px2rem-loader添加到cssLoaders中，如：
const cssLoader = {
    loader: 'css-loader',
    options: {
        minimize: process.env.NODE_ENV === 'production',
        sourceMap: options.sourceMap
    }
}
const px2remLoader = {
    loader: 'px2rem-loader',
    options: {
        remUnit: 75
    }
}
```

```js
// 在generateLoaders方法中添加px2remLoader
function generateLoaders (loader, loaderOptions) {
　　const loaders = options.usePostCSS ? [cssLoader, postcssLoader, px2remLoader] : [cssLoader, px2remLoader]
    if (loader) {
　　loaders.push({
　　loader: loader + '-loader',
　　options: Object.assign({}, loaderOptions, {
　　sourceMap: options.sourceMap
　　})
　　})
　　}

    if (options.extract) {
　　return ExtractTextPlugin.extract({
　　use: loaders,
　　fallback: 'vue-style-loader'
　　})
　　} else {
　　return ['vue-style-loader'].concat(loaders)
　　}
}

```

```js
// vue.config.js
module.exports = {
    css: {
        loaderOptions: {
            css: {},
            postcss: {
                plugins: [
                    require('postcss-px2rem')({
                        // 以设计稿1920为例， 1920 / 10 = 192
                        remUnit: 192
                    }),
                ]
            }
        }
    },
};

```

```js
// vite.config.js
import { fileURLToPath, URL } from 'node:url'
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import px2rem from "postcss-px2rem"  // 分辨率适配
export default defineConfig({
  plugins: [vue()],
  define: {
    'process.env': {},
  },
  // css 分辨率适配
  css: {
    postcss: {
      plugins: [
        px2rem({
          remUnit: 192
        })
      ]
    }
  }
})

```
```html
<!-- 移动端适配 index.html -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">

<style lang="scss">
    *{
        margin: 0;
        padding: 0;
    }
    html{
        font-size:16px ; // 设置html font-size
    }
    div{
        font-size:1rem; // 使用 1rem == 16px
    }
</style>
```
-  3.按照px来编写都会转化成rem的形式，但是有些地方我们不想转换，可以用下面两种方法。
<pre>
    1. 在px后面添加/*no*/，不会转化px，会原样输出。 — 一般border需用这个
    2. 在px后面添加/*px*/,会根据dpr的不同，生成三套代码。---- 一般字体需用这个
</pre>

-  4.使用过程中，发现某些import外联样式不会被转化，注意避开这些坑。
```js
<style src='../assets/style.css'>
 /* px2rem能正常转换 */
</style>

<style>
  /* px2rem不能正常转换 */
  @import '../assets/style.css';
</style>

<style>
  /* px2rem不能正常转换 */
  @import url('../assets/style.css');

</style>
```
-  5.无需自己增加html页面name=viewport的meta元标签。flexible会自动添加。

#### 7、响应式
-  响应式是什么
<pre>
    响应式就是根据不同的屏幕尺寸和设备类型，自动调整布局、图片、甚至切换到移动端版本。
</pre>
-  响应式怎么实现
<pre>
    1. 媒体查询
    2. 百分比
    3. rem
</pre>
-  媒体查询
```scss
// @media 媒体类型 and (媒体特性){
// only 可以排除不支持媒体查询的浏览器
// screen 设备类型
// max-width 最大宽度
// min-width 最小宽度
// and 同时满足多个条件
@media only screen and (max-width: 320px) {} 

@media screen and (min-width: 321px) and (max-width: 480px) {}

@media screen and (max-width: 768px) {}

@media screen and (min-width: 768px) and (max-width: 992px) {}

@media screen and (min-width: 992px) and (max-width: 1200px) {}

@media screen and (min-width: 1200px) {}
```
-  响应式图片（性能优化）
```html
<picture>
<!--    大于1000px 显示-->
    <source srcset="1.png" media="(min-width:1000px)"/> 
<!--    大于700px 显示-->
    <source srcset="2.png"  media="(min-width:700px)"/>
<!--    小于 700px 显示-->
    <img src="3.png" alt="">
</picture>
```

#### 8、布局方案
-  1.什么情况下用响应式
 <pre>
    数据不是特别多，用户量不是特别大，纯展示类的项目适合响应式布局
    例如：公司官网、专题页面
    特别是追求性能的项目，不太适合响应式，因为如果添加了很多的响应式就会造成加载速度变慢。（淘宝、京东）
 </pre>
-  2.pc + 移动端应该做什么样的布局方案
 <pre>
    访问量还可以或者比较大，类似于淘宝：pc是一套（会加一点响应式） 、移动端是一套（会使用自适应的布局方式）
</pre>

-  3.pc 设计图 1920，自己笔记本是1280，怎么办？
 <pre>
    1.把ui图进行等比例缩放，缩放成和电脑一样的尺寸；
    2.换1980的电脑；
</pre>

-  4.移动端设计图 750
<pre>
    因为750设计图/2就是375，正好是iphone6的尺寸，我们要把iphone6的尺寸作为基准点。
</pre>
