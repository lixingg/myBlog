# Python

## Python 专栏

### 1、python 解释器的安装

- **1.下载安装包**

   ```python
   # https://www.python.org/downloads/
   ```

- **2.安装**

   ```python
   # 根据安装包提示安装即可，
   # 安装过程勾选 
   #  1. Use admin privileges when installing py.exe 选项
   #  2. Add python.exe to PATH 选项
   ```

### 2、安装 Pycharm 编辑器

- **1.下载安装包**

   ```python
   # https://www.jetbrains.com/pycharm/download/
   ```

- **2.安装(不做过多赘述，不会的百度一下就行了)**

- **3.快捷键**
- ```python
  # ctrl + alt + s : 打开设置
  # ctrl + d : 复制当前行
  # ctrl + alt + ↑/↓ : 向上/下移动当前行
  # ctrl + / : 单行注释
  # ctrl + shift + f10 : 运行当前代码文件
  # shift + f6 : 重命名文件
  # ctrl + a : 全选
  # ctrl + c/v/x : 复制/粘贴/剪切
  # ctrl + z : 撤销
  # ctrl + f : 搜索
  # ctrl + shift + f : 全局搜索
  # ctrl + shift + r : 全局替换
  ```

### 3、基础语法

-  #### 1.字面量
- 1.什么是字面量
-  ```python
    # 在代码中，被写下来的固定的值，称之为字面量
   ```

- 2.常用值类型
-  ```python
   # (1) 数字（Number）：支持整数（int）、浮点数（float）、复数（complex）、布尔值（bool）
   # (2) 字符串（String）：描述文本的一种数据类型
   # (3) 列表（List）： 有序的可变列表
   # (4) 元组（Tuple）：有序的不可变列表
   # (5) 集合（Set）：无序不重复集合
   # (6) 字典（Dictionary）：无序Key-Value集合
   ```

-  #### 2.注释
- 1.注释的作用
-  ```python
   # 注释不是程序，不能被执行，只是对程序代码进行解释说明，让别人可以看懂程序代码的作用，能够大大增强程序的可读性。
   ```

- 2.单行注释
-  ```python
   # 单行注释以 # 开头，注释内容可以放在一行，也可以放在多行。
   # 注意：# 号和注释内容一般建议以一个空格隔开。
   ```

- 3.多行注释
-  ```python
   # 多行注释以三个单引号（'''）或者三个双引号（"""）开头，以三个单引号（'''）或者三个双引号（"""）结尾。
   ```

-  #### 3.变量

-  ```python
   # 变量：它是程序中最基本的存储单元，用于存储程序运行过程中产生的数据。
   # 格式：变量名 = 变量值
   # 特征：变量的值是可以改变的 
   ```

-  #### 4.数据类型
- 1.类型分类
-  ```python
   # string : 字符串类型 
   # int : 整数类型（有符号）
   # float : 浮点数类型 （有符号）
   ```

- 2.类型验证
-  ```python
   # 1.type(字面量) 返回值为数据类型
   print(type(10))  # <class 'int'> 
   
   # 2.type(变量名) 返回值为数据类型
   # 变量没有类型 变量存储的字面量有类型
   # 例如：我们可以说字符串变量 但不能说变量是字符串
   a=11
   print(type(a))  # <class 'int'>
   ```

- 3.类型转换
-  ```python
   # 1.int(x) 将x转换为整数 (x内容必须是数字，不然就报错, 浮点数转整数，小数部分会被去掉)
   print(int(10.5))  # 10
   # 2.float(x) 将x转换为浮点数 (x内容必须是数字，不然就报错， 整数转浮点数， 整数部分会变成浮点数)
   print(float(10))  # 10.0
   # 3.str(x) 将x转换为字符串 （x任何类型都可）
   print(str(10))  # '10'
   print(str(10.5))  # '10.5'
   print(str(True))  # 'True'
   print(str(False))  # 'False'
   print(str([1,2,3]))  # '[1, 2, 3]'
   print(str({'name':'张三'}))  # "{'name': '张三'}"
   # 4.bool(x) 将x转换为布尔值
   print(bool(10))  # True
   print(bool(0))  # False
   print(bool(''))  # False
   print(bool('hello'))  # True
   print(bool([]))  # False
   print(bool([1,2,3]))  # True
   print(bool({}))  # False
   print(bool({'name':'张三'}))  # True
   ```

-  #### 5.标识符
- 1.标识符：用于给变量、类、方法等名命。

- 2.标识符名命规则：
-  ```python
   # 1.内容限定
   #    1.1.只能包含英文、中文、数字、下划线(_)这四类元素。（不推荐使用中文）
   #    1.2.不能以数字开头
   #    错误的代码示范：
   #      1.2.1.10_name = '张三'
   #      name_! = '张三'
   # 2.大小写敏感
   A='HELLO'
   a='world'
   print(A)  # HELLO
   print(a)  # world
   
   # 3.不可使用关键字
    False True class continue def del import in is return None raise
    if elif else global nonlocal pass try while and as assert break by
    except finally for from lambda not or with yield
   ```

- 3.标识符的命名规范：
-  ```python
   # 1.见名知意（变量名要做到：明了(看见名就知道什么意思)、简洁(减少名字长度）、唯一）
   # 2.遵循驼峰命名法（首字母小写，后面单词的首字母大写）
   # 3.不能使用中文
   # 4.不能使用特殊字符
   # 5.下划线命名法（多个单词组合变量名，要使用下划线做分隔）
   ```

- #### 6.运算符
- 1.算数运算符

- ```python
  # + : 加  a + b
  # - : 减  a - b
  # * : 乘  a * b
  # / : 除  a / b
  # // : 取整除 9 // 2 输出 4 ； 9.0  // 2.0 输出 4.0 
  # % : 取余 a % b  9 % 2 输出 1
  # ** : 指数 a ** b  a的b次方
  ```

- 2.赋值运算符

- ```python
  # = : 赋值  a = 10
  ```

- 3.复合赋值运算符

- ```python
  # += : 加法赋值运算符 a += b 等价于 a = a + b
  # -= : 减法赋值运算符 a -= b 等价于 a = a - b
  # *= : 乘法赋值运算符 a *= b 等价于 a = a * b
  # /= : 除法赋值运算符 a /= b 等价于 a = a / b
  # //= : 取整除赋值运算符 a //= b 等价于 a = a // b
  # %= : 取余赋值运算符 a %= b 等价于 a = a % b
  # **= : 幂赋值运算符 a **= b 等价于 a = a ** b
  ```

- 4.比较运算符

- ```python
  # == : 等于  a == b
  # != : 不等于  a != b
  # > : 大于  a > b
  # < : 小于  a < b
  # >= : 大于等于  a >= b
  # <= : 小于等于  a <= b
  ```

- #### 7.字符串
- 1.字符串的三种定义方式
- ```python
  # 1.单引号 ：name = 'world'
  # 2.双引号 ：name = "world"
  # 3.三引号 ：name = '''hello world''' || name = """hello world"""
  # 注意：三引号定义法，和多行注释的写法一样，同样支持换行操作。使用变量接收它，它就是字符串，不使用变量接收它，就可以作为多行注释使用
  ```

- 2.字符串的引号嵌套
- ```python
  # 1.单引号定义法，可以内含双引号：name = 'hello "world"'
  # 2.双引号定义法，可以内含单引号：name = "hello 'world'"
  # 3.可以使用转义字符（\）来将引号解除转义效果，变成普通字符串： name = "hello \"world\""
  ```

- 3.字符串的拼接
- ```python
  number = 123456
  # 1.使用 + 进行拼接 ： addr = "北京" +number + "朝阳"
  # 2.使用 * 进行重复拼接 addr = "北京" * 3
  # 注意：无法和非字符串类型拼接，否则会报错 ：print("我是" + name2 + 123) 
  ```

- 4.字符串格式化
- ```python
  # 1.使用 % 进行格式化：
    # 语法："%占位符" % 变量
    # s表示将变量转换成字符串类型，d表示将变量转换成整数类型，f表示将变量转换成浮点数类型
    # %s 表示字符串：message = "hello %s：你是我的 %s" % ("world","朋友")
    # %d 表示整数：message = "hello %d" % (123)
    # %f 表示浮点数：message = "hello %f" % (123.456)
  
  # 2.数字精度控制: 辅助符号 ("m.n")
    # m：控制宽度，要求是数字（很少使用），设置的宽度小于数字自身，不生效
    # n：控制小数点精度，要求是数字，会进行小数的四舍五入
    # 示例：
       # %5d : 表示将整数的宽度控制5位，如数字11，被设置为了5d,就会变成：[空格][空格][空格]11，用三个空格补足宽度。
  
       # %5.2f : 表示将浮点数的宽度控制为5位，小数点精度为2位，如数字1
       # 小数点和小数部分也算入宽度计算。如：对11.345设置了%7.2f后，结果为：[空格][空格]11.35。2个空格补足宽度，
       # 小数部分限制2位精度后，四舍五入为.35 。
      
       # %.2f：表示不限宽度，只设置小数点精度为2，如：11.345设置 .2f后，结果是 11.35
  
  # 3.使用 f"内容{变量}" 进行格式化：不限数据类型，不做精度控制
  # 如：
    name = "world"
    message = f"hello {name}"
  # 注意：适合对精度没有要求的时候快速使用
  
  # 4.表达式的格式化
  # 表达式：一条具有明确执行结果的代码语句 如：1+1 、5*2 、name = "张三"
  # 格式化表达式：
    # "执行结果是 %d" % (表达式)
    # f"执行结果是 {表达式}"
    # "字符串在Python中的类型是: %s" % (type('字符串'))
  ```

- #### 8.获取键盘输入
- **input()语句（函数）**
- ```python
  # 1.input() 函数：
    # 作用：接收用户输入的内容，并返回给调用者
    # 语法：input("提示信息")
    # 注意：input() 函数接收到的内容，都是字符串类型
    # 示例：
      # 1.提示用户输入一个数字
      # num = input("请输入一个数字：")
      # print(num)
      # 2.提示用户输入一个名字
      # name = input("请输入你的名字：")
      # print(name)
  ```

- #### 9.布尔类型
- **布尔类型（bool）**
- ```python
  # 布尔类型（bool）
    # 布尔类型只有两个值：True 和 False (注意大小写)
    # 布尔类型通常用于逻辑判断
    # 注意：布尔类型通常用于逻辑判断，判断一个条件是否成立
  ```

- #### 10.判断语句
- 1.if语句
- ```python
  
    # 语法：
      # if 条件:
        # 条件成立时执行的代码
      #elif 条件:
        # 条件成立时执行的代码
      # ...
      # else:
        # 条件不成立时执行的代码
  
      # 例如：
         age = 18
         if age >= 18:
         # 注意：归属于if判断的代码块，需要在前面四个空格缩进，python 通过缩进判断代码块的归属关系
             print("你已经成年了")
         # 注意：elif 可以写多个 
         elif age < 0:
             print("你还未出生")
         else:
             print("你还未成年")
  
    # 注意：
      # 1.if、else语句后面必须跟一个冒号：
      # 2.if语句的执行结果，取决于条件是否成立
      # 3.if语句的执行结果，只有True和False两种
      # 4.判断是互斥且有顺序的。满足当前条件将不会向下继续执行其他条件判断。
  
  ```

- 2.判断语句的嵌套
- ```python
  # 1.判断语句的嵌套
  
    # 语法：
      # if 条件1:
        # 条件1成立时执行的代码
        # if 条件2:
          # 条件2成立时执行的代码
        # else:
          # 条件2不成立时执行的代码
      # else:
        # 条件1不成立时执行的代码
  
    # 例如：
      # 1.判断一个数是否大于0
        num = 10
        if num > 0:
          print("这是一个正数")
          if num % 2 == 0:
            print("这是一个偶数")
          else:
            print("这是一个奇数")
        else:
          print("这是一个负数")
    
    # 总结：
      # 1.嵌套判断语句可以用在多条件、多层次的逻辑判断
      # 2.嵌套判断语句可以根据需求，自由组合 if leif else 来构建多层次判断
      # 3.嵌套判断语句，一定要注意空格缩进，python 通过缩进来判断代码块的归属关系
  ```

- #### 12.随机数
- ```python
  # 1.获取随机数
  import random
  
  # 1.1 获取0-100之间的整数随机数
  random_num = random.randint(0, 100)
  print(random_num)
  
  # 1.2 获取0-1之间的随机数
  random_num = random.random()
  print(random_num)
  ```

- #### 13.循环语句
- 1.while循环语句
- ```python
    # 语法：
      # while 循环条件:
        # 条件成立时执行的代码
  
    # 例如：
      # 1.计算1-100之间所有整数的和
        sum = 0
        i = 1
        while i <= 100:
          sum += i
          i += 1
        print(sum)
  
    # 注意：
      # 1.while的条件需要得到布尔类型，True 表示继续循环，False 表示结束循环
      # 2.需要设置循环终止的条件，如 i+=1 配合 i<=100 ,就能保证循环100次后终止循环，否则将无限循环下去
      # 3.空格缩进和if判断一样，都需要设置
  ```

- 2.while循环的嵌套
- ```python
    # 语法：
      # while 循环条件1:
        # 条件1成立时执行的代码
        # while 循环条件2:
          # 条件2成立时执行的代码
  
    # 例如：
     i=1
     while i<=10:
         print(i)
         i+=1
         j=1
         while j<=10:
             print(j)
             j+=1
    # 注意：
      # 1.同判断语句的嵌套一样，循环语句的嵌套也需要空格缩进（基于空格缩进来决定层次关系）
      # 2.注意条件的设置，避免出现无限循环（除非真的需要无限循环）
   ```

- 3.补充知识
- ```python
   # 1.print() 默认输出换行，如果需要输出不换行，需要添加end=""
    # 例如：
      print("hello",end="")
      print("world",end="")
  
   # 2.制表符 \t
    # 在字符串中，有一个特殊符号：\t,效果等同于在键盘上按下tab键，它可以让我们的多行字符串对齐
    # 例如：
        # 九九乘法表
        i = 1
        while i <= 9:
            j = 1
            while j <= i:
                print(f"{j}x{i}={j * i}\t", end="")
                j += 1
            i += 1
            print()
  ```

- 4.for循环
- ```python
   # 语法：
    # for 临时变量 in 待处理的数据集（序列）:
      # 循环满足条件执行的代码
  
    # 例如：
      # 1.打印字符串的每个字符
        s = "hello world
        for i in s:
          print(i)
  
  # 注意：
    # 1.无法定义循环条件，只能被动取出数据处理
    # 2.要注意，循环内的语句，需要有空格缩进
  ```

- 5.range 语句
- ```python
  # for 循环语句，本质上是遍历：序列类型。
  # 语法1:
    # range(num) 获取一个从0开始到num-1结束的序列
    # 如：range(5) -> [0,1,2,3,4]
  
  for i in range(5):
    print(i) 
  
  # 语法2:
    # range(start,end) 获取一个从start开始到end-1结束的序列
    # 如：range(1,5) -> [1,2,3,4]
  
  for i in range(1,5):
    print(i) 
  
  # 语法3:
    # range(start,end,step) 获取一个从start开始到end-1结束的
    # 步长为step的序列,step默认为1
    # 如：range(1,5,2) -> [1,3]
  
  for i in range(1,5,2):
    print(i)
  
  # 注意：
    # 1.range 返回的是一个序列，而不是一个具体的值
    # 2.range 返回的序列，是左闭右开的
    # 3.range 返回的序列，是可迭代对象
  ```

- 6.for循环临时变量作用域
- ```python
  # 1.for循环中的临时变量，其作用域：循环内
  # 2.这种限定：
    # 是编程规范的限定，而非强制限定
    # 不遵守也能正常运行，但是不建议这样做
    # 如需访问临时变量，可以预先在循环外定义它
    # 例如：
    i=0
    for i in range(10):
        print(i)
    print(i)
  ```

- 7.for循环的嵌套
- ```python
  # 语法：
    # for 临时变量 in 待处理的数据集（序列）:
      # 循环满足条件执行的代码
          for 临时变量 in 待处理的数据集（序列）:
            # 循环满足条件执行的代码
  
  # 例如：
    # 打印九九乘法表
    for i in range(1,10):
      for j in range(1,i+1):
        print(f"{j}x{i}={i*j}",end="\t")
      print()
  
  # 注意：
    # 1.for循环可以嵌套，但建议不要超过三层
    # 2.for循环的嵌套，是逻辑上的嵌套，而非物理上的嵌套
    # 3.嵌套的for循环，建议使用break和continue来控制
    # 4.嵌套的for循环，建议使用else来控制
  ```

- 8.break和continue
- ```python
  # 1.break
    # 作用：结束整个循环(如果是嵌套循环，只能终止当前循环体，外层循环体不受影响）
    # 用于：for循环和while循环，效果一致
    # 注意：
      # 1.break 结束的是离它最近的循环
      # 2.break 结束循环后，不会执行循环体中剩余的代码
  
  # 例如：
    # 遇到50终止循环
    for i in range(1,101):
      if i==50:
          break
      print(i)
  
  # 2.continue
    # 作用：中断本次循环，直接进入下一次循环(如果是嵌套循环，只能跳过当前循环体本次执行，外层循环体不受影响）
    # 用于：for循环和while循环，效果一致
    # 注意：
      # 1.continue 结束的是离它最近的循环
      # 2.continue 结束循环后，会执行循环体中剩余的代码
  
  # 例如：
    # 打印1-100之间所有是3的倍数的数
    for i in range(1,101):
      if i%3==0:
          print(i)
      else:
          continue
    
    # while循环使用 continue （break也是相同）
    i=1
    while i<=100:
        i+=1
        if i%3==0:
            print(i)
        else:
            continue
        print("执行了第%d次" % (i))
  ```
  

- 9.列表生成式
- ```python
  # 作用：快速生成一个列表
  # 语法：
    # [表达式 for 临时变量 in 待处理的数据集（序列） if 条件判断]
  
  # 例如：
    # 生成1-100之间所有是3的倍数的数的列表
    result=[i for i in range(1,101) if i%3==0]
    print(result)
  ```

- #### 14.函数
- 1.函数的定义
- ```python
    # 函数：
      # 1.是组织好的，可重复使用的，用于执行特定任务的代码段
      # 2.通过调用函数来执行代码
  
    # 使用函数的好处：
      # 1.将功能封装在函数内，可供随时随地的重复使用
      # 2.提高代码的复用性、减少重复代码，提高开发效率
  
    # 语法：
      def 函数名(传入参数): 
          # 函数体
          # return 返回值
  
    # 例如：
      def say_hello():
          print("hello")
  
      say_hello()

  # 2.函数的调用
    # 语法：
      函数名(传入参数)
  
    # 例如：
      def say_hello(name):
          print("hello %s" % (name))
  
      say_hello("小明")
  
    # 注意：
      # 1.参数如不需要，可以省略
      # 2.返回值如不需要，可以省略
      # 3.函数必须先定义后使用
    ```

- 2.函数的参数
- ```python
    # 1.作用：在函数运行的时候，接收函数外传入的数据
  
    # 2.语法：
       # def 函数名(形参1,形参2,...):
          # 函数体
          # return 返回值
  
    # 例如：
      def say_hello(name):
          print("hello %s" % (name))
  
      say_hello("小明")

    # 3.注意：
      # 函数定义中的参数，称之为“形式参数”
      # 函数调用时传入的参数，称之为“实际参数”
      # 函数的参数数量不限，使用逗号分隔
      # 传入参数的时候，要和形参一一对应，逗号分隔
    ```

- 3.函数的返回值
- ```python
    # 1.作用：在函数运行结束时，将结果返回给函数调用者
  
    # 2.语法：
       # def 函数名(传入参数):
          # 函数体
          # return 返回值
  
    # 例如：
      def sum(a,b):
          return a+b
  
      result = sum(1,2)
      print(result)

    # 3.注意：
      # 1.return 后面的返回值，会返回给函数调用者
      # 2.函数体中，return 后面的代码都不会执行
      # 3.函数中可以有多个return，但只有第一个return会被执行
      # 4.函数中如果没有return，则返回None
    ```

- 4.函数的说明文档
- ```python
   # 1.作用：在函数定义的时候，对函数的功能进行描述
  # 2.语法：
    # def 函数名(形参1,形参2,...):
        # """
        # 这里是函数的功能描述
        # """ 
        # 函数体
        # return 返回值
  
  # 例如：
    def sum(a,b):
        """
        计算两个数的和
        """
        return a+b
  
    print(sum.__doc__)
  
  # 3.注意：
    # 1.函数的说明文档，使用三个双引号
    # 2.函数的说明文档，使用三个单引号
  ```

- 5.函数的嵌套调用
- ```python
    # 1.作用：在函数A中调用函数B，在函数B中调用函数C
  
    # 2.语法：
       # def 函数A():
          # 函数A的代码
          # 函数A调用函数B
          # def 函数B():
            # 函数B的代码
            # 函数B调用函数C
            # def 函数C():
              # 函数C的代码
  
    # 例如：
      def sum(a,b):
        return a+b
  
      def sub(a,b):
        return a-b
  
      def mul(a,b):
        return a*b
  
      def div(a,b):
        return a/b
  
      def main():
        # 调用函数A
        result = sum(1,2)
        print(result)
        # 调用函数B
        result = sub(1,2)
        print(result)
        # 调用函数C
        result = mul(1,2)
        print(result)
        # 调用函数D
        result = div(1,2)
        print(result)
  
      main()
  
  ```

- 6.变量在函数中的作用域

- ```python
    # 1.局部变量：作用范围在函数内部，在函数外部无法使用
      # 例如：
        def main():
          num = 10
          print(num)
        main()
        # 外部访问会报错
        print(num)
       
    
    # 2.全局变量：作用范围在函数内、外部均可使用
      # 例如：
        # 定义全局变量
        num = 10
        def main():
          print(num)
        main()
        print(num)
  
    
    # 3.局部变量和全局变量重名
      # 例如：
        num = 10
        def main():
          # 重新定义局部变量num ，与全局变量不冲突
          num = 20
          print(num)
        main()
        print(num)
  
    
    # 4.局部变量和全局变量重名，在函数内部修改全局变量
      # 例如：
        num = 10
        def main():
          # 修改全局变量 使用global关键字标注该变量为全局变量
          global num
          num = 20
          print(num)
        main()
        print(num)
  ```

-  #### 15.数据容器
- 1.列表list

- ```python
    # 1.基础语法:
      # 字面量 
      # [元素1,元素2,元素3,...]
  
      # 定义变量 
      # 变量名 = [元素1,元素2,元素3,...]
  
      # 定义空列表
      # 变量名 = []
      # 变量名 = list()
  
      # 列表内每一个数据称为元素，以[]作为标识，列表内每个元素之间，逗号隔开
      # 例如：
        # 定义列表
        list1 = [1,2,3,4,5]
  
      # 注意：列表内的元素，可以是任意数据类型，甚至元素也可以是列表，这样就定义了嵌套列表
   
    # 2.列表的下标（索引）
      # 列表的下标（索引）是从0开始的，列表的下标（索引）可以用来访问列表中的元素
      # 从前向后的方向，索引编号从0开始递增
      # 从后向前的方向，索引编号从-1开始递减
      # 例如：
        # 定义列表
        list1 = [1,2,3,4,5]
        # 访问列表中的元素
        print(list1[0])  # 输出：1
        print(list1[-1])  # 输出：5
        list2 = [1,2,[3,4]]
        print(list2[2][1])  # 输出：4
  
      #注意：取值时索引编号不要超出下标索引的取值范围（0~len(list)-1），超出范围会报错
  
    # 3.列表的常用操作（方法）
      # 函数和方法的区别：
      # 函数是一个封装的代码单元，可以提供特定的功能
      # python 中如果将函数定义为class(类)的属性，那么这个函数就是类的方法
      
      # 1.查找元素索引
        # 语法：
          # 元素在列表中的索引编号 = 列表.index(元素)
        # 例如：
          # 定义列表
          list1 = [1,2,3,4,5]
          # 查找元素索引
          print(list1.index(3))  # 输出：2
          # 查找元素不存在
          print(list1.index(6))  # 报错：ValueError: 6 is not in list
  
      # 2.修改元素
         # 语法：
           # 列表[索引] = 新元素
         # 例如：
           # 定义列表
           list1 = [1,2,3,4,5]
           # 修改索引的元素值
           list1[2] = 10
           print(list1)  # 输出：[1, 2, 10, 4, 5]
  
      # 3.插入元素
         # 语法：
           # 列表.insert(索引,新元素)
         # 例如：
           # 定义列表
           list1 = [1,2,3,4,5]
           # 在指定位置插入元素
           list1.insert(2,10)
           print(list1)  # 输出：[1, 2, 10, 3, 4, 5] 
      
      # 4.追加元素（单个）
         # 语法：
           # 列表.append(新元素)
         # 例如：
           # 定义列表
           list1 = [1,2,3,4,5]
           # 追加元素
           list1.append(6)
           print(list1)  # 输出：[1, 2, 3, 4, 5, 6]
      
      # 5.批量追加元素 
         # 语法：
           # 列表.extend(可迭代对象)
         # 例如：
           # 定义列表
           list1 = [1,2,3,4,5]
           # 批量追加元素
           list1.extend([6,7,8])
           print(list1)  # 输出：[1, 2, 3, 4, 5, 6, 7, 8]
  
      # 6.删除元素
         # 语法：
           # del 列表[索引]
           # 列表.remove(元素)
           # 列表.pop(索引)
         # 例如： 
           # 定义列表
           list1 = [1,2,3,4,5]
  
           # 删除指定索引的元素
           del list1[2]
           print(list1)  # 输出：[1, 2, 4, 5]
           
           # 删除指定元素（只删除第一个匹配（从前向后匹配）的元素）
           list1.remove(3) # 返回值 输出：None
           print(list1)  # 输出：[1, 2, 4, 5]
  

           # 删除指定索引的元素，并返回该元素
           list1.pop(2)
           print(list1)  # 输出：[1, 2, 5]
           print(list1.pop(2))  # 返回值输出：5
  
         # 注意：
           # 1.删除元素后，索引会自动前移
           # 2.删除的元素不存在时，会报错
      
      # 7.清空列表
         # 语法：
           # 列表.clear()
         # 例如：
           # 定义列表
           list1 = [1,2,3,4,5]
           # 清空列表
           list1.clear()
           print(list1)  # 输出：[]
  
      # 8.统计某元素在列表中的数量
         # 语法：
           # 列表.count(元素)
         # 例如：
           # 定义列表
           list1 = [1,2,3,4,5,1,2,3,4,5]
           # 统计元素1的数量
           print(list1.count(1))  # 输出：2
      
      # 9.统计列表内所有元素的数量 
         # 语法：
           # len(列表)
         # 例如：
           # 定义列表
           list1 = [1,2,3,4,5,1,2,3,4,5]
           # 统计列表内所有元素的数量
           print(len(list1))  # 输出：10
      
      # 总结：
        # 可以容纳多个元素（上限为2**63-1）  
        # 可以容纳不同类型的元素（混装）
        # 数据是有序存储的（有下标序号）
        # 允许重复数据存在
        # 可以修改（增删改查）
  
      
      # 10.列表的遍历（while）
         # 语法：
           # while 条件：
           #    执行语句
         # 例如：
           # 定义列表
           list1 = [1,2,3,4,5]
           # 遍历列表
           i = 0
           while i < len(list1):
               print(list1[i])
               i += 1
  
      # 11.列表的遍历（for）
         # 语法：
           # for 变量 in 列表：
           #    执行语句
         # 例如：
           # 定义列表
           list1 = [1,2,3,4,5]
           # 遍历列表
           for i in list1:
               print(i)
  
      # 12.列表的遍历（for-else）
         # 语法：
           # for 变量 in 列表：
           #    执行语句
           # else：
           #    执行语句
         # 例如：
           # 定义列表
           list1 = [1,2,3,4,5]
           # 遍历列表
           for i in list1:
               print(i)
           else:
               print("遍历完成")
  
      # 13.列表的遍历（while-else）
         # 语法：
           # while 条件：
           #    执行语句
           # else：
           #    执行语句
         # 例如：
           # 定义列表
           list1 = [1,2,3,4,5]
           # 遍历列表
           i = 0
           while i < len(list1):
               print(list1[i])
               i += 1
           else:
               print("遍历完成")
    
      # 14.while 循环和for 循环 都是循环语句，但细节上不同：
        # 再循环控制上
          # while循环可以自定循环条件，并自行控制
          # for循环不可以自定循环条件，只可以一个个从容器中取出数据
        # 在无限循环上
          # while循环可以定义条件无限循环下去，for循环在取完容器内所有数据后停止循环
        # 在使用场景上
          # while循环适用于任何想要循环的场景
          # for循环适用于遍历数据容器的场景或简单的固定次数循环场景
  ```

- 2.元组

- ```python
  # 元组
      # 1.定义
        # 定义元组使用小括号(),且使用逗号隔开各个数据，数据可以是不同的数据类型
  
        # 定义元组字面量
          # (元素1,元素2,元素3,...)
  
        # 定义元组变量
          # 变量名 = (元素1,元素2,元素3,...)
  
        # 定义空元组
          # 变量名 = ()
          # 变量名 = tuple()
  
        # 定义只有一个元素的元组
          # 变量名 = (元素,)
  
        # 定义嵌套元组
          # 变量名 = (元素1,(元素2,元素3,...),...)
        
        # 注意：
          # 1.元组一旦定义，就不能修改（如果元组内包含list,list里面的元素可以通过下标修改）
          # 2.元组只有一个数据，这个数据后面要添加逗号，否则不是元组类型 t1 = (100,)
  
      # 2.访问
        # 语法：
          # 元组变量[索引]
        # 例如：
          # 定义元组
            t1 = (100,200,300,400,500)
          # 访问元组
            print(t1[0]) # 输出 100
          # 定义嵌套元组
            t2 = (100,(200,300),400,500)
          # 访问嵌套元组
            print(t2[1][1]) # 输出 300
  
      # 3.操作方法
        # 1.查找元素索引
          # 语法：
            # 元组变量.index(元素)
          # 例如：
            # 定义元组
              t1 = (100,200,300,400,500)
            # 查找元素索引
              print(t1.index(300)) # 输出 2
    
        # 2.统计元素出现次数（也可用于判断是否存在该元素使用 0 为不存在）
          # 语法：
            # 元组变量.count(元素)
          # 例如：
            # 定义元组
              t1 = (100,200,300,400,500,100,200,300,400,500)
            # 统计元素出现次数
              print(t1.count(100)) # 输出 2
  
        # 3.统计元组元素的数量
            # 语法：
              # len(元组变量)
            # 例如：
              # 定义元组
                t1 = (100,200,300,400,500)
              # 统计元组元素的数量
                print(len(t1)) # 输出 5
  
      # 4.遍历
        # while循环
        # 语法：   
          # while 条件表达式:
            # 语句块
          # 例如：
            # 定义元组
              t1 = (100,200,300,400,500)
            # 遍历元组
              i = 0
              while i < len(t1):
                print(t1[i])
                i += 1
        # for循环
        # 语法：
          # for 变量 in 元组变量:
            # 语句块
          # 例如：
            # 定义元组
              t1 = (100,200,300,400,500)
            # 遍历元组
              for i in t1:
                print(i)
  
      # 总结：
        # 1.元组和list基本相同（有序、任意数量元素、允许重复元素），唯一不同在于不可修改
  ```

- 3.字符串

  ```python
  # 字符串的定义
    # 1.单引号
      # 例如：
        # 定义字符串
          str1 = 'hello'
    # 2.双引号
      # 例如：
        # 定义字符串
          str2 = "hello"
    # 3.三引号
      # 例如：
        # 定义字符串
          str3 = '''hello'''
        # 定义多行字符串
          str4 = """hello
          hello
          hello"""
  
  # 字符串的操作
    # 1.通过下标索引取值 
      # 从前向后，下标从0开始
      # 从后向前，下标从-1开始
      # 不支持通过下标修改元素
      # 语法：
        # 字符串变量[索引]
      # 例如：
        # 定义字符串
          str1 = 'hello' 
        # 使用方法
          print(str1[0]) # 输出 h
          print(str1[-1]) # 输出 o
    
    # 2.获取元素的索引
      # 语法：
        # 字符串变量.index(要查找的子串,开始索引,结束索引)
      # 例如： 
        # 定义字符串
          str1 = 'hello'
        # 使用方法
          print(str1.index('l')) # 输出 2 
          print(str1.index('l',3)) # 输出 3
        # 报错
          print(str1.index('l',3,5)) # 报错
  

    # 3.字符串替换（老的字符串是只读不可修改的 获取到新的返回值字符串）
      # 语法： 
        # 字符串变量.replace(旧子串,新子串,替换次数)
      # 功能：
        # 将字符串变量中所有旧子串替换为新子串，替换次数默认为所有
      # 例如：
        # 定义字符串
          str1 = 'hello'
        # 使用方法
          print(str1.replace('l','a')) # 输出 heaao
          print(str1.replace('l','a',1)) # 输出 healo
  
      # 注意：
        # 不是修改字符串本身，而是得到了一个新的字符串
  
    # 4.字符串分割
      # 语法：
        # 字符串变量.split(分割符,分割次数)
      # 功能：
        # 将字符串变量按照分割符进行分割，分割次数默认为所有，将字符串划分为多个字符串，并存入列表对象中
      # 例如：
        # 定义字符串
          str1 = 'hello'
        # 使用方法
          print(str1.split('l')) # 输出 ['he', '','o']
          print(str1.split('l',1)) # 输出 ['he', 'lo']
      
      # 注意：
        # 字符串本身不变，而是得到了一个列表对象
  
    # 5.字符串规整（去前后空格）
      # 语法： 
        # 字符串变量.strip()
        # 字符串变量.strip('指定字符串')
      # 功能：
        # 去除字符串变量前后的所有空格
        # 去除字符串变量前后的指定字符串
      # 例如：
        # 定义字符串
          str1 = '   hello   '
          str2 = '12hello21'
        # 使用方法
          print(str1.strip()) # 输出 hello
          print(str2.strip('12')) # 输出 hello
  
      # 注意：
        # 字符串本身不变，而是得到了一个新字符串
        # 传入的是 "12" 其实就是：'1'和'2'都会移除，是按照单个字符
  
    # 6.统计字符串中某字符出现次数
      # 语法：
        # 字符串变量.count(子串)
      # 功能：
        # 统计字符串变量中某子串出现的次数
      # 例如：
        # 定义字符串
          str1 = 'hello'
        # 使用方法 
          print(str1.count('l')) # 输出 2
          print(str1.count('l',1,3)) # 输出 1
  
    # 7.统计字符串长度
      # 语法：
        # len(字符串变量)
      # 功能：
        # 统计字符串变量中字符的个数
      # 例如：
        # 定义字符串
          str1 = 'hello'
        # 使用方法
          print(len(str1)) # 输出 5
  
  # 字符串的遍历  
    # while循环
      # 语法：
        # while 条件:
          # 代码块
      # 功能：
        # 只要条件为真，就执行代码块
      # 例如：
        # 定义字符串
          str1 = 'hello'
        # 使用方法
          i = 0
          while i < len(str1):
            print(str1[i])
            i += 1
  
    # for循环
      # 语法：
        # for 变量 in 字符串变量:
          # 代码块
      # 功能：
        # 依次取出字符串变量中的每一个字符
      # 例如：
        # 定义字符串
          str1 = 'hello'
        # 使用方法
          for ch in str1:
            print(ch) 
  
  # 注意：
    # 只可以存储字符串
    # 长度任意（取决于内存大小）
    # 支持下标索引
    # 允许重复字符串存在
    # 不可以修改（增删改）
    # 支持for、while循环
  ```

- 4.序列

- ```python
  # 序列：
    # 1.内容连续、有序，可使用下标索引的一类数据容器
    # 2.列表、元组、字符串，均可以称之为序列
  
  # 序列的常用操作 - 切片
    # 切片：从一个序列中取出一个子序列
      # 语法： 
        # 变量名[起始下标:结束下标:步长]
      # 功能：
        # 取出从（起始下标）到（结束下标-1）的子序列
        # 步长：（默认是1，可以不写）
          # 取出元素的间隔
          # 步长为N表示，每次跳过N-1个元素，然后取当前元素
          # 步长为负数表示，反向取（注意：起始下标和结束下标也要反向标记）
      # 例如：
        # 定义列表
          list1 = [1,2,3,4,5,6,7,8,9]
        # 使用方法 
          print(list1[1:5:2]) # 输出 [2,4]
          print(list1[1:5]) # 输出 [2,3,4]
          print(list1[-1:-5:-2]) # 输出 [9,7]
          print(list1[:]) # 输出 [1,2,3,4,5,6,7,8,9] 起始和结束不写表示从头到尾，步长为1
          print(list1[::2]) # 输出 [1,3,5,7,9] 步长为2
          print(list1[::-1]) # 输出 [9,8,7,6,5,4,3,2,1] 步长为-1 序列反转
          print（list1[3:1:-1]) # 输出 [4,3,2] 起始和结束不写表示从头到尾，步长为-1
  ```   

- 5.集合

- ```python
  # 集合：
    # 1.内容无序且不重复、无索引，可使用in、not in判断元素是否存在的数据容器
    # 2.集合、字典，均可以称之为可变集合
    # 3.集合和列表一样，是允许修改的
  
  # 基础语法：
    # 1.定义集合字面量
      # 语法：{元素1,元素2,...}
    # 2.定义集合变量
      # 语法：变量名 = {元素1,元素2,...}
    # 3.定义空集合
      # 语法：变量名 = set()
  
  # 集合的常用操作
    # 1.添加元素
      # 语法：集合变量名.add(元素)
      # 功能：向集合中添加元素
      # 例如：
        # 定义集合
          set1 = {1,2,3,4,5}
        # 添加元素
          set1.add(6)
          set1.add(7)
          set1.add(6)
          print(set1) # 输出 {1,2,3,4,5,6,7} 
  
    # 2.删除元素 
      # 语法：集合变量名.remove(元素)
      # 功能：删除集合中的元素
      # 例如：
        # 定义集合
          set1 = {1,2,3,4,5}
        # 删除元素
          set1.remove(3)
          print(set1) # 输出 {1,2,4,5}
  
    # 3.随机取出元素
      # 语法：集合变量名.pop()
      # 功能：随机取出集合中的一个元素
      # 例如：
        # 定义集合
          set1 = {1,2,3,4,5}
        # 随机取出元素
          el = set1.pop() 
          print(el) # 取出元素 2
          print(set1) # 输出 {1,3,4,5}
  
    # 4.清空集合
      # 语法：集合变量名.clear()
      # 功能：清空集合 
      # 例如：
        # 定义集合
          set1 = {1,2,3,4,5}
        # 清空集合
          set1.clear()
          print(set1) # 输出 set()
  
    # 5.取两个集合的差集
      # 语法：集合变量名1.difference(集合变量名2)
      # 功能：取两个集合的差集(集合1有，集合2没有的元素)
      # 结果得到一个新的集合，集合1和集合2不变
      # 例如：
        # 定义集合
          set1 = {1,2,3,4,5}
          set2 = {4,5,6,7,8}
        # 取两个集合的差集
          set3 = set1.difference(set2)
          print(set3) # 输出 {1,2,3}
          print(set1) # 输出 {1,2,3,4,5}
          print(set2) # 输出 {4,5,6,7,8}
  
    # 6.消除2个集合的差集
      # 语法：集合变量名1.defference_update(集合变量名2)
      # 功能：对比集合1和集合2，在集合1内，删除和集合2相同的元素
      # 结果：集合1被修改，集合2不变
      # 例如：
        # 定义集合
          set1 = {1,2,3,4,5}
          set2 = {4,5,6,7,8}
        # 消除2个集合的差集
          set1.difference_update(set2)
          print(set1) # 输出 {1,2,3}
          print(set2) # 输出 {4,5,6,7,8} 
  
    # 7. 2个集合的合并
      # 语法：集合变量名1.union(集合变量名2)
      # 功能：将集合1和集合2组合成新集合
      # 结果：得到一个新的集合，集合1和集合2不变
      # 例如：
        # 定义集合
          set1 = {1,2,3,4,5}
          set2 = {4,5,6,7,8}
        # 2个集合的合并
          set3 = set1.union(set2)
          print(set3) # 输出 {1,2,3,4,5,6,7,8}
          print(set1) # 输出 {1,2,3,4,5}
          print(set2) # 输出 {4,5,6,7,8}
  
    # 8.统计集合元素的数量
      # 语法：集合变量名.len()
      # 功能：统计集合元素的数量
      # 结果：返回一个整数，表示集合元素的数量
      # 例如：
        # 定义集合
          set1 = {1,2,3,4,5,1,2,3,4,5}
        # 统计集合元素的数量
          print(len(set1)) # 输出 5
  
    # 9.集合的遍历 
      # 集合不支持下标索引，不能用while循环
      # 可以使用for循环
      # 例如：
        # 定义集合
          set1 = {1,2,3,4,5,1,2,3,4,5}
        # 遍历集合
          for i in set1:
            print(i)
  ```

- 6.字典（dict）
  ```python
    # 1.字典的定义
      # 定义字典字面量
        # 语法：{键1:值1,键2:值2,...}
      # 定义字典变量
        # 语法：字典变量名 = {键1:值1,键2:值2,...}
      # 定义空字典
        # 语法：字典变量名 = {}
        # 语法：字典变量名 = dict()
    
    # 2.字典数据的获取
      # 语法：
        # 获取键为key的值
          # 字典变量名[key]
        # 获取键为key的值，如果键不存在，返回默认值
          # 字典变量名.get(key,默认值)
      # 例如：
        # 定义字典
          dict1 = {'name':'张三','age':18,'gender':'男'}
        # 获取键为name的值
          print(dict1['name']) # 输出：张三
        # 获取键为gender的值
          print(dict1['gender']) # 输出：男
        # 获取键为gender的值，如果键不存在，返回默认值
          print(dict1.get('gender','未知')) # 输出：男
  
    # 3.字典的嵌套
      # 例如： 
        # 定义字典
          dict1 = {'name':'张三','age':18,'gender':'男','address':{'province':'北京市','city':'北京市'},12:24}
        # 获取键为address的值
          print(dict1['address']) # 输出：{'province':'北京市','city':'北京市'}
        # 获取键为address的值，获取键为province的值
          print(dict1['address']['province']) # 输出：北京市
    
    # 4.注意：
      # 字典的键是唯一的，如果再次定义相同的键，会覆盖之前的键值对
      # 字典key和value可以是任意数据类型（key不可为字典）
      # 字典同集合一样，不可以使用下标索引，只能通过键来获取值
  
    # 5.字典的常用操作
      # 新增元素
        # 语法：字典变量名[键] = 值 
        # 例如： 
          dict1 = {'name':'张三','age':18,'gender':'男'}
          dict1['address'] = '北京市'
          print(dict1) # 输出：{'name':'张三','age':18,'gender':'男','address':'北京市'}
  
      # 修改元素
        # 语法：字典变量名[需要修改的键] = 新值 （key是唯一的,如果key不存在默认为添加操作，如果存在默认为修改操作）
        # 例如：
          dict1 = {'name':'张三','age':18,'gender':'男'}
          dict1['name'] = '李四'
          print(dict1) # 输出：{'name':'李四','age':18,'gender':'男'}
  
      # 删除元素 
        # 语法：
          # del 字典变量名[键]
          # 要删除的值 = 字典变量名.pop(键)
        # 例如：
          dict1 = {'name':'张三','age':18,'gender':'男'}
          del dict1['name'] 
          print(dict1) # 输出：{'age':18,'gender':'男'}
          delAge = dict1.pop('age')
          print(dict1,delAge) # 输出：{'gender':'男'} 18
  
      # 清空元素
        # 语法：字典变量名.clear()
        # 例如：
          dict1 = {'name':'张三','age':18,'gender':'男'}
          dict1.clear()
          print(dict1) # 输出：{}
  
      # 获取全部的Key
        # 语法：字典变量名.keys()
        # 例如：
          dict1 = {'name':'张三','age':18,'gender':'男'}
          print(dict1.keys()) # 输出：dict_keys(['name', 'age', 'gender'])
  
      # 获取全部的value
        # 语法：字典变量名.values()
        # 例如：
          dict1 = {'name':'张三','age':18,'gender':'男'}
          print(dict1.values()) # 输出：dict_values(['张三', 18, '男'])
  
      # 获取全部的键值对
        # 语法：字典变量名.items()
        # 例如：
          dict1 = {'name':'张三','age':18,'gender':'男'}
          print(dict1.items()) # 输出：dict_items([('name', '张三'), ('age', 18), ('gender', '男')])
  
      # 判断键是否在字典中
        # 语法：字典变量名.get(键,默认值)
        # 例如：
          dict1 = {'name':'张三','age':18,'gender':'男'}
          print(dict1.get('name')) # 输出：张三
          print(dict1.get('sex')) # 输出：None
          print(dict1.get('sex','未知')) # 输出：未知
  
      # 遍历字典
        # 语法1：for 键 in 字典变量名:
          # 执行语句
        # 例如：
          dict1 = {'name':'张三','age':18,'gender':'男'}
          for key in dict1:
            print(key) # 输出：name age gender
            print(dict1[key]) # 输出：张三 18 男
  
        # 语法2：for key in keys:
          # 执行语句
        # 例如：
          dict1 = {'name':'张三','age':18,'gender':'男'}
          for key in dict1.keys():
            print(key) # 输出：name age gender
            print(dict1[key]) # 输出：张三 18 男
  
      # 统计字典内元素的数量
        # 语法：len(字典变量名)
        # 例如：
          dict1 = {'name':'张三','age':18,'gender':'男'}
          print(len(dict1)) # 输出：3
  
    # 6.总结
      # 字典是Python中唯一的映射类型，字典用{}来表示，字典的键值对用冒号来分隔，
      # 键值对之间用逗号来分隔。
      # 字典的键是唯一的，但值可以重复。
      # 字典的键和值可以是任何数据类型。
      # 可以容纳多个数据。
      # 支持for循环，不支持while循环    
  ```

- 7.容器分类
- ```python
  # 是否支持下标索引
    # 支持：列表、元组、字符串 - 序列类型
    # 不支持：字典、集合 - 非序列类型
  
  # 是否支持重复元素
    # 支持：列表、元组、字符串 - 序列类型
    # 不支持：字典、集合 - 非序列类型
  
  # 是否支持修改元素
    # 支持：列表、字典、集合 
    # 不支持：元组、字符串
  ```

- 8.使用场景
- ```python
  # 1.列表：一批数据，可修改、可重复的存储场景
  # 2.元组：一批数据，不可修改、可重复的存储场景 
  # 3.字符串：一串字符串的存储场景
  # 4.集合：一批数据，去重存储场景
  # 5.字典：一批数据，可用key检索value的存储场景 
  ```

- 9.通用操作
- ```python
  # 1.获取容器元素的个数
    # 语法：len(容器变量名)
    # 例如：
      list1 = [1,2,3,4,5]
      print(len(list1)) # 输出：5
  
  # 2.获取容器中最大的元素
    # 语法：max(容器变量名)
    # 例如：
      list1 = [1,2,3,4,5]
      print(max(list1)) # 输出：5
  
  # 3.获取容器中最小的元素
    # 语法：min(容器变量名)
    # 例如：
      list1 = [1,2,3,4,5]
      print(min(list1)) # 输出：1
  
  # 4.类型转换->列表
    # 语法：list(容器变量名)
    # 例如：
      str1 = '12345'
      print(list(str1)) # 输出：[1,2,3,4,5]
  
  # 5.类型转换->元组
    # 语法：tuple(容器变量名)
    # 例如：
      str1 = '12345'
      print(tuple(str1)) # 输出：(1,2,3,4,5)
  
  # 6.类型转换->字符串
    # 语法：str(容器变量名)
    # 例如：
      list1 = [1,2,3,4,5]
      print(str(list1)) # 输出：[1,2,3,4,5]
  
  # 7.类型转换->集合
    # 语法：set(容器变量名)
    # 例如：
      list1 = [1,2,3,4,5]
      print(set(list1)) # 输出：{1,2,3,4,5}
  
  # 8.排序功能
    # 语法：sorted(容器变量名,[reverse=False]) 
    # 例如：
      list1 = [3,2,4,1,5]
      print(sorted(list1)) # 输出：[1,2,3,4,5]
      print(sorted(list1,reverse=True)) # 输出：[5,4,3,2,1]
  ```

- 10.字符串比较
- ```python
  # 1.字符串比较：
    # 单个字符通过根据ASCII码值大小比较
    # 字符串是按位比较，也就是一位位根据ASCII码值进行对比，只要有一位大，那么整体就大 
    # 例如：
      str1 = 'abc'
      str2 = 'abcd'
      str3 = 'ab'
      print(str1>str2) # 输出：False 
      print(str1>str3) # 输出：True
  
  ```

- #### 16.函数进阶
- 1.函数的多返回值
- ```python
  # 如果一个函数需要返回多个值，该如何书写？
    # 语法：
      def 函数名([参数列表]):
          return 返回值1,返回值2,返回值3...
  
    # 例如：
      def 函数名(x,y):
          return x+y,x-y,x*y,x/y
      # 按照返回值顺序，写对应顺序的多个变量接收即可
      # 变量之间用逗号隔开
      # 支持不同类型的数据 return
      result1,result2,result3,result4 = 函数名(10,5)
      print(result1,result2,result3,result4) # 输出：15 5 50 2.0
  ```

- 2.函数的多种参数方式
- ```python
  # 1.函数的常见4种参数：
    # 1.位置参数：
        # 理解：调用函数时根据函数定义的参数位置来传递参数
        # 例如：
          def 函数名(x,y):
              print(x,y)
          函数名(10,20) # 输出：10 20
        # 注意：传递的参数和定义的参数的顺序及个数必须一致

    # 2.关键字参数 
        # 理解：函数调用时通过 “参数名=参数值” 的形式传递参数
        # 作用：可以让函数更加清晰、容易使用，同时也清除了参数的顺序问题
        # 例如：
          def 函数名(x,y):
              print(x,y)
          函数名(y=20,x=10) # 输出：10 20
          函数名(10,y=20) # 输出：10 20 关键字和位置参数混用，位置参数在前且对应关系正确
        # 注意：函数调用时，如果有位置参数时，位置参数必须在关键字参数之前，但关键字参数之间不存在先后顺序

    # 3.缺省参数（默认参数）
      # 理解：用于定义函数时，为参数指定一个默认值，这样在调用函数时，如果不给参数赋值，则使用默认参数
      # 注意：所有位置参数必须出现在默认参数之前，包括函数定义和调用
      # 作用：当调用函数时，如果没有传递参数，则使用默认参数，如果传递了参数，则使用传递的参数
      # 例如：
        def 函数名(x,y=10):
            print(x,y)
        函数名(10) # 输出：10 10
        函数名(10,20) # 输出：10 20
      # 注意：
        # 函数调用时，如果为缺省参数传值则修改默认参数值，否则使用默认值
        # 默认参数必须指向不变对象！
 
    # 4.不定长参数
      # 理解：不定长参数也叫可变参数，用于不确定调用的时候会传递多少个参数（不传参也可以）的场景。
      # 作用：当调用函数时不确定参数个数时，可以使用不定长参数来接收传递的参数
      # 不定长参数的类型：位置参数、关键字参数
      # 例如：
        # 位置传递 （*args）
        def 函数名(*args):
            print(args)
        函数名(10) # 输出：(10,) 
        函数名(10,20) # 输出：(10, 20)
        函数名(10,20,30) # 输出：(10, 20, 30)
      # 注意：传进的所有参数都会被args变量收集，它会根据传进参数的位置合并为一个元组（tuple），args是元组类型，这就是位置传递
  
        # 关键字传递（**kwargs）
        def 函数名(**kwargs):
            print(kwargs)
        函数名(x=10) # 输出：{'x': 10}
        函数名(x=10,y=20) # 输出：{'x': 10, 'y': 20}
      # 注意：参数是 "键=值" 的形式，所有的 "键=值" 都会被kwargs收集，它是一个字典类型，这就是关键字传递
  ```

- 3.匿名函数
- ```python
  # 1.函数作为参数传递 
  # 函数本身是可以作为参数，传入另一个函数中进行使用的
  # 将函数传入的作用在于:传入计算逻辑，而非传入数据
  # 例如：
    def 函数名(x,y):
        return x+y
    def 函数名2(x,y,f):
        return f(x,y)
    函数名2(10,20,函数名) # 输出：30
    # 传递lambda表达式 
    函数名2(10,20,lambda x,y:x*y) # 输出：200
    函数名2(10,20,lambda x,y:x-y) # 输出：0
  
  # 2.lambda匿名函数
    # 1.函数的定义中
      # def关键字，可以定义带有名称的函数
      # lambda关键字，可以定义匿名函数（无名称）
    # 2.有名称的函数，可以基于名称重复使用
    # 3.匿名函数，只可临时使用一次。
    # 4.匿名函数的定义格式：lambda 参数列表: 函数体（一行代码）
      # lambda是关键字，表示定义匿名函数
      # 传入参数表示匿名函数的形式参数，多个参数用逗号隔开
      # 函数体，就是函数的执行逻辑，要注意：只能一行，无法写多行代码。
    # 例如：
      lambda x,y:x+y
  ```

- #### 17.文件操作
- 1.文件编码
- ```python 
  # 编码就是一种规则集合，记录了内容和二进制间进行转换的逻辑。
  # 编码有许多，我们最常用的是UTF-8编码。
  # 计算机只识别0和1，所以需要将内容翻译为0和1，这个过程就是编码。
  # 计算机读取文件时，需要将文件中的二进制内容翻译为文本内容，这个过程就是解码。
  # 编码和解码需要使用相同的编码规则，否则会乱码。
  ```

- 2.文件的读取
- ```python
  # 1.打开文件
    # 文件路径：打开文件时，需要指定文件路径，以及打开模式
    # 打开模式：
      # r 表示读取（读取文件），
      # w 表示写入（如果文件存在，原有内容删掉并写入新内容，如果文件不存在，创建文件并写入），
      # a 表示追加（如果文件存在，新内容会追加到老内容后面，如果文件不存在，创建新文件并写入）
    # 注意：默认打开模式为r
    # 语法：
      # 文件对象 = open(文件路径,打开模式,编码格式)
    # 例如：
      f = open("C:/demo/study.txt",'r'，encoding='utf-8')
      # encoding的顺序不是第三位，所以不能用位置参数，用关键字参数直接指定 
      # 此时的'f'是'open'函数返回的文件对象，对象是Python中一种特殊的数据类型，拥有属性和方法，可以使用对象.属性
      # 或对象.方法对其进行访问。
  
  # 2.读取文件操作方法
    # 1.read()方法
      # 语法：内容 = 文件对象.read(num)
      # 参数：num表示读取的文件内容的长度（单位是字节），如果不指定，表示读取所有内容。
  
    # 2.readlines()方法 
      # 注解：readlines可以按照行的方式把整个文件中的内容进行一次性读取，并且返回的是一个包含所有行的列表，其中每一行的数据为一个元素。
      # 语法：内容列表 = 文件对象.readlines(num)
      # 参数：num表示读取的文件内容的长度（单位是字节），如果不指定，表示读取所有内容。
  
    # 3.readline()方法
      # 注解：readline可以每次读取一行内容，它是从当前位置读取的，所以需要循环读取，直到读取完为止。
      # 语法：内容 = 文件对象.readline(num)
      # 参数：num表示读取的文件内容的长度（单位是字节），如果不指定，表示读取所有内容。
  
    # 4.for循环读取文件
      # 注解：使用for循环读取文件时，默认读取所有内容，所以不需要指定num参数。
      # 语法：
        # for 变量 in 文件对象:
          # 代码块
      # 例如：
         f = open("C:/demo/study.txt",'r'，encoding='utf-8')
         for line in f:
           print(f"每一行数据是：{line}")
  
    # 5.文件关闭
      # 注解：文件使用完毕后，需要关闭文件，释放内存。
      # 语法：文件对象.close()
      # 例如：
        f.close()
        time.sleep(50000)
        print("文件已关闭")
  
    # 6.with语句读取文件
      # 注解：使用with语句读取文件时，文件会自动关闭，无需手动关闭。
      # 语法：
        # with open(文件路径,打开模式,编码格式) as 文件对象:
          # 代码块
        # time.sleep(50000) 
      # 例如：
        with open("C:/demo/study.txt",'r'，encoding='utf-8') as f:
          print(f.read())
        time.sleep(50000)
  
    # 7.注意：
      # 读取文件时，默认情况下，文件指针会放在文件的开头位置，所以读取时，会从文件的开头开始读取。
      # 每次读取完成文件指针会移动当前读取的位置，以便再次读取时，从上次读取的位置开始读取。
  ```

- 3.文件的写入
- ```python
  # 语法： 
    # 文件对象=open(文件路径,'w',编码格式)
    # 文件对象.write(内容) 写入内容到缓存中
    # 文件对象.flush() 刷新缓存内容到文件
    # 文件对象.close() 关闭文件（带有flush()方法功能，使用close就无需在调用flush方法）
    # 参数：内容表示要写入的内容，可以是字符串、列表、元组、字典等。
    
    # 例如：
      f = open("C:/demo/study.txt",'w'，encoding='utf-8')
      f.write("hello world")
      f.write("你好，世界")
      f.write("你好，世界".encode('utf-8'))
      f.flush() 
      f.close()
  
  # 注意：
    # 直接调用write,内容并未真正写入文件，而是会积攒在程序的内存中，称之为缓冲区。
    # 当调用flush的时候，内容会真正写入文件。
    # 这样做是避免频繁操作硬盘，导致效率下降（积攒一堆，一次性写入硬盘，提高效率）。
    # 调用flush后，缓冲区清空。
  ```

- 4.文件的追加写入
- ```python
  # 语法：
    # 文件对象=open(文件路径,'a',编码格式)
    # 文件对象.write(内容) 写入内容到缓存中 
    # 文件对象.flush() 刷新缓存内容到文件
    # 文件对象.close() 关闭文件（带有flush()方法功能，使用close就无需在调用flush方法）
    # 参数：内容表示要写入的内容，可以是字符串、列表、元组、字典等。
    
    # 例如：
      f = open("C:/demo/study.txt",'a'，encoding='utf-8')
      f.write("hello world")
      f.write("你好，世界")
      f.write("你好，世界".encode('utf-8'))
      f.flush()
      f.close()
  
  # 注意：
    # a模式，文件不存在会自动创建。
    # 文件存在，内容会追加到文件末尾。
    # 可以使用"\n"来换行。
  ```

- #### 18.异常

- 1.异常的定义

- ```python
  # 异常的定义：
    # 程序在执行过程中，出现的错误，称为异常。
    # 异常是程序在运行过程中出现的错误，是阻止程序正常执行的问题。
  ```

- 2.异常的捕获

- ```python
  # 1.基础语法：
    # try:
      # 可能出现异常的代码
    # except:（默认全部异常捕获） 
      # 异常处理代码
    # else:
      # 没有异常执行的代码
    # finally:
      # 无论是否出现异常都会执行的代码
  
  # 例如：
    
    try:
      print(1/0)
    except:
      print("除数不能为0")
    else:
      print("没有异常")
    finally:
      print("无论是否出现异常都会执行的代码")
  
  # 2.捕获指定异常语法：
    # try:
      # 可能出现异常的代码
    # except 异常类型 as 别名:（可以写多个except，捕获指定异常，不写默认全部异常捕获）
      # 异常处理代码
    # else:
      # 没有异常执行的代码
    # finally:
      # 无论是否出现异常都会执行的代码
  
  # 例如：
    
    try:
      print(1/0)
    except ZeroDivisionError:
      print("除数不能为0")
    else:
      print("没有异常")
    finally:
      print("无论是否出现异常都会执行")
  
  # 注意：
    # 异常的捕获，可以捕获一个异常，也可以捕获多个异常。
  
  # 3.捕获多个异常语法：
    # try:
      # 可能出现异常的代码
    # except 异常类型1 as 别名:
      # 异常处理代码1
    # except 异常类型2 as 别名:
      # 异常处理代码2
    # except 异常类型3 as 别名:
      # 异常处理代码3
    # else:
      # 没有异常执行的代码
    # finally:
      # 无论是否出现异常都会执行的代码
  
   # try:
      # 可能出现异常的代码
    # except (异常类型1,异常类型2...) as 别名:
      # 异常处理代码
    # else:
      # 没有异常执行的代码
    # finally:
      # 无论是否出现异常都会执行的代码
  
  # 例如：
    
    try:
      print(1/0)
    except ZeroDivisionError as e:
      print("除数不能为0")
    except NameError as e:
      print("变量未定义")
    except:
      print("其他异常")
    else:
      print("没有异常")
    finally:
      print("无论是否出现异常都会执行")
  
  # 注意：
    # 1.一个try语句中可以写多个except语句，用来捕获不同类型的异常。
    # 2.else 语句是可选的，当不需要对异常进行特殊的处理时，可以省略else语句。
    # 3.finally 语句是可选的，当不需要在异常发生时执行一些代码，也可以省略finally语句。 
  ```

- 3.异常的传递
- ```python
  # 1.异常的传递
    # 异常的传递是从内到外，即从函数内部到函数外部。
    # 如果在函数内部发生了异常，并且没有处理这个异常，那么异常会传递到函数调用的地方。
    # 如果在函数调用的地方也没有处理这个异常，那么异常会继续传递，直到它被处理。
    # 如果在异常传递到main()函数时还没有被处理，那么程序会终止，并输出异常信息。
  
  # 2.异常的传递示例
    
    def fun01():
      print("fun01开始")
      # 异常传递到fun01()函数内部，但是没有处理这个异常
      # 异常会继续传递到fun02()函数内部
      print(1/0)
      print("fun01结束")
    
    def fun02():
      print("fun02开始")
      # 异常传递到fun02()函数内部，但是没有处理这个异常
      # 异常会继续传递到main函数内部
      fun01()
      print("fun02结束")
    
    def main(): 
      print("main开始")
      # 异常在main()函数中被处理
      try:
          fun02()
      except ZeroDivisionError as e:
          print("捕获到异常：",e)
      print("main结束")
    
    main()
  ```

- #### 19.模块

- 1.模块的定义

- ```python
    # 1.模块的定义
      # 模块是Python的一个基本组成部分，它是一个包含Python代码的文件。模块可以被其他模块导入和使用。
      # 模块可以用来组织代码，提高代码的可维护性和复用性。
      # 直白的说：
        # 1.模块是Python中一个文件，可以包含函数、类、变量等。
        # 2.模块可以被其他模块导入和使用。
  ```

- 2.模块的导入

- ```python
    # 1.模块的导入语法：
      # 导入模块可以使用import关键字，例如：
        # import 模块名
        # import 模块名 as 别名
        # from 模块名 import 类|变量| 方法
        # from 模块名 import *
        # from 模块名 import 功能名 as 别名
   
    # 2.模块的导入示例：
      # import 模块名
      import time
      # 模块的使用
      time.sleep(1)
  
      # import 模块名 as 别名
      import time as t
      # 模块的使用
      t.sleep(1)
  
      # from 模块名 import 类|变量| 方法
      from time import sleep
      # 模块的使用
      sleep(1)
  
      # from 模块名 import *
      from time import *
      # 模块的使用
      sleep(1)
  
      # from 模块名 import 功能名 as 别名
      from time import sleep as s
      # 模块的使用
      s(1)
  
    # 注意：
      # 1.导入方式：[from 模块名] import [模块|类|变量|函数|*] [as 别名]
      # 1.from可以省略，直接import即可
      # 2.as 别名可省略
      # 3.通过"."来确定层级关系
      # 4.模块导入一般写在代码文件的开头位置
  ```

- 3.自定义模块

- ```python
    # 1.自定义模块的定义
      # 自定义模块是用户自己创建的模块，可以包含函数、类、变量等。
      # 自定义模块可以被其他模块导入和使用。
      # 自定义模块的命名规则： 
        # 1.模块名不能和Python内置模块名冲突，例如：不能使用内置模块名如：time、random等。
        # 2.模块名可以由字母、数字、下划线组成，但不能包含空格。
        # 3.模块名可以由多个单词组成，可以使用下划线或驼峰命名法。
        # 4.模块名不区分大小写，例如：time和Time是同一个模块。
      # 自定义模块的创建：
        # 1.创建一个.py文件，例如：my_module.py
        # 2.在文件中定义函数、类、变量等。
        # 3.在文件中使用if __name__ == "__main__":来判断是否是直接运行该模块，如果是则执行相应的操作。
        # 4.在文件中使用__all__=['test1'] 来控制 from 模块名 import *导入功能哪些可以导入。
        # 5.不同模块，同名的功能，如果都被导入，那么后导入的会覆盖先导入的。
  ```

- #### 20.包
- 1.什么是包
- ```python
    # 包是包含多个模块的文件夹，在包中有一个__init__.py文件，
    # 该文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。
    # __init__.py可以是空文件，也可以有Python代码，因为__init__.py本身就是一个模块，而它的模块名就是包名。
  ```

- 2.包的创建

- ```python
  # 1.步骤：
    # 1.创建一个文件夹，例如：my_package
    # 2.在文件夹中创建一个__init__.py文件，该文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。
    # 3.在文件夹中创建多个模块文件，例如：my_module1.py、my_module2.py等。
    # 4.在__init__.py文件中可以使用from 模块名 import *来控制 from 包名 import *导入功能哪些可以导入。
    # 5.不同包，同名的功能，如果都被导入，那么后导入的会覆盖先导入的。
  
  # 2.pycharm中的基本步骤：
    # [New] -> [Python Package] -> 输入包名称 -> 点击[OK] -> 新建功能模块（有联系的模块）
    # 注意：新建包后，包内部会自动创建__init__.py文件，这个文件控制着包的导入行为（通过 __all__ 控制哪些可以导入）。
  ```

- 3.第三方包

- ```python
  # 1.什么是第三方包
    # 第三方包是别人已经写好的包，我们可以直接使用。
  # 2.第三方包的安装：
      # 1.使用pip命令安装，例如：pip install requests
      # 2.使用pip命令安装指定版本，例如：pip install requests==2.24.0
      # 3.使用pip命令安装指定路径，例如：pip install D:\python_code\requests-2.24.0-py3-none-any.whl
      # 4.使用pip命令安装指定网站的文件，例如：pip install i https://pypi.tuna.tsinghua.edu.cn/simple/ requests
  ```

-  #### 21.可视化图表
- 1.JSON数据格式

- ```python
  # 1.JSON是一种轻量级的数据交互格式，可以按照JSON指定的格式去组织和封装数据
    # 1.JSON数据格式是键值对的形式，例如：{" name ": " 小明 "}、[{" name ": " 小明 "},{" name ": "小红 "}] 
  # 2.JSON本质上是一个带有特定格式的字符串
  # 3.python数据和JSON数据之间的转换
    # import json
    # json.dumps(python数据,ensure_ascii=False) 将python数据转换为JSON数据
    # ensure_ascii默认是True，代表将所有的中文转换为unicode编码，如果设置为False，代表将所有的中文转换为中文
    # json.loads(json数据) 将JSON数据转换为python数据
    # 例如：
        json_str = '{" name ": " 小明 "}'
        python_data = [{"name ": " 小明 "},{"name ": " 小红 "}]
        json_data = json.dumps(python_data,ensure_ascii=False)
        json_data = json.loads(json_str)
  ```

- 2.[pyecharts](https://pyecharts.org/#/zh-cn/)模块（使用案例可参考[官方画廊](https://gallery.pyecharts.org/)）

- ```python
  # 1.pyecharts模块是python中一个可视化图表的模块，可以方便的绘制出柱状图、折线图、饼图、散点图等
    # 1.安装pyecharts模块：
        pip install pyecharts
    # 2.导入pyecharts模块：
        # 全部导入
        import pyecharts
        # 按需导入
        from pyecharts.charts import Line
    # 3.使用pyecharts模块绘制图表：
        # 1.创建一个图表对象：
        chart = pyecharts.Bar()
        # 2.添加x轴数据：
        chart.add_xaxis(["衬衫","羊毛衫","雪纺衫","裤子","高跟鞋","袜子"])
        # 3.添加y轴数据：
        chart.add_yaxis("商家A",[5,20,36,10,75,90])
        # 4.设置图表的标题：
        chart.set_title("商家销售统计")
        # 5.设置图表的图例：
        chart.set_global_opts(title_opts=opts.TitleOpts(title="商家销售统计"))
        # 6.保存图表到文件：
        chart.render("bar_chart.html")
        # 7.生成了一个bar_chart.html文件，可以在浏览器中打开查看图表
    # 4.pyecharts配置选项
        # 1.全局配置选项 （set_global_opts，更多配置查看官方文档）
            # 导入配置项：
            from pyecharts.options import TitleOpts, LegendOpts, ToolboxOpts
            # 1.设置图表的标题：
            chart.set_global_opts(title_opts=TitleOpts(title="商家销售统计")) 
            # 2.设置图表的图例：
            chart.set_global_opts(legend_opts=LegendOpts(orient="vertical", pos_left="2%", pos_top="15%"))
        # 2.系列配置选项 （更多配置查看官方文档）
            # 1.设置系列名称：
            chart.set_series_opts(label_opts=opts.LabelOpts(formatter="{b}: {c}"))
            # 2.设置系列颜色：
            chart.set_series_opts(linestyle_opts=opts.LineStyleOpts(color="#CD0000"))
  ```

- 3.pyecharts地图
-  ```python
   # 1.导入pyecharts模块：
    from pyecharts import Map
    # 2.创建地图对象：
    map = Map()
    # 3.添加数据：
    map.add("商家A",[("北京",100),("上海",200),("深圳",300)],
        maptype="china",
        is_visualmap=True,
        visual_range=[0,500],
        visual_text_color="#fff"
    )
    # 4.设置配置选项：
    map.set_global_opts(
        title_opts=opts.TitleOpts(title="商家销售统计"),
        legend_opts=opts.LegendOpts(is_show=False)
    )
    # 5.保存图表：
    map.render("map_chart.html")
    # 6.打开图表：
    # 打开浏览器，输入http://localhost:8000/map_chart.html
    # 注意：如果无法打开，请检查pyecharts是否安装成功
   ``` 

- #### 22.对象
- 1.类的定义和使用
- ```python
  # 类的定义：
    # class 是关键字，表示要定义类
    # 类的属性，即定义在类中的变量（成员变量）
    # 类的行为，即定义在类中的函数（成员方法）
  # 语法：
    # class 类名:
        # 类的属性
        # 属性名 = 属性值
        # 类的方法
        # def 方法名(self,参数列表):
            # 方法体
  # 类的实例化（创建类对象的语法）
    # 对象名 = 类名()
  # 例如：
    class Student:
        name = "张三"
        age = 18
        def say_hello(self):
            print("你好，我是" + self.name)
    # 创建一个学生对象
    stu = Student()
    # 调用对象的方法
    stu.say_hello()
    # 访问对象的属性
    print(stu.name)
    print(stu.age)
  
  # self作用：
    # self 表示类对象本身的意思。
    # 只有通过self,成员方法才能访问类的成员变量
    # 在类的方法中，第一个参数必须是 self，而 self 只是参数名，你也可以使用其他参数名，但是约定俗成使用self。
    # self出现在形参数列表中，但不占用参数位置，传参的时候可以忽略它。
  ```

- 2.构造方法
- ```python
  # Python类可以使用：__init__()方法,称之为构造方法
  # 构造方法的作用：
    # 1.完成对象的初始化
    # 2.为对象的成员变量赋初值
  # 语法：
    # def __init__(self,参数列表):
        # 方法体
  # 例如：
    class Student:
        def __init__(self,name,age):
            self.name = name
            self.age = age
    # 创建一个学生对象
    stu = Student("张三",18)
    # 访问对象的属性
    print(stu.name)
    print(stu.age)
  ```

- 3.内置方法（魔术方法）
- ```python
  # 对象的方法名前面加上两个下划线__，就变成了内置方法，也称为魔术方法
  # 作用：
    # 1.对象和类相关的操作
    # 2.运算符重载
  
  # 1.__str__字符串方法
    # 作用：
      # 1.打印对象时，默认输出对象的内存地址
      # 2.可以自定义输出内容
    # 语法：
      # def __str__(self):
          # 方法体
    # 例如：
      class Student:
          def __init__(self,name,age):
              self.name = name
              self.age = age
          def __str__(self):
              return "学生姓名：" + self.name + "，年龄：" + str(self.age)
      # 创建一个学生对象
      stu = Student("张三",18)
      # 打印对象
      print(stu)
  
  # 2.__len__长度方法
    # 作用：
      # 1.用于计算对象的长度
    # 语法：
      # def __len__(self):
          # 方法体
    # 例如：
      class Student:
          def __init__(self,name,age):
              self.name = name
              self.age = age
          def __str__(self):
              return "学生姓名：" + self.name + "，年龄：" + str(self.age)
          def __len__(self):
              return len(self.name)
      # 创建一个学生对象
      stu = Student("张三",18)
      # 打印对象
      print(len(stu))
  
  # 3.__lt__比较方法
     # 作用：
       # 1.用于比较两个对象的大小（不含相等）
     # 语法：
       # def __lt__(self,other):
           # 方法体
     # 例如：
       class Student:
           def __init__(self,name,age):
               self.name = name
               self.age = age
           def __str__(self):
               return "学生姓名：" + self.name + "，年龄：" + str(self.age)
           def __lt__(self,other):
               return self.age < other.age
       # 创建两个学生对象
       stu1 = Student("张三",18)
       stu2 = Student("李四",20)
       # 比较两个学生对象
       print(stu1 < stu2)
  
  # 4.__le__比较方法 
     # 作用：
       #  1.用于比较两个对象的大小（含相等） 
     # 语法：
       # def __le__(self,other):
           # 方法体
     # 例如：
       class Student:
           def __init__(self,name,age):
               self.name = name
               self.age = age
           def __str__(self):
               return "学生姓名：" + self.name + "，年龄：" + str(self.age)
           def __le__(self,other):
               return self.age <= other.age
       # 创建两个学生对象
       stu1 = Student("张三",18)
       stu2 = Student("李四",20)
       # 比较两个学生对象
       print(stu1 <= stu2)
  
  # 5.__eq__比较方法 
     # 作用：
       # 1.用于比较两个对象是否相等
     # 语法：
       # def __eq__(self,other):
           # 方法体
     # 例如：
       class Student:
           def __init__(self,name,age):
               self.name = name
               self.age = age
           def __str__(self):
               return "学生姓名：" + self.name + "，年龄：" + str(self.age)
           def __eq__(self,other):
               return self.age == other.age
       # 创建两个学生对象
       stu1 = Student("张三",18)
       stu2 = Student("李四",20)
       # 比较两个学生对象
       print(stu1 == stu2)
  ```

- 4.封装
- ```python
  # 1.什么是封装
    # 封装就是将属性和方法封装到一个类中
  # 2.什么是私有成员
    # 在类中提供仅供内部使用的属性和方法，而不对外开放（类对象无法使用）
    # 私有成员就是以两个下划线开头(__)的成员
  # 3.私有成员的访问限制
    # 类对象无法访问私有成员
    # 类中的其他成员可以访问私有成员
  # 4.语法：
    # 私有成员的定义
      # def __方法名(self,参数):
          # 方法体
      # __变量名 = None
    # 例如：
      class Student:
          def __init__(self,name,age):
              self.__name = name
              self.__age = age
          def __sing(self):
              print("私有方法")
      # 创建学生对象
      stu = Student("张三",18)
      # 访问私有成员
      print(stu.__name) # 报错
      print(stu.__age) # 报错
      stu.__sing() # 报错
  ```

- 5.继承
- ```python
  # 继承的基础语法：
  # 1.什么是继承   
    # 继承就是子类继承父类的属性和方法
  # 2.单继承语法：
    # 定义父类
      # class 父类名:
          # 方法体
    # 定义子类
      # class 子类名(父类名):
          # 方法体
    # 例如：
      class Animal:
          def __init__(self,name):
              self.name = name
          def eat(self):
              print(self.name + "正在吃东西")
      class Dog(Animal):
          def bark(self):
              print(self.name + "正在汪汪叫")
      # 创建狗对象
      dog = Dog("旺财")
      dog.eat() # 旺财正在吃东西
      dog.bark() # 旺财正在汪汪叫
  
  # 3.多继承语法：
    # 定义父类1
      # class 父类名1:
          # 方法体
    # 定义父类2
      # class 父类名2:
          # 方法体
    # 定义子类
      # class 子类名(父类名1,父类名2,...):
          # 方法体
    # 例如：
      class A:
          def sing(self):
              print("sing")
  
          def foo(self):
              print("A")
      class B:
          def run(self):
              print("run")
  
          def foo(self):
              print("B")
      class C(A,B):
          pass # 语法补全 类内不写任何内容
      # 创建C对象
      c = C()
      c.sing() # sing
      c.run() # run
      c.foo() # A
  
  # 单继承和多继承
    # 单继承：子类只继承一个父类
    # 多继承：子类继承多个父类，按照顺序，从左到右依次继承
    # 多继承中：如果父类有同名方法或属性，先继承的优先级高于后继承
  # pass 关键字的作用
    # pass是占位语句，用来保证函数（方法）或类定义的完整性，表示无内容，空的意思
  
  
  # 复写和使用父类成员
    # 1.什么是复写
      # 子类中重新定义父类中同名的方法或属性
    # 2.复写属性和方法 
      # 子类中重新定义父类中同名的属性
      # 子类中重新定义父类中同名的方法
      # 例如：
        class Animal:
          def __init__(self,name):
              self.name = name
          def eat(self):
              print(self.name + "正在吃东西")
        class Dog(Animal):
          def eat(self):
              print(self.name + "正在吃骨头")
        # 创建Dog对象
        dog = Dog("旺财")
        dog.eat() # 旺财正在吃骨头
        # 创建Animal对象
        animal = Animal("小狗")
        animal.eat() # 小狗正在吃东西
   # 3.调用父类同名成员
    # 子类中调用父类中同名的属性和方法
    # 方式1：
      # 使用成员变量：父类名.成员变量名
      # 使用成员方法：父类名.成员方法名(self)
      # 例如： 
        class Animal: 
          def sing(self):
              print("Animal is singing")
  
        class Dog(Animal):
          def sing(self):
             Animal.sing(self) # 调用父类同名方法
  
    # 方式2：
      # 使用成员变量：super().成员变量名
      # 使用成员方法：super().成员方法名(self)
      # 例如：  
        class Animal:
            def sing(self):
                print("Animal is singing")
  
        class Dog(Animal):
            def sing(self):
                super().sing()
                print("Dog is singing")
  
  # 注意：只可以在子类内部调用父类的同名成员，子类的实体类对象调用默认是调用子类的复写的
     
  ```

- 6.类型注解
- ```python
  # 1.什么是类型注解
    # PyCharm等开发工具对代码做类型推断协助代码提示
    # 类型注解不会影响程序的运行，但可以用来帮助开发者和编辑器检查代码的错误
  # 2.语法：
    # 语法1：变量:类型
    # 语法2：在注释中，#type: 类型
    # 例如：
      def add(a: int, b: int) -> int:
          return a + b
  
      x: int = 10
      y: str = "Hello"
  # 3.类型注解的种类
    # 基本数据类型：int, float, bool, str,
    # 基本容器类型：list, tuple, dict, set
    # 特殊类型：Any（任意类型）, Union（联合类型）, Optional（可选类型）
    # 例如：
      # 1.参数类型注解及返回值类型注解
      def add(a: int, b: int) -> int:
          return a + b
      # 2.基础数据类型注解
      x: int = 10
      y: str = "Hello"
      # 特殊类型注解
      z: Any = 10
      z: Union[int, str] = 10
      z: Optional[int] = 10
      # 3.基础容器类型注解
      a1: list = [1, 2, 3]
      b1: tuple = (1, 2, 3)
      c1: dict = {"a": 1, "b": 2}
      d1: set = {1, 2, 3}
      # 4.容器类型详细注解
      d: Dict[str, int] = {"a": 1, "b": 2}
      c: tuple[int, str] = (1, "2")
      f: list[int] = [1, 2, 3]
      g: set[int] = {1, 2, 3}
      # 5.类对象类型注解
      class Person:
          def __init__(self, name: str, age: int):
              self.name = name
              self.age = age
  
      p1: Person = Person("Tom", 18)
      # 6.在注释中进行类型注解
      var_2 = "Hello"  # type: str
      def func():
          return 123  # type: int
      var_3 = func() # type: init
      # 7.联合类型
      from typing import Union
      var_4: list[Union[int, str]] = [1, "2"]
      var_6: dict[Union[int, str], Union[int, str]] = {"a": 1, "b": "2"}
      def func(a: Union[int, str], b: Union[int, str]) -> Union[int, str]:
          return a + b
      # 8.可选类型
      from typing import Optional
      var_5: Optional[int] = 10
      # 

  # 注意：
    # 元组类型设置类型详情注解，需要将每一个元素都标记出来
    # 字典类型设置类型详情注解，需要2个类型，第一个是key，第二个是value
    # 类型注释只是提示性的，并非决定性的。数据类型和注解类型无法对应也不会导致报错
  ```

- 7.多态
- ```python
   # 多态：指的是：多种状态，即完成某个行为时，使用不同的对象会得到不同的状态。
   # 多态常作用在继承关系上：
      # 比如 
        # 函数（方法）形参声明接收父类对象
        # 实际传入父类的子类对象进行工作

      # 即：
        # 以父类做定义声明
        # 以子类做实际工作
        # 用以获得同一行为，不同状态
   # 抽象类（接口）
     # 父类用来确定有哪些方法，具体的方法实现由子类自行决定，这种写法叫做抽象类（也可以称之为接口）
     # 抽象类：含有抽象方法的类称之为抽象类
     # 抽象方法：方法体是空实现的（pass)称之为抽象方法
   
   # 例如：
      # 定义一个父类
      class Animal: 
          def __init__(self, name: str):
              self.name = name
          def eat(self):
              pass
      # 定义一个子类
      class Dog(Animal):
          def __init__(self, name: str):
              super().__init__(name)
          def eat(self):
              print(f"{self.name} is eating")
      # 定义一个子类
      class Cat(Animal):
          def __init__(self, name: str): 
              super().__init__(name)
          def eat(self):
              print(f"{self.name} is eating")
      # 创建一个Dog对象
      dog = Dog("旺财")
      # 创建一个Cat对象
      cat = Cat("Tom")
      # 调用Dog类和Cat类的方法
      dog.eat()
      cat.eat() 
  
   # 抽象类作用：
     # 多用于做顶层设计（设计标准），以便子类做具体实现
     # 也是对子类的一种软性约束，要求子类必须复写（实现）父类的一些方法
     # 并配合多态使用，获得不同的工作状态。
  ```

- #### 23.SQL
- 1.MySQL数据库
- ```python
  # MySQL的安装
  # 1.下载MySQL安装包 
    # https://dev.mysql.com/downloads/mysql/
    # https://www.mysql.com/
  # 2.安装MySQL
    # 选择自定义安装，选择安装路径，选择服务名，选择端口号，选择其他选项，选择安装
  # 3.配置环境变量
    # 在系统变量中新建MYSQL_HOME，值为MySQL的安装路径
    # 在系统变量中新建Path，在Path中添加%MYSQL_HOME%\bin
  # 4.启动MySQL服务
    # 以管理员身份运行cmd，输入net start mysql启动MySQL服务
  # 5.连接MySQL
    # 以管理员身份运行cmd，输入mysql -uroot -p连接MySQL
    # 输入密码，回车
  # 6.退出MySQL
    # 输入exit退出MySQL
  ```

- 2.MySQL图形化工具（DBeaver）
- ```python
  # 1.下载DBeaver
    # https://dbeaver.io/download/  
  # 2.安装DBeaver
    # 选择自定义安装，选择安装路径，选择其他选项，选择安装
  # 3.配置DBeaver
    # 选择连接类型为MySQL
    # 输入主机名，端口号，用户名，密码
  # 4.连接MySQL
    # 输入密码，回车
  ```

- 3.SQL语言基础
- ```python
  # 1.SQL语言分类
    # 1.DDL（数据定义语言）
      # 用来定义数据库对象：数据库，表，列等
      # 关键字：create,drop,alter等
    # 2.DML（数据操作语言）
      # 用来对数据库中表的记录进行增删改
      # 关键字：insert,delete,update等
    # 3.DQL（数据查询语言）
      # 用来查询数据库中表的记录
      # 关键字：select,where等
    # 4.DCL（数据控制语言）
      # 用来定义数据库的访问权限和安全级别，及创建用户
      # 关键字：grant,revoke等
  
  # 2.SQL语法特征
    # 1.大小写不敏感
    # 2.SQL可以写在一行或者多行，最后以;号结尾
    # 3.关键字不能被缩写
    # 4.SQL可以写在单引号或者双引号中  
  
  # 3.SQL支持注释
    # 1.单行注释：-- 注释内容（-- 后面一定要有一个空格）
    # 2.单行注释：# 注释内容（# 后面可以没有空格，推荐加上）
    # 3.多行注释：/* 注释内容 */
  
  # 4.DDL-库管理
    # 1.查看数据库
      # show databases;
    # 2.使用数据库 
      # use 库名;
    # 3.创建数据库
      # create database 库名[charset utf8];
    # 4.删除数据库
      # drop database 库名;
    # 5.修改数据库
      # alter database 库名 charset gbk;
    # 6.查看当前使用的数据库
      # select database();
  
  # 5.DDL-表管理
    # 1.创建表
      # create table 表名(
        # 列名1 数据类型1,
        # 列名2 数据类型2,
        # ...
      # );
      # 数据类型：
        # 整型：int(11) 11 表示显示的最大宽度，如果不够11位，则左边用0填充
        # 浮点型：float(M,D) M 表示总位数，D 表示小数位数
        # 字符串型：varchar(M) M 表示字符串的最大长度，如果插入的字符串的长度大于M，则从开头截断
        # 日期型：date
        # timestamp：时间戳
    # 2.查看表结构
      # desc 表名; 
    # 3.查看表创建语句
      # show create table 表名\G;
    # 4.修改表
      # alter table 表名 执行动作;
        # 执行动作：
          # 添加列：alter table 表名 add 列名 数据类型;
          # 修改列：alter table 表名 modify 列名 数据类型;
          # 删除列：alter table 表名 drop 列名;
          # 修改列名：alter table 表名 change 旧列名 新列名 数据类型;
          # 修改表名：alter table 表名 rename 新表名;
    # 5.删除表
      # drop table 表名;
      # drop table if exists 表名;
    # 6.复制表
      # create table 表名 like 被复制的表名;
    # 7.查看有哪些表
      # show tables; 注意：需要先选择数据库，否则会报错
      # show tables from 库名;

  # 6.DML-增删改
    # 1.插入数据
      # insert into 表名(列名1,列名2,...) values(值1,值2,...)[,(值1,值2,...),(值1,值2,...)...];
      # insert into 表名 values(值1,值2,...)[,(值1,值2,...),(值1,值2,...)...];
    # 2.删除数据
      # delete from 表名 where 条件;
    # 3.修改数据
      # update 表名 set 列名1=值1,列名2=值2,... where 条件;
    #  注意： 字符串的值，出现在SQL语句中，必须使用单引号包裹，数值型的值可以不使用单引号

  # 7.DQL-查询
    # 1.基础查询
      # select 列名1,列名2,...|* from 表名;
    # 2.条件查询
      # select 列名1,列名2,...|* from 表名 where 条件;
      # 条件：
        # 比较运算符：> < = != <> >= <=
        # 逻辑运算符：and or not
        # 模糊查询：like
          # % 表示任意多个字符
          # _ 表示任意单个字符
        # 范围查询：in,not in
        # 空判断：is null,is not null
        # 优先级：小括号，not，比较运算符，逻辑运算符
    # 3.分组聚合
      # select 列名1,聚合函数... from 表名[where 条件] group by 列名1;
      # 注意：group by 列名，表示按照哪一列进行分组，
      # 聚合函数：将一列数据作为一个整体，进行纵向计算
      # count(列|*)：计算个数
      # max(列)：计算最大值
      # min(列)：计算最小值
      # sum(列)：计算总和
      # avg(列)：计算平均值
      # 注意：以上分组函数都忽略null值
      # 注意：sum,avg一般用于处理数值型
      # 注意：max,min,一般处理字符型
      # 注意：count一般用于处理任何数据类型
      # 注意：group by 中出现了哪个列，哪个列才能出现在select中的非聚合中
    # 4.排序分页
      # 语法：
        # select 列名1,列名2,...|*|聚合函数 from 表名[where 条件] 
        # group by 列名 （分组）
        # order by 列名1 [asc|desc],列名2 [asc|desc],... （排序）
        # limit 起始索引[,每页的条目数]; （分页）
      # 注意：排序和分页可以单独使用，也可以一起使用
      # 注意：where、group by、order by、limit均可按需求省略，
      # 注意：select 和 from 是必须写的
      # 注意:执行顺序 
        # from -> where -> group by -> select -> order by -> limit
  ```

- 4.python操作MySQL基础
    - ```python
  # 在python中使用第三方库pymysql操作MySQL
      # 1.安装pymysql
        # pip install pymysql
      # 2.导入pymysql
        # from pymysql import Connection
      # 3.建立连接
        # conn = Connection(
                           # host='主机名',
                           # port=端口号,
                           # user='用户名',
                           # password='密码',
                           # autocommit=True, 是否自动提交数据库
                           # charset='utf8')
      # 4.建立游标
        # cursor = conn.cursor()
      # 5.选择数据库
        # cursor.execute('use 数据库名')
      # 6.执行SQL语句
        # cursor.execute(sql语句)
      # 7.获取结果（元组套元组）
        # result = cursor.fetchall()
      # 8.确认插入信息（执行插入或者修改表内容时需要执行的方法，将数据提交到数据库中，autocommit设置为True,则不需要手动提交事务）
        # conn.commit()
      # 9.关闭游标
        # cursor.close()
      # 10.关闭连接
        # conn.close()
      # 11.注意：
        # 1.SQL语句中的字符串需要使用引号引起来
        # 2.SQL语句中的变量需要使用%s占位
        # 3.SQL语句中的变量需要使用%r打印
    ```

- #### 24.PySpark
- 1.Spark
- ```python
  # Spark 是什么
    # Apache Spark是用于大规模数据（large-scale data）处理的统一分析引擎。
    # 简单说：Spark是一款分布式计算框架，用于调度成百上千的服务器集群，计算TB、PB乃至EB级别的海量数据。
  ```

- 2.PySpark
- ```python
  # Spark对python的支持重点体现在，python的第三方库：pyspark之上
  # 大数据方向：python -> Hadoop -> Spark -> Hive
  # 1.pyspark库的安装
    # pip install pyspark
    # pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyspark
  
  # 2.构建PySpark执行环境入口对象
    # 想要使用pyspark库完成数据处理，首先需要构建PySpark执行环境入口对象
    # PySpark的执行环境入口对象是：类 SparkContext 的类对象
    # 导包
      # from pyspark import SparkContext, SparkConf
    # 创建SparkConf类对象 
      # conf = SparkConf().setMaster("local[*]").setAppName("test_spark_app")
    # 基于SparkConf类对象创建SparkContext类对象
      # sc = SparkContext(conf=conf)
    # 打印PySpark的运行版本
      # print(sc.version)
    # 停止SparkContext类对象的运行（停止PySpark的程序）
      # sc.stop()
  
  # 3.PySpark的编程模型
    # SparkContext类对象，是PySpark编程中一切功能的入口
    # PySpark的编程模型，主要分为三大步骤：
      # 1.数据输入：通过SparkContext类对象的成员方法完成数据的读取操作，读取后得到RDD类对象
      # 2.数据处理：通过RDD类对象的成员方法完成数据的处理操作
      # 3.数据输出：将处理完成后的RDD对象，调用各种成员方法完成写出文件、转换为list等操作
    ```
- 3.注意： 如果windows系统 ，运行的时候报错了未配置
  [HADOOP_HOME](http://archive.apache.org/dist/hadoop/common/hadoop-3.0.0/hadoop-3.0.0.tar.gz)
  ,点击下载配置环境（建议使用迅雷下载会快的很！！！）
- ```python
   # 1.下载完成后找个合适的位置进行解压
   # 2.在环境变量中设置 
       # HADOOP_HOME = D:\bigdata\hadoop-3.0.0 （路径是你存放 hadoop-3.0.0文件的真实路径）
       # PATH = %HADOOP_HOME%\bin;%HADOOP_HOME%\sbin;
   # 3.在cmd中输入hadoop version 测试是否配置成功
  ```
- 嘿嘿~ 运行pycharm代码是不是还在报错了？ 不要慌，稳住我们能赢！下载这两个文件:
  [hadoop.dll 和 winutils.exe](https://gitee.com/lixindekongjian/hadoop.git)，
  将这两个文件放在 D:\bigdata\hadoop-3.0.0\bin 目录下，然后将`hadoop.dll`文件复制一份放在
  C:\Windows\System32 目录下，重启电脑就行了

- 4.数据输入
- ```python
   # 1.PySpark支持多种数据输入，在输入完成后，都会得到一个RDD（弹性分布式数据集 Resilient Distributed Dataset）类对象
   # 2.PySpark针对数据的处理，都是以RDD类对象作为载体，即：
     # 数据存储在RDD内
     # 各类数据的计算方法，也都是RDD的成员方法
     # RDD的数据计算方法，返回值依旧是RDD对象
  # 3.PySpark支持通过SparkContext对象的parallelize成员方法，将 list、tuple、set.dict、str转换为PySpark的RDD类对象
     # 例如：
     from pyspark import SparkContext,SparkConf
     conf = SparkConf().setMaster("local").setAppName("test")
     sc = SparkContext(conf = conf)
     rdd1 = sc.parallelize(["a","b","c"]) # 将list转换为RDD
     rdd2 = sc.parallelize(("a","b","c")) # 将tuple转换为RDD
     rdd3 = sc.parallelize({"a":1,"b":2,"c":3}) # 将dict转换为RDD
     rdd4 = sc.parallelize("abc") # 将str转换为RDD
     rdd5 = sc.parallelize({"a","b","c"}) # 将set转换为RDD
     print(rdd1.collect())  # 输出：['a', 'b', 'c']
     print(rdd2.collect())  # 输出：['a', 'b', 'c']
     print(rdd3.collect())  # 输出：['a', 'b', 'c']
     print(rdd4.collect())  # 输出：['a', 'b', 'c']
     print(rdd5.collect())  # 输出：['a', 'b', 'c']
     sc.stop()
  # 4.读取文件数据，将文件内容转换为RDD对象
     # 4.1.PySpark支持通过SparkContext对象的textFile成员方法，将文件转换为PySpark的RDD
       # 例如：
       rdd = sc.textFile("D:\\bigdata\\spark\\data\\input\\1.txt")
       print(rdd.collect())
     # 4.2.PySpark支持通过SparkContext对象的wholeTextFiles成员方法，将多个文件转换为PySpark的RDD 
       # 例如：
       rdd = sc.wholeTextFiles("D:\\bigdata\\spark\\data\\input\\")
       print(rdd.collect())
     # 4.3.PySpark支持通过SparkContext对象的sequenceFile成员方法，将文件转换为PySpark的RDD
       # 例如：
       rdd = sc.sequenceFile("D:\\bigdata\\spark\\data\\input\\1.txt")
       print(rdd.collect())
     # 4.4.PySpark支持通过SparkContext对象的objectFile成员方法，将文件转换为PySpark的RDD
       # 例如：
       rdd = sc.objectFile("D:\\bigdata\\spark\\data\\input\\1.txt")
       print(rdd.collect())
     # 4.5.PySpark支持通过SparkContext对象的hadoopFile成员方法，将文件转换为PySpark的RDD
       # 例如：
       rdd = sc.hadoopFile("D:\\bigdata\\spark\\data\\input\\1.txt")
       print(rdd.collect())
     # 4.6.PySpark支持通过SparkContext对象的pickleFile成员方法，将文件转换为PySpark的RDD
       # 例如：
       rdd = sc.pickleFile("D:\\bigdata\\spark\\data\\input\\1.txt")
       print(rdd.collect())
     # 4.7.PySpark支持通过SparkContext对象的newAPIHadoopFile成员方法，将文件转换为PySpark的RDD
       # 例如：
       rdd = sc.newAPIHadoopFile("D:\\bigdata\\spark\\data\\input\\1.txt")
       print(rdd.collect())
     # 4.8.PySpark支持通过SparkContext对象的binaryFiles成员方法，将文件转换为PySpark的RDD
       # 例如：
       rdd = sc.binaryFiles("D:\\bigdata\\spark\\data\\input\\")
       print(rdd.collect())
  # 注意：
    # 字符串会被拆分出1个个的字符，存入RDD对象
    # 字典仅有key会被存入RDD对象
  ```

- 5.数据计算
- ```python
  # 1.map方法（成员方法，也叫算子）
    # 功能：map算子，是将RDD的数据一条条处理（处理的逻辑基于map算子中接收的处理函数，可以用lambda表达式快速编写），返回新的RDD
    # 语法：
  
      # rdd.map(func)
        # func: f(T) -> U
          # (T)->U 表示方法的定义
          # ()表示传入参数， (T) 表示传入1个参数，() 表示没有传入参数
          # T 是泛型的代称，在这里表示任意类型
          # U 也是泛型的代称，在这里表示任意类型
          # U 表示返回值
          # (T)->U :这是一个方法，这个方法接收一个参数，参数类型不限，返回一个返回值，返回值类型不限
          # (A)->A :这是一个方法，这个方法接收一个参数，参数类型不限，返回一个返回值，返回值类型和传入参数类型一致
  
    # 例如: 
      from pyspark import SparkContext, SparkConf
      import os
      os.environ['PYSPARK_PYTHON'] = "D:/Python/python3.8/python.exe"
      # 创建一个RDD对象
      rdd = sc.parallelize([1,2,3,4,5])
      # 使用map算子，将RDD中的每个元素乘以2
      rdd_map = rdd.map(lambda x: x*2)
      print(rdd_map.collect())
      # 链式调用
       # 对于返回值是新RDD的算子，可以通过链式调用的方式多次调用算子
      rdd_map.map(lambda x: x*2).collect()
  
  # 2.flatMap方法（成员方法，也叫算子）
    # 功能：对RDD执行map操作，然后进行解除嵌套操作（扁平化处理）。
    # 语法：
      # rdd.flatMap(func) # func 等同于map
    # 例如：
      from pyspark import SparkContext, SparkConf
      import os
      os.environ['PYSPARK_PYTHON'] = "D:/Python/python3.8/python.exe" 
      # 创建一个RDD对象
      rdd = sc.parallelize(["hello world", "hello spark", "hello hadoop"]) 
      # 使用flatMap算子，将RDD中的每个元素进行分割
      rdd_map = rdd.map(lambda x: x.split(" "))
      print(rdd_map.collect())
      rdd_flatMap = rdd.flatMap(lambda x: x.split(" "))
      print(rdd_flatMap.collect())
      # 打印结果
      # map： [['hello', 'world'], ['hello', 'spark'], ['hello', 'hadoop']]
      # flatmap：['hello', 'world', 'hello', 'spark', 'hello', 'hadoop']
  
  # 3.reduceByKey方法（成员方法，也叫算子）
    # 功能：针对KV型（二元元组）RDD,自动按照key分组，然后根据你提供的聚合逻辑，完成组内数据(value)的聚合操作。 
    # 语法：
      # rdd.reduceByKey(func)
        # func:(v,v)->v
        # 接受2个参数（类型要一致），返回一个返回值，类型和传入要一致
    # 例如：
      from pyspark import SparkContext, SparkConf
      import os
      os.environ['PYSPARK_PYTHON'] = "D:/Python/python3.8/python.exe"
      # 创建一个RDD对象
      rdd = sc.parallelize([("hello", 1), ("hello", 2), ("spark", 3),
                                  ("spark", 4), ("hadoop", 5), ("hadoop", 6)])
      # 使用reduceByKey算子，将RDD中的每个元素按照key进行分组，然后根据你提供的聚合逻辑，完成组内
      # 数据(value)的聚合操作
      rdd_reduceByKey = rdd.reduceByKey(lambda x, y: x + y)
      print(rdd_reduceByKey.collect())
      # 打印结果： [('hello', 3), ('spark', 7), ('hadoop', 11)]
    # 注意：
      # 1.reduceByKey中接收的函数，只负责聚合，不理会分组
      # 2.分组是自动by key 来分组的
  
  # 4.filter方法
    # 功能：对RDD中的每个元素进行过滤，返回过滤后的元素
    # 语法：
      # rdd.filter(func)
        # func:(v)->bool
        # 返回一个布尔值，返回True的元素保留，返回False的元素丢弃
    # 例如：
      from pyspark import SparkContext, SparkConf
      import os
      os.environ['PYSPARK_PYTHON'] = "D:/Python/python3.8/python.exe"
      # 创建conf对象 
      conf = SparkConf().setMaster("local[*]").setAppName("test_app")
      # 创建context对象
      sc = SparkContext(conf=conf)
      # 创建一个RDD对象
      rdd = sc.parallelize([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
      # 使用filter算子，对RDD中的每个元素进行过滤，返回过滤后的元素
      rdd_filter = rdd.filter(lambda x: x % 2 == 0)
      print(rdd_filter.collect())
      # 打印结果：[2, 4, 6, 8, 10]
  
  # 5.distinct方法
    # 功能：对RDD中的每个元素进行去重操作
    # 语法：
      # rdd.distinct() # 无参数
    # 例如：
      from pyspark import SparkContext, SparkConf
      import os
      os.environ['PYSPARK_PYTHON'] = "D:/Python/python3.8/python.exe"
      # 创建conf对象
      conf = SparkConf().setMaster("local[*]").setAppName("test_app")
      # 创建context对象
      sc = SparkContext(conf=conf)
      # 创建一个RDD对象
      rdd = sc.parallelize([1, 2, 3, 4, 4, 4, 5, 6, 7, 8]) 
      # 使用distinct算子，对RDD中的每个元素进行去重操作
      rdd_distinct = rdd.distinct()
      print(rdd_distinct.collect())
      # 打印结果：[1, 2, 3, 4, 5, 6, 7, 8]
  
  # 6.sortBy方法
    # 功能：对RDD中的元素进行排序操作
    # 语法：
      # rdd.sortBy(func, ascending=True,numPartitions=1) 
        # func:(T)->U 告知按照rdd中的哪个数据进行排序，比如 lambda x: x[1] 表示按照rdd中的第二个数据进行排序 
        # ascending=True/False 表示升序/降序排序
        # numPartitions=1 表示用多少分区数排序，默认为1 
    # 例如：
      from pyspark import SparkContext, SparkConf
      import os
      os.environ['PYSPARK_PYTHON'] = "D:/Python/python3.8/python.exe"
      # 创建conf对象
      conf = SparkConf().setMaster("local[*]").setAppName("test_app")
      # 创建context对象
      sc = SparkContext(conf=conf) 
      # 创建一个RDD对象
      rdd = sc.parallelize([(1, 'a'), (2, 'b'), (3, 'c'), (4, 'd')])
      # 使用sortBy算子，对RDD中的元素进行排序操作
      rdd_sortBy = rdd.sortBy(lambda x: x[0], ascending=True)
      print(rdd_sortBy.collect())
      # 打印结果：[(1, 'a'), (2, 'b'), (3, 'c'), (4, 'd')]
  ```

- 6.数据输出
- ```python
  # 1.collect方法 
    # 功能：将RDD各个分区的数据统一收集到Driver中，形成一个list对象
    # 语法：
      # rdd.collect() 
      # 返回值是一个list
    # 例如： 
      from pyspark import SparkContext, SparkConf
      import os
      os.environ['PYSPARK_PYTHON'] = "D:/Python/python3.8/python.exe"
      # 创建conf对象
      conf = SparkConf().setMaster("local[*]").setAppName("test_app")
      # 创建context对象
      sc = SparkContext(conf=conf)
      # 创建一个RDD对象
      rdd = sc.parallelize([(1, 'a'), (2, 'b'), (3, 'c'), (4, 'd')])
      # 使用collect算子，将RDD中的数据收集到Driver中
      rdd_collect = rdd.collect()
      print(rdd_collect)
      # 打印结果：[(1, 'a'), (2, 'b'), (3, 'c'), (4, 'd')]
  
  # 2.reduce方法
    # 功能：对RDD数据集按照你传入的逻辑进行聚合
    # 语法：
      # rdd.reduce(func)
      # func:(T,T) -> T
      # 2个参数传入 1个返回值 返回值和参数要求类型一致
    # 例如：
      from pyspark import SparkContext, SparkConf
      import os
      os.environ['PYSPARK_PYTHON'] = "D:/Python/python3.8/python.exe"
      # 创建conf对象
      conf = SparkConf().setMaster("local[*]").setAppName("test_app")
      # 创建context对象
      sc = SparkContext(conf=conf)
      # 创建一个RDD对象
      rdd = sc.parallelize([1, 2, 3, 4, 5])
      # 使用reduce算子，对RDD中的数据按照传入的逻辑进行聚合
      rdd_reduce = rdd.reduce(lambda x, y: x + y)
      print(rdd_reduce)
      # 打印结果：15
  
  # 3.take方法
    # 功能：获取RDD中的前n个数据，组合成list返回
    # 语法：
      # rdd.take(n)
      # 参数：n表示获取前n个数据
    # 例如：
      from pyspark import SparkContext, SparkConf
      import os
      os.environ['PYSPARK_PYTHON'] = "D:/Python/python3.8/python.exe"
      # 创建conf对象
      conf = SparkConf().setMaster("local[*]").setAppName("test_app")
      # 创建context对象
      sc = SparkContext(conf=conf)
      # 创建一个RDD对象
      rdd = sc.parallelize([1, 2, 3, 4, 5])
      # 使用take算子，获取RDD中的前3个数据
      rdd_take = rdd.take(3)
      print(rdd_take)
      # 打印结果：[1, 2, 3]
  
  # 4.count方法
    # 功能：获取RDD中数据的个数
    # 语法：
      # rdd.count()
    # 例如：
      from pyspark import SparkContext, SparkConf
      import os
      os.environ['PYSPARK_PYTHON'] = "D:/Python/python3.8/python.exe"
      # 创建conf对象
      conf = SparkConf().setMaster("local[*]").setAppName("test_app")
      # 创建context对象
      sc = SparkContext(conf=conf)
      # 创建一个RDD对象
      rdd = sc.parallelize([1, 2, 3, 4, 5])
      # 使用count算子，获取RDD中数据的个数
      rdd_count = rdd.count()
      print(rdd_count)
      # 打印结果：5
  
  # 5.saveAsTextFile方法
    # 功能：将RDD中的数据保存到本地文件中,支持本地写出，hdfs等文件系统
    # 语法： 
      # rdd.saveAsTextFile(path)
      # 参数：path表示保存的文件路径 
    # 例如：
      from pyspark import SparkContext, SparkConf
      import os
      os.environ['PYSPARK_PYTHON'] = "D:/Python/python3.8/python.exe"
      os.environ['HADOOP_HOME'] = "D:/useSoftware/hadoop/hadoop-3.0.0"
      # 创建conf对象
      conf = SparkConf().setMaster("local[*]").setAppName("test_app")
      conf.set("spark.default.parallelism", "1") # 写入一个分区文件
      # 创建context对象
      sc = SparkContext(conf=conf)
      # 创建一个RDD对象
      rdd = sc.parallelize([1, 2, 3, 4, 5])
      # 使用saveAsTextFile算子，将RDD中的数据保存到本地文件中
      rdd.saveAsTextFile("D:/test.txt")
    # 修改rdd分区为1个
      1.第一种方法：SparkConf对象设置属性全局并行度为1
        conf.set("spark.default.parallelism", "1")
      2.第二种方法：创建RDD的时候设置（parallelize方法传入numSlices参数为1）
        rdd.parallelize([1, 2, 3, 4, 5],numSlices=1)
         rdd.parallelize([1, 2, 3, 4, 5],1)
  
  # 注意：链式调用过多可以换行，使用'\'进行换行
    # 例如：
      rdd.saveAsTextFile("D:/test.txt").\
          saveAsTextFile("D:/test1.txt").\
          saveAsTextFile("D:/test2.txt")
  ```

- #### 25.高阶技巧

- 1.闭包
- ```python
  # 闭包：闭包是一个函数，该函数定义在一个函数内部，并且该函数引用了外部函数的变量
  # 闭包的作用：可以实现累加器的效果
  # 例如：
    # 定义一个外部函数
    def outer_func(start):
      # 定义一个内部函数
      def inner_func(param):
        nonlocal start # 需要使用nonlocal关键字修饰外部函数的变量，才可在内部函数中修改它
        start += param
        return start
      return inner_func # 注意将内部函数返回出去
    # 调用外部函数，并返回内部函数
    result = outer_func(10)
    # 调用内部函数，并传入参数
    result(5)  # 结果为15
    result(10) # 结果为25
  # 注意：
    # 优点： 
      # 1. 无需定义全局变量即可实现通过函数，持续的访问、修改值
      # 2. 闭包使用的变量所用在函数内，难以被错误的调用修改
    # 缺点：
      # 1.由于内部函数持续引用外部函数值，所以会导致这一部分内存空间不被释放，一直占用内存，导致内存泄漏。
  ```

- 2.装饰器
- ```python
  # 装饰器其实也是一种闭包，其功能就是在不破坏目标函数原有的代码和功能的前提下，为目标函数增加新的功能
  # 例如： 
    # 定义一个装饰器函数
      def outer(fun):
          # 定义闭包函数
          def inner():
            print("我睡觉了")
            # 调用参数函数
            fun()
            print("我起床了")
          # 将闭包函数返回
          return inner
  
    # 定义一个目标函数
      # 使用装饰器函数
      @outer
      def sleep():
          import time
          import random
          print("睡眠中....")
          time.sleep(random.randint(1, 5))

      # 调用目标函数
      sleep()
  ```

- 2.设计模式
- ```python
  # 设计模式是一种编程套路，可以极大的方便程序的开发，最常见、最经典的设计模式，就是面向对象，
  # 除了面向对象以外，在编程中也有很多既定的套路可以方便我们开发，我们称之为设计模式，
  # 例如：单例模式、工厂模式、建造者模式、责任链模式、状态模式、备忘录模式、解释器模式、访问者模式、观察者模式、
  # 中介模式、模板模式、代理模式、装饰器模式、策略模式等等。
  
  # 1. 单例模式
    # 定义：确保某一个类只有一个实例，并提供一个访问它的全局访问点，
    # 适用场景：当一个类只有一个实例，而客户可以从一个众所周知的访问点访问它时。
    # 例如：
      class Singleton:
          # 定义一个类变量，用于保存类的实例
          _instance = None
          # 定义一个类方法，用于获取类的实例
          @classmethod
          def get_instance(cls):
              # 如果类的实例不存在，则创建一个实例
              if not cls._instance:
                  cls._instance = cls()
              # 返回类的实例
              return cls._instance
      # 创建两个类的实例
      s1 = Singleton.get_instance()
      s2 = Singleton.get_instance()
      # 判断两个实例是否相等
      print(s1 == s2)  # 输出：True
      
  # 2. 工厂模式
    # 定义：定义一个用于创建对象的接口，让子类决定实例化哪一个类
    #      将对象的创建由使用原生类本身创建，转换到由特定的工厂方法来创建
    # 好处：
      # 1. 大批量创建对象的时候有统一的入口，易于代码维护
      # 2. 当发生修改，仅修改工厂类的创建方法即可
      # 3. 符合现实世界模式，即由工厂来制作产品（对象）
    # 适用场景：当一个类不知道它所需要的对象的类的时候，或者当一个类希望由它的子类来指定它所创建的对象时
    # 例如：
      class Animal:
          def __init__(self, name):
              self.name = name
      
      class Dog(Animal):
          def __init__(self, name):
              super().__init__(name)
              self.type = "dog"
      
      class Cat(Animal):
          def __init__(self, name):
              super().__init__(name)
              self.type = "cat"
      
      # 定义一个工厂类，用于创建Animal类的子类
      class AnimalFactory:
          @staticmethod
          def create_animal(type, name):
              if type == "dog":
                  return Dog(name)
              elif type == "cat":
                  return Cat(name)
              else:
                  return None
      
      # 使用工厂类创建Animal类的子类实例
      dog = AnimalFactory.create_animal("dog", "Buddy")
      cat = AnimalFactory.create_animal("cat", "Kitty")
      print(dog.name, dog.type)  # 输出：Buddy dog
      print(cat.name, cat.type)  # 输出：Kitty cat
  ```

- 3.多线程
- ```python
  # 进程：就是一个程序，运行在系统之上，那么便称之这个程序为一个运行进程，并分配进程ID方便系统管理
  # 线程：线程是归属于进程的，一个进程可以开启多个线程，执行不同的工作，是进程的实际工作最小单位
  # 操作系统中可以运行多个进程，即多任务运行
  # 一个进程内可以运行多个线程，即多线程运行
  # 注意点：
    # 进程之间是内存隔离的，即不同的进程拥有各自的内存空间。
    # 线程之间是内存共享的，线程是属于进程的，一个进程内多个线程之间是共享这个进程所拥有的内存空间的。
  
  # 并行执行：
    # 并行执行指的是多个任务在同一时刻被多个CPU同时执行。
    # 进程之间就是并行执行的，操作系统可以同时运行多个程序，这些程序都是在并行执行
    # 除了进程外，线程其实也是可以并行执行的
  
  # 多线程编程：
    # threading模块
    # 导入模块
    import threading
    # 创建线程
    # t = threading.Thread([group[,target[, name[, args[, kwargs]]]]])
    # group:暂时无用，未来功能的预留参数
    # target:执行的目标任务名
    # name:线程名，一般不用设置
    # args:给target传参，以元组的形式传入 
    # kwargs:给target传参，以字典的形式传入
    # 例如：
    # 创建任务
     def sing(msg):
         print(f"我是通过args传入的参数：{msg}")
     def dance(msg):
         print(f"我是通过kwargs传入的参数：{msg}")
     # 创建线程
     t1 = threading.Thread(target=sing, args=("我是一个参数",))
     t2 = threading.Thread(target=dance, kwargs={"msg":"我是一个参数"})
    # 启动线程
    # t.start()
    # 等待线程结束
    # t.join()
    # 判断线程是否存活
    # t.is_alive()
    # 设置线程名
    # t.setName(name)
    # 获取线程名
    # t.getName()
    # 设置线程优先级
    # t.setPriority(priority)
    # 获取线程优先级
    # t.getPriority()
    # 判断线程是否是守护线程
    # t.isDaemon()
    # 设置线程是否是守护线程
    # t.setDaemon(daemon)
    # 判断线程是否是alive状态
    # t.isAlive()
    # 获取线程的运行状态
    # t.exitcode
    # 设置线程的运行状态
    # t.setExitcode(exitcode)
  ```

- 4.网络编程
- ```python
  # socket
    # socket（简称套接字）是进程之间的通信工具，进程之间想要进行网络通信需要socket
    # socket负责进程之间的网络数据传输，好比数据搬运工
  
  # 客户端和服务端
    # 2个进程之间通过Socket进行相互通讯，就必须有服务端和客户端
    # Socket服务端：等待其它进程的连接、可接受发来的消息、可回复消息
    # Socket客户端：主动连接服务端、可发送消息、可接收回复消息
  
  # Socket服务端编程
    # 1.创建socket对象
      # import socket
      # server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  
    # 2.绑定IP和端口
      # server.bind((host, port)) # 注意传入的是元组
  
    # 3.开启监听
      # server.listen(backlog)
      # backlog为int整数，表示允许的连接数量，超出的会等待，可以不填，不填会自动设置一个合理值
  
    # 4.接收客户端的连接，获取连接对象
      # conn, addr = server.accept()
      # conn表示连接对象，addr表示客户端的IP和端口
      # accept方法是阻塞方法，如果没有连接，会卡在当前这一行不向下执行代码
      # accept返回的是一个二元元组，可以使用上述形式，用两个变量接收二元元组的两个元素
  
    # 5.客户端连接后，通过recv方法，接收客户端发送的消息
      # while True:
           # data = conn.recv(1024).decode("utf-8")
           # recv方法的返回值是字节数据（Bytes），可以通过decode使用UTF-8解码成字符串
           # recv方法的传参是buffsize,缓冲区大小，一般设置为1024即可
           # if data == "exit":
               # break
           # print(f"接收到发送来的消息：{data}")
      # 可以通过while True 无限循环来持续和客户端进行数据交互
      # 可以通过判定客户端发来的特殊标记，如：exit，来退出无限循环
  
    # 6.通过conn（客户端当次连接对象）调用send方法可以回复消息
      # while True:
            # data = conn.recv(1024).decode("utf-8")
            # if data == "exit":
                # break
            # print(f"接收到发送来的消息：{data}")
            # conn.send(f"服务端回复：{data}".encode("utf-8"))
  
    # 7.关闭连接
       # conn（客户端当次连接对象）和server对象调用close方法，关闭连接
       # server.close()
       # conn.close()
  
  # Socket客户端编程
    # 1.创建socket对象
      # import socket
      # client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
      # AF_INET表示使用IPv4地址，SOCK_STREAM表示使用面向流的TCP协议
      # 创建socket对象后，会返回一个socket对象
  
    # 2.连接服务器
      # client.connect((host, port))
    
    # 3.发送消息
      # while True:
          # msg = input("请输入要发送的消息：")
          # if msg == "exit":
              # break
          # client.send(msg.encode("utf-8")) # 消息需要编码为字节数组（UTF-8编码）
  
    # 4.接收消息
      # while True:
          # data = client.recv(1024) # 1024是缓冲区大小，一般为1024即可
          # print(f"接收到发送来的消息：{data.decode("utf-8")}") # 接收的消息需要通过UTF-8解码为字符串
  
   # 5.关闭连接
       # client.close() # 最后通过close方法关闭连接
  ```

- 5.正则表达式
- ```python
  # 正则表达式：又称为规则表达式（Regular Expression），是使用单个字符串来描述、匹配某个句法规则的字符串，
    # 常被用来检索、替换那些符合某个句法规则的文本。
    # 简单地说：正则表达式就是使用：字符串定义规则，并通过规则去验证字符串是否匹配
   
  # 正则的三个基础方法
    # Python正则表达式，使用re模块，并基于re模块中三个基础方法来做正则匹配。
    # 分别是：match、search、findall 三个基础方法
    # 1.re.match(匹配规则, 被匹配的字符串) 
      # 从被匹配的字符串的起始位置开始匹配，匹配成功返回匹配对象（包含匹配的信息），匹配不成功返回空
      # 从头开始匹配，匹配第一个命中项
      # 例如：
        # import re
        # ret = re.match("1","123") 
        # print(ret) # 输出：<_sre.SRE_Match object; span=(0, 1), match='1'>
        # ret = re.match("2","123")
        # print(ret) # 输出：None 1开头，2非1 所以无法匹配返回None
  
    # 2.re.search(匹配规则, 被匹配的字符串)
      # 从被匹配的字符串的任意位置开始匹配，匹配成功返回匹配对象（包含匹配的信息），匹配不成功返回空
      # 全局匹配，匹配第一个命中项
      # 例如：
        # import re
        # ret = re.search("1","123")
        # print(ret) # 输出：<_sre.SRE_Match object; span=(0, 1), match='1'>
        # ret = re.search("2","123")
        # print(ret) # 输出：<_sre.SRE_Match object; span=(1, 2), match='2'>
  
    # 3.re.findall(匹配规则, 被匹配的字符串)
      # 匹配所有符合规则的字符串，并返回一个列表
      # 全局匹配，匹配全部命中项
      # 例如：
        # import re
        # ret = re.findall("1","123123123")
        # print(ret) # 输出：[1, 1, 1, 1]
        # ret = re.findall("2","123123123") 
        # print(ret) # 输出：[2,2,2]
  
  # 元字符匹配
    # 单字符匹配：
      # .    匹配任意1个字符（除了\n），\.匹配点本身
      # []   匹配[]中列举的字符
      # \d   匹配数字，等价于[0-9] 
      # \D   匹配非数字，等价于[^0-9]
      # \s   匹配空白，即空格、tab键，等价于[ \t\n\x0b\f\r]
      # \S   匹配非空白，等价于[^\s]
      # \w   匹配数字、字母、下划线，等价于[A-Za-z0-9_] 
      # \W   匹配非数字、字母、下划线，等价于[^A-Za-z0-9_]
  
      # 例如：
        # import re
        # ret = re.findall(r'\d',"rrr12d3r4w5ff")
        # print(ret) # 输出：['1', '2', '3', '4', '5']
        # 字符串的r标记，表示当前字符串是原始字符串，即字符串中出现的转义字符不发生转义
  
    # 数量匹配：
      # *    匹配前一个规则的字符出现0至无数次，等价于{0,} 
      # +    匹配前一个规则的字符出现1至无数次，等价于{1,}
      # ?    匹配前一个规则的字符出现0或1次，等价于{0,1} 
      # {m}  匹配前一个规则的字符出现m次 
      # {m,} 匹配前一个规则的字符出现至少m次，等价于{m,}
      # {m,n} 匹配前一个规则的字符出现m至n次，等价于{m,n}
  
    # 边界匹配：
      # ^   以什么什么什么开头
      # $   以什么什么什么结尾
      # \b  匹配一个单词的边界，即在单词和空格间的位置
      # \B  匹配非单词的边界
  
    # 分组匹配：
      # |   匹配左右任意一个表达式
      # ()  将括号中的字符作为一个分组
  
    # 例如：
      # 1.匹配账号，只能由字母、数字组成，长度限制6到10位
        # import re 
        # ret = re.findall(r'[a-zA-Z0-9]{6,10}',"1234567890")
        # print(ret) # 输出：['1234567890'] 
      
      # 2.匹配邮箱地址，只允许qq、163、gmail这三种邮箱 
        # import re
        # ret = re.findall(r'^[\w-]+(\.[\w-]+)*@(qq|163|gmail)(\.[\w-]+)+$',"1234567890@qq.com")
        # print(ret) # 输出：['1234567890@qq.com']
  ```
  
- 6.递归
- ```python
  # 递归：
    # 递归函数：在函数内部调用函数本身
    # 递归的结束条件：在递归函数中，当满足某个条件时，不再调用函数本身，而是返回一个结果，
      # 递归的结束条件，一定要放在递归函数的内部，否则递归函数将无法结束，从而导致栈溢出。
    # 递归的缺点：
      # 递归调用栈可能会很长，占用大量的内存空间。
    # 递归的优点：
      # 递归可以简化代码，提高代码的可读性和可维护性。
  
    # 例如：
      # 1.计算阶乘
        # def factorial(n):
          # if n == 0:
            # return 1
          # else:
            # return n * factorial(n-1)
        # print(factorial(5)) # 输出：120
  
    # 注意：
      # 注意退出条件，否则容易变成无限递归
      # 注意返回值的传递，确保从最内层，层层传递到最外层
  
    # os模块的3个方法：
      # os.listdir(path) 返回指定路径下的所有文件和文件夹
      # os.path.exists(path) 判断指定路径是否存在,存在为True,不存在为False
      # os.path.isdir(path) 判断指定路径是否为文件夹,是返回True,不是返回False
  ```


